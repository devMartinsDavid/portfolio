{"ast":null,"code":"import _asyncToGenerator from \"C:/projetos/meus projetos/portfolio/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * @license Angular v19.2.3\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { ɵDeferBlockState as _DeferBlockState, ɵtriggerResourceLoading as _triggerResourceLoading, ɵrenderDeferBlockState as _renderDeferBlockState, ɵCONTAINER_HEADER_OFFSET as _CONTAINER_HEADER_OFFSET, ɵgetDeferBlocks as _getDeferBlocks, InjectionToken, ɵDeferBlockBehavior as _DeferBlockBehavior, inject as inject$1, NgZone, ErrorHandler, Injectable, ɵNoopNgZone as _NoopNgZone, ApplicationRef, ɵPendingTasksInternal as _PendingTasksInternal, ɵZONELESS_ENABLED as _ZONELESS_ENABLED, ɵChangeDetectionScheduler as _ChangeDetectionScheduler, ɵEffectScheduler as _EffectScheduler, ɵMicrotaskEffectScheduler as _MicrotaskEffectScheduler, getDebugNode, RendererFactory2, ɵstringify as _stringify, Pipe, Directive, Component, NgModule, ɵReflectionCapabilities as _ReflectionCapabilities, ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT as _USE_RUNTIME_DEPS_TRACKER_FOR_JIT, ɵdepsTracker as _depsTracker, ɵgetInjectableDef as _getInjectableDef, resolveForwardRef, ɵisComponentDefPendingResolution as _isComponentDefPendingResolution, ɵgetAsyncClassMetadataFn as _getAsyncClassMetadataFn, ɵresolveComponentResources as _resolveComponentResources, ɵRender3NgModuleRef as _Render3NgModuleRef, ApplicationInitStatus, LOCALE_ID, ɵDEFAULT_LOCALE_ID as _DEFAULT_LOCALE_ID, ɵsetLocaleId as _setLocaleId, ɵRender3ComponentFactory as _Render3ComponentFactory, ɵNG_COMP_DEF as _NG_COMP_DEF, ɵcompileComponent as _compileComponent, ɵNG_DIR_DEF as _NG_DIR_DEF, ɵcompileDirective as _compileDirective, ɵNG_PIPE_DEF as _NG_PIPE_DEF, ɵcompilePipe as _compilePipe, ɵNG_MOD_DEF as _NG_MOD_DEF, ɵpatchComponentDefWithScope as _patchComponentDefWithScope, ɵNG_INJ_DEF as _NG_INJ_DEF, ɵcompileNgModuleDefs as _compileNgModuleDefs, ɵclearResolutionOfComponentResourcesQueue as _clearResolutionOfComponentResourcesQueue, ɵrestoreComponentResolutionQueue as _restoreComponentResolutionQueue, ɵinternalProvideZoneChangeDetection as _internalProvideZoneChangeDetection, ɵChangeDetectionSchedulerImpl as _ChangeDetectionSchedulerImpl, Compiler, ɵDEFER_BLOCK_CONFIG as _DEFER_BLOCK_CONFIG, ɵINTERNAL_APPLICATION_ERROR_HANDLER as _INTERNAL_APPLICATION_ERROR_HANDLER, COMPILER_OPTIONS, Injector, ɵtransitiveScopesFor as _transitiveScopesFor, ɵgenerateStandaloneInDeclarationsError as _generateStandaloneInDeclarationsError, ɵNgModuleFactory as _NgModuleFactory, ModuleWithComponentFactories, ɵisEnvironmentProviders as _isEnvironmentProviders, ɵconvertToBitFlags as _convertToBitFlags, InjectFlags, ɵsetAllowDuplicateNgModuleIdsForTest as _setAllowDuplicateNgModuleIdsForTest, ɵresetCompiledComponents as _resetCompiledComponents, ɵsetUnknownElementStrictMode as _setUnknownElementStrictMode, ɵsetUnknownPropertyStrictMode as _setUnknownPropertyStrictMode, ɵgetUnknownElementStrictMode as _getUnknownElementStrictMode, ɵgetUnknownPropertyStrictMode as _getUnknownPropertyStrictMode, runInInjectionContext, EnvironmentInjector, ɵflushModuleScopingQueueAsMuchAsPossible as _flushModuleScopingQueueAsMuchAsPossible } from '@angular/core';\nexport { ɵDeferBlockBehavior as DeferBlockBehavior, ɵDeferBlockState as DeferBlockState } from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { ResourceLoader } from '@angular/compiler';\n\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```ts\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * })));\n * ```\n *\n * @publicApi\n */\nfunction waitForAsync(fn) {\n  const _Zone = typeof Zone !== 'undefined' ? Zone : null;\n  if (!_Zone) {\n    return function () {\n      return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js');\n    };\n  }\n  const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n  if (typeof asyncTest === 'function') {\n    return asyncTest(fn);\n  }\n  return function () {\n    return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' + 'Please make sure that your environment includes zone.js/testing');\n  };\n}\n\n/**\n * Represents an individual defer block for testing purposes.\n *\n * @publicApi\n */\nclass DeferBlockFixture {\n  block;\n  componentFixture;\n  /** @nodoc */\n  constructor(block, componentFixture) {\n    this.block = block;\n    this.componentFixture = componentFixture;\n  }\n  /**\n   * Renders the specified state of the defer fixture.\n   * @param state the defer state to render\n   */\n  render(state) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (!hasStateTemplate(state, _this.block)) {\n        const stateAsString = getDeferBlockStateNameFromEnum(state);\n        throw new Error(`Tried to render this defer block in the \\`${stateAsString}\\` state, ` + `but there was no @${stateAsString.toLowerCase()} block defined in a template.`);\n      }\n      if (state === _DeferBlockState.Complete) {\n        yield _triggerResourceLoading(_this.block.tDetails, _this.block.lView, _this.block.tNode);\n      }\n      // If the `render` method is used explicitly - skip timer-based scheduling for\n      // `@placeholder` and `@loading` blocks and render them immediately.\n      const skipTimerScheduling = true;\n      _renderDeferBlockState(state, _this.block.tNode, _this.block.lContainer, skipTimerScheduling);\n      _this.componentFixture.detectChanges();\n    })();\n  }\n  /**\n   * Retrieves all nested child defer block fixtures\n   * in a given defer block.\n   */\n  getDeferBlocks() {\n    const deferBlocks = [];\n    // An LContainer that represents a defer block has at most 1 view, which is\n    // located right after an LContainer header. Get a hold of that view and inspect\n    // it for nested defer blocks.\n    const deferBlockFixtures = [];\n    if (this.block.lContainer.length >= _CONTAINER_HEADER_OFFSET) {\n      const lView = this.block.lContainer[_CONTAINER_HEADER_OFFSET];\n      _getDeferBlocks(lView, deferBlocks);\n      for (const block of deferBlocks) {\n        deferBlockFixtures.push(new DeferBlockFixture(block, this.componentFixture));\n      }\n    }\n    return Promise.resolve(deferBlockFixtures);\n  }\n}\nfunction hasStateTemplate(state, block) {\n  switch (state) {\n    case _DeferBlockState.Placeholder:\n      return block.tDetails.placeholderTmplIndex !== null;\n    case _DeferBlockState.Loading:\n      return block.tDetails.loadingTmplIndex !== null;\n    case _DeferBlockState.Error:\n      return block.tDetails.errorTmplIndex !== null;\n    case _DeferBlockState.Complete:\n      return true;\n    default:\n      return false;\n  }\n}\nfunction getDeferBlockStateNameFromEnum(state) {\n  switch (state) {\n    case _DeferBlockState.Placeholder:\n      return 'Placeholder';\n    case _DeferBlockState.Loading:\n      return 'Loading';\n    case _DeferBlockState.Error:\n      return 'Error';\n    default:\n      return 'Main';\n  }\n}\n\n/** Whether test modules should be torn down by default. */\nconst TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;\n/** Whether unknown elements in templates should throw by default. */\nconst THROW_ON_UNKNOWN_ELEMENTS_DEFAULT = false;\n/** Whether unknown properties in templates should throw by default. */\nconst THROW_ON_UNKNOWN_PROPERTIES_DEFAULT = false;\n/** Whether defer blocks should use manual triggering or play through normally. */\nconst DEFER_BLOCK_DEFAULT_BEHAVIOR = _DeferBlockBehavior.Playthrough;\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\nclass TestComponentRenderer {\n  insertRootElement(rootElementId) {}\n  removeAllRootElements() {}\n}\n/**\n * @publicApi\n */\nconst ComponentFixtureAutoDetect = new InjectionToken('ComponentFixtureAutoDetect');\n/**\n * @publicApi\n */\nconst ComponentFixtureNoNgZone = new InjectionToken('ComponentFixtureNoNgZone');\nconst RETHROW_APPLICATION_ERRORS_DEFAULT = true;\nclass TestBedApplicationErrorHandler {\n  zone = inject$1(NgZone);\n  userErrorHandler = inject$1(ErrorHandler);\n  whenStableRejectFunctions = new Set();\n  handleError(e) {\n    try {\n      this.zone.runOutsideAngular(() => this.userErrorHandler.handleError(e));\n    } catch (userError) {\n      e = userError;\n    }\n    // Instead of throwing the error when there are outstanding `fixture.whenStable` promises,\n    // reject those promises with the error. This allows developers to write\n    // expectAsync(fix.whenStable()).toBeRejected();\n    if (this.whenStableRejectFunctions.size > 0) {\n      for (const fn of this.whenStableRejectFunctions.values()) {\n        fn(e);\n      }\n      this.whenStableRejectFunctions.clear();\n    } else {\n      throw e;\n    }\n  }\n  static ɵfac = function TestBedApplicationErrorHandler_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || TestBedApplicationErrorHandler)();\n  };\n  static ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: TestBedApplicationErrorHandler,\n    factory: TestBedApplicationErrorHandler.ɵfac\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TestBedApplicationErrorHandler, [{\n    type: Injectable\n  }], null, null);\n})();\n\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\nclass ComponentFixture {\n  componentRef;\n  /**\n   * The DebugElement associated with the root element of this component.\n   */\n  debugElement;\n  /**\n   * The instance of the root component class.\n   */\n  componentInstance;\n  /**\n   * The native element at the root of the component.\n   */\n  nativeElement;\n  /**\n   * The ElementRef for the element at the root of the component.\n   */\n  elementRef;\n  /**\n   * The ChangeDetectorRef for the component\n   */\n  changeDetectorRef;\n  _renderer;\n  _isDestroyed = false;\n  /** @internal */\n  _noZoneOptionIsSet = inject$1(ComponentFixtureNoNgZone, {\n    optional: true\n  });\n  /** @internal */\n  _ngZone = this._noZoneOptionIsSet ? new _NoopNgZone() : inject$1(NgZone);\n  // Inject ApplicationRef to ensure NgZone stableness causes after render hooks to run\n  // This will likely happen as a result of fixture.detectChanges because it calls ngZone.run\n  // This is a crazy way of doing things but hey, it's the world we live in.\n  // The zoneless scheduler should instead do this more imperatively by attaching\n  // the `ComponentRef` to `ApplicationRef` and calling `appRef.tick` as the `detectChanges`\n  // behavior.\n  /** @internal */\n  _appRef = inject$1(ApplicationRef);\n  _testAppRef = this._appRef;\n  pendingTasks = inject$1(_PendingTasksInternal);\n  appErrorHandler = inject$1(TestBedApplicationErrorHandler);\n  zonelessEnabled = inject$1(_ZONELESS_ENABLED);\n  scheduler = inject$1(_ChangeDetectionScheduler);\n  rootEffectScheduler = inject$1(_EffectScheduler);\n  microtaskEffectScheduler = inject$1(_MicrotaskEffectScheduler);\n  autoDetectDefault = this.zonelessEnabled ? true : false;\n  autoDetect = inject$1(ComponentFixtureAutoDetect, {\n    optional: true\n  }) ?? this.autoDetectDefault;\n  subscriptions = new Subscription();\n  // TODO(atscott): Remove this from public API\n  ngZone = this._noZoneOptionIsSet ? null : this._ngZone;\n  /** @nodoc */\n  constructor(componentRef) {\n    this.componentRef = componentRef;\n    this.changeDetectorRef = componentRef.changeDetectorRef;\n    this.elementRef = componentRef.location;\n    this.debugElement = getDebugNode(this.elementRef.nativeElement);\n    this.componentInstance = componentRef.instance;\n    this.nativeElement = this.elementRef.nativeElement;\n    this.componentRef = componentRef;\n    if (this.autoDetect) {\n      this._testAppRef.externalTestViews.add(this.componentRef.hostView);\n      this.scheduler?.notify(8 /* ɵNotificationSource.ViewAttached */);\n      this.scheduler?.notify(0 /* ɵNotificationSource.MarkAncestorsForTraversal */);\n    }\n    this.componentRef.hostView.onDestroy(() => {\n      this._testAppRef.externalTestViews.delete(this.componentRef.hostView);\n    });\n    // Create subscriptions outside the NgZone so that the callbacks run outside\n    // of NgZone.\n    this._ngZone.runOutsideAngular(() => {\n      this.subscriptions.add(this._ngZone.onError.subscribe({\n        next: error => {\n          throw error;\n        }\n      }));\n    });\n  }\n  /**\n   * Trigger a change detection cycle for the component.\n   */\n  detectChanges(checkNoChanges = true) {\n    this.microtaskEffectScheduler.flush();\n    const originalCheckNoChanges = this.componentRef.changeDetectorRef.checkNoChanges;\n    try {\n      if (!checkNoChanges) {\n        this.componentRef.changeDetectorRef.checkNoChanges = () => {};\n      }\n      if (this.zonelessEnabled) {\n        try {\n          this._testAppRef.externalTestViews.add(this.componentRef.hostView);\n          this._appRef.tick();\n        } finally {\n          if (!this.autoDetect) {\n            this._testAppRef.externalTestViews.delete(this.componentRef.hostView);\n          }\n        }\n      } else {\n        // Run the change detection inside the NgZone so that any async tasks as part of the change\n        // detection are captured by the zone and can be waited for in isStable.\n        this._ngZone.run(() => {\n          // Flush root effects before `detectChanges()`, to emulate the sequencing of `tick()`.\n          this.rootEffectScheduler.flush();\n          this.changeDetectorRef.detectChanges();\n          this.checkNoChanges();\n        });\n      }\n    } finally {\n      this.componentRef.changeDetectorRef.checkNoChanges = originalCheckNoChanges;\n    }\n    this.microtaskEffectScheduler.flush();\n  }\n  /**\n   * Do a change detection run to make sure there were no changes.\n   */\n  checkNoChanges() {\n    this.changeDetectorRef.checkNoChanges();\n  }\n  /**\n   * Set whether the fixture should autodetect changes.\n   *\n   * Also runs detectChanges once so that any existing change is detected.\n   *\n   * @param autoDetect Whether to autodetect changes. By default, `true`.\n   */\n  autoDetectChanges(autoDetect = true) {\n    if (this._noZoneOptionIsSet && !this.zonelessEnabled) {\n      throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set.');\n    }\n    if (autoDetect !== this.autoDetect) {\n      if (autoDetect) {\n        this._testAppRef.externalTestViews.add(this.componentRef.hostView);\n      } else {\n        this._testAppRef.externalTestViews.delete(this.componentRef.hostView);\n      }\n    }\n    this.autoDetect = autoDetect;\n    this.detectChanges();\n  }\n  /**\n   * Return whether the fixture is currently stable or has async tasks that have not been completed\n   * yet.\n   */\n  isStable() {\n    return !this.pendingTasks.hasPendingTasks.value;\n  }\n  /**\n   * Get a promise that resolves when the fixture is stable.\n   *\n   * This can be used to resume testing after events have triggered asynchronous activity or\n   * asynchronous change detection.\n   */\n  whenStable() {\n    if (this.isStable()) {\n      return Promise.resolve(false);\n    }\n    return new Promise((resolve, reject) => {\n      this.appErrorHandler.whenStableRejectFunctions.add(reject);\n      this._appRef.whenStable().then(() => {\n        this.appErrorHandler.whenStableRejectFunctions.delete(reject);\n        resolve(true);\n      });\n    });\n  }\n  /**\n   * Retrieves all defer block fixtures in the component fixture.\n   */\n  getDeferBlocks() {\n    const deferBlocks = [];\n    const lView = this.componentRef.hostView['_lView'];\n    _getDeferBlocks(lView, deferBlocks);\n    const deferBlockFixtures = [];\n    for (const block of deferBlocks) {\n      deferBlockFixtures.push(new DeferBlockFixture(block, this));\n    }\n    return Promise.resolve(deferBlockFixtures);\n  }\n  _getRenderer() {\n    if (this._renderer === undefined) {\n      this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n    }\n    return this._renderer;\n  }\n  /**\n   * Get a promise that resolves when the ui state is stable following animations.\n   */\n  whenRenderingDone() {\n    const renderer = this._getRenderer();\n    if (renderer && renderer.whenRenderingDone) {\n      return renderer.whenRenderingDone();\n    }\n    return this.whenStable();\n  }\n  /**\n   * Trigger component destruction.\n   */\n  destroy() {\n    this.subscriptions.unsubscribe();\n    this._testAppRef.externalTestViews.delete(this.componentRef.hostView);\n    if (!this._isDestroyed) {\n      this.componentRef.destroy();\n      this._isDestroyed = true;\n    }\n  }\n}\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\nconst fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\nconst fakeAsyncTestModuleNotLoadedErrorMessage = `zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing`;\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\nfunction resetFakeAsyncZone() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.resetFakeAsyncZone();\n  }\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\nfunction resetFakeAsyncZoneIfExists() {\n  if (fakeAsyncTestModule) {\n    fakeAsyncTestModule.resetFakeAsyncZone();\n  }\n}\n/**\n * Wraps a function to be executed in the `fakeAsync` zone:\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\n *\n * Can be used to wrap `inject()` calls.\n *\n * @param fn The function that you want to wrap in the `fakeAsync` zone.\n * @param options\n *   - flush: When true, will drain the macrotask queue after the test function completes.\n *     When false, will throw an exception at the end of the function if there are pending timers.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n *\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\n * Any arguments passed when calling this returned function will be passed through to the `fn`\n * function in the parameters when it is called.\n *\n * @publicApi\n */\nfunction fakeAsync(fn, options) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.fakeAsync(fn, options);\n  }\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @param millis The number of milliseconds to advance the virtual timer.\n * @param tickOptions The options to pass to the `tick()` function.\n *\n * @usageNotes\n *\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\n * which determines whether or not to invoke new macroTasks.\n *\n * If you provide a `tickOptions` object, but do not specify a\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\n * then `processNewMacroTasksSynchronously` defaults to true.\n *\n * If you omit the `tickOptions` parameter (`tick(100))`), then\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\n *\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * The following example includes a nested timeout (new macroTask), and\n * the `tickOptions` parameter is allowed to default. In this case,\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\n * function is executed on each tick.\n *\n * ```ts\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n * ```\n *\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\n * set to false, so the nested timeout function is not invoked.\n *\n * ```ts\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n * ```\n *\n *\n * @publicApi\n */\nfunction tick(millis = 0, tickOptions = {\n  processNewMacroTasksSynchronously: true\n}) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.tick(millis, tickOptions);\n  }\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flushes any pending microtasks and simulates the asynchronous passage of time for the timers in\n * the `fakeAsync` zone by\n * draining the macrotask queue until it is empty.\n *\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\n *     throwing an error.\n * @returns The simulated time elapsed, in milliseconds.\n *\n * @publicApi\n */\nfunction flush(maxTurns) {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.flush(maxTurns);\n  }\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\nfunction discardPeriodicTasks() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.discardPeriodicTasks();\n  }\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\nfunction flushMicrotasks() {\n  if (fakeAsyncTestModule) {\n    return fakeAsyncTestModule.flushMicrotasks();\n  }\n  throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\nlet _nextReferenceId = 0;\nclass MetadataOverrider {\n  _references = new Map();\n  /**\n   * Creates a new instance for the given metadata class\n   * based on an old instance and overrides.\n   */\n  overrideMetadata(metadataClass, oldMetadata, override) {\n    const props = {};\n    if (oldMetadata) {\n      _valueProps(oldMetadata).forEach(prop => props[prop] = oldMetadata[prop]);\n    }\n    if (override.set) {\n      if (override.remove || override.add) {\n        throw new Error(`Cannot set and add/remove ${_stringify(metadataClass)} at the same time!`);\n      }\n      setMetadata(props, override.set);\n    }\n    if (override.remove) {\n      removeMetadata(props, override.remove, this._references);\n    }\n    if (override.add) {\n      addMetadata(props, override.add);\n    }\n    return new metadataClass(props);\n  }\n}\nfunction removeMetadata(metadata, remove, references) {\n  const removeObjects = new Set();\n  for (const prop in remove) {\n    const removeValue = remove[prop];\n    if (Array.isArray(removeValue)) {\n      removeValue.forEach(value => {\n        removeObjects.add(_propHashKey(prop, value, references));\n      });\n    } else {\n      removeObjects.add(_propHashKey(prop, removeValue, references));\n    }\n  }\n  for (const prop in metadata) {\n    const propValue = metadata[prop];\n    if (Array.isArray(propValue)) {\n      metadata[prop] = propValue.filter(value => !removeObjects.has(_propHashKey(prop, value, references)));\n    } else {\n      if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n        metadata[prop] = undefined;\n      }\n    }\n  }\n}\nfunction addMetadata(metadata, add) {\n  for (const prop in add) {\n    const addValue = add[prop];\n    const propValue = metadata[prop];\n    if (propValue != null && Array.isArray(propValue)) {\n      metadata[prop] = propValue.concat(addValue);\n    } else {\n      metadata[prop] = addValue;\n    }\n  }\n}\nfunction setMetadata(metadata, set) {\n  for (const prop in set) {\n    metadata[prop] = set[prop];\n  }\n}\nfunction _propHashKey(propName, propValue, references) {\n  let nextObjectId = 0;\n  const objectIds = new Map();\n  const replacer = (key, value) => {\n    if (value !== null && typeof value === 'object') {\n      if (objectIds.has(value)) {\n        return objectIds.get(value);\n      }\n      // Record an id for this object such that any later references use the object's id instead\n      // of the object itself, in order to break cyclic pointers in objects.\n      objectIds.set(value, `ɵobj#${nextObjectId++}`);\n      // The first time an object is seen the object itself is serialized.\n      return value;\n    } else if (typeof value === 'function') {\n      value = _serializeReference(value, references);\n    }\n    return value;\n  };\n  return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\nfunction _serializeReference(ref, references) {\n  let id = references.get(ref);\n  if (!id) {\n    id = `${_stringify(ref)}${_nextReferenceId++}`;\n    references.set(ref, id);\n  }\n  return id;\n}\nfunction _valueProps(obj) {\n  const props = [];\n  // regular public props\n  Object.keys(obj).forEach(prop => {\n    if (!prop.startsWith('_')) {\n      props.push(prop);\n    }\n  });\n  // getters\n  let proto = obj;\n  while (proto = Object.getPrototypeOf(proto)) {\n    Object.keys(proto).forEach(protoProp => {\n      const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n      if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n        props.push(protoProp);\n      }\n    });\n  }\n  return props;\n}\nconst reflection = new _ReflectionCapabilities();\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\nclass OverrideResolver {\n  overrides = new Map();\n  resolved = new Map();\n  addOverride(type, override) {\n    const overrides = this.overrides.get(type) || [];\n    overrides.push(override);\n    this.overrides.set(type, overrides);\n    this.resolved.delete(type);\n  }\n  setOverrides(overrides) {\n    this.overrides.clear();\n    overrides.forEach(([type, override]) => {\n      this.addOverride(type, override);\n    });\n  }\n  getAnnotation(type) {\n    const annotations = reflection.annotations(type);\n    // Try to find the nearest known Type annotation and make sure that this annotation is an\n    // instance of the type we are looking for, so we can use it for resolution. Note: there might\n    // be multiple known annotations found due to the fact that Components can extend Directives (so\n    // both Directive and Component annotations would be present), so we always check if the known\n    // annotation has the right type.\n    for (let i = annotations.length - 1; i >= 0; i--) {\n      const annotation = annotations[i];\n      const isKnownType = annotation instanceof Directive || annotation instanceof Component || annotation instanceof Pipe || annotation instanceof NgModule;\n      if (isKnownType) {\n        return annotation instanceof this.type ? annotation : null;\n      }\n    }\n    return null;\n  }\n  resolve(type) {\n    let resolved = this.resolved.get(type) || null;\n    if (!resolved) {\n      resolved = this.getAnnotation(type);\n      if (resolved) {\n        const overrides = this.overrides.get(type);\n        if (overrides) {\n          const overrider = new MetadataOverrider();\n          overrides.forEach(override => {\n            resolved = overrider.overrideMetadata(this.type, resolved, override);\n          });\n        }\n      }\n      this.resolved.set(type, resolved);\n    }\n    return resolved;\n  }\n}\nclass DirectiveResolver extends OverrideResolver {\n  get type() {\n    return Directive;\n  }\n}\nclass ComponentResolver extends OverrideResolver {\n  get type() {\n    return Component;\n  }\n}\nclass PipeResolver extends OverrideResolver {\n  get type() {\n    return Pipe;\n  }\n}\nclass NgModuleResolver extends OverrideResolver {\n  get type() {\n    return NgModule;\n  }\n}\nvar TestingModuleOverride;\n(function (TestingModuleOverride) {\n  TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n  TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n})(TestingModuleOverride || (TestingModuleOverride = {}));\nfunction isTestingModuleOverride(value) {\n  return value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE;\n}\nfunction assertNoStandaloneComponents(types, resolver, location) {\n  types.forEach(type => {\n    if (!_getAsyncClassMetadataFn(type)) {\n      const component = resolver.resolve(type);\n      if (component && (component.standalone == null || component.standalone)) {\n        throw new Error(_generateStandaloneInDeclarationsError(type, location));\n      }\n    }\n  });\n}\nclass TestBedCompiler {\n  platform;\n  additionalModuleTypes;\n  originalComponentResolutionQueue = null;\n  // Testing module configuration\n  declarations = [];\n  imports = [];\n  providers = [];\n  schemas = [];\n  // Queues of components/directives/pipes that should be recompiled.\n  pendingComponents = new Set();\n  pendingDirectives = new Set();\n  pendingPipes = new Set();\n  // Set of components with async metadata, i.e. components with `@defer` blocks\n  // in their templates.\n  componentsWithAsyncMetadata = new Set();\n  // Keep track of all components and directives, so we can patch Providers onto defs later.\n  seenComponents = new Set();\n  seenDirectives = new Set();\n  // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n  overriddenModules = new Set();\n  // Store resolved styles for Components that have template overrides present and `styleUrls`\n  // defined at the same time.\n  existingComponentStyles = new Map();\n  resolvers = initResolvers();\n  // Map of component type to an NgModule that declares it.\n  //\n  // There are a couple special cases:\n  // - for standalone components, the module scope value is `null`\n  // - when a component is declared in `TestBed.configureTestingModule()` call or\n  //   a component's template is overridden via `TestBed.overrideTemplateUsingTestingModule()`.\n  //   we use a special value from the `TestingModuleOverride` enum.\n  componentToModuleScope = new Map();\n  // Map that keeps initial version of component/directive/pipe defs in case\n  // we compile a Type again, thus overriding respective static fields. This is\n  // required to make sure we restore defs to their initial states between test runs.\n  // Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of an\n  // NgModule), store all of them in a map.\n  initialNgDefs = new Map();\n  // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n  // defs in case TestBed makes changes to the originals.\n  defCleanupOps = [];\n  _injector = null;\n  compilerProviders = null;\n  providerOverrides = [];\n  rootProviderOverrides = [];\n  // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n  // module's provider list.\n  providerOverridesByModule = new Map();\n  providerOverridesByToken = new Map();\n  scopesWithOverriddenProviders = new Set();\n  testModuleType;\n  testModuleRef = null;\n  deferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n  rethrowApplicationTickErrors = RETHROW_APPLICATION_ERRORS_DEFAULT;\n  constructor(platform, additionalModuleTypes) {\n    this.platform = platform;\n    this.additionalModuleTypes = additionalModuleTypes;\n    class DynamicTestModule {}\n    this.testModuleType = DynamicTestModule;\n  }\n  setCompilerProviders(providers) {\n    this.compilerProviders = providers;\n    this._injector = null;\n  }\n  configureTestingModule(moduleDef) {\n    // Enqueue any compilation tasks for the directly declared component.\n    if (moduleDef.declarations !== undefined) {\n      // Verify that there are no standalone components\n      assertNoStandaloneComponents(moduleDef.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\n      this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n      this.declarations.push(...moduleDef.declarations);\n    }\n    // Enqueue any compilation tasks for imported modules.\n    if (moduleDef.imports !== undefined) {\n      this.queueTypesFromModulesArray(moduleDef.imports);\n      this.imports.push(...moduleDef.imports);\n    }\n    if (moduleDef.providers !== undefined) {\n      this.providers.push(...moduleDef.providers);\n    }\n    if (moduleDef.schemas !== undefined) {\n      this.schemas.push(...moduleDef.schemas);\n    }\n    this.deferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    this.rethrowApplicationTickErrors = moduleDef.rethrowApplicationErrors ?? RETHROW_APPLICATION_ERRORS_DEFAULT;\n  }\n  overrideModule(ngModule, override) {\n    if (_USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n      _depsTracker.clearScopeCacheFor(ngModule);\n    }\n    this.overriddenModules.add(ngModule);\n    // Compile the module right away.\n    this.resolvers.module.addOverride(ngModule, override);\n    const metadata = this.resolvers.module.resolve(ngModule);\n    if (metadata === null) {\n      throw invalidTypeError(ngModule.name, 'NgModule');\n    }\n    this.recompileNgModule(ngModule, metadata);\n    // At this point, the module has a valid module def (ɵmod), but the override may have introduced\n    // new declarations or imported modules. Ingest any possible new types and add them to the\n    // current queue.\n    this.queueTypesFromModulesArray([ngModule]);\n  }\n  overrideComponent(component, override) {\n    this.verifyNoStandaloneFlagOverrides(component, override);\n    this.resolvers.component.addOverride(component, override);\n    this.pendingComponents.add(component);\n    // If this is a component with async metadata (i.e. a component with a `@defer` block\n    // in a template) - store it for future processing.\n    this.maybeRegisterComponentWithAsyncMetadata(component);\n  }\n  overrideDirective(directive, override) {\n    this.verifyNoStandaloneFlagOverrides(directive, override);\n    this.resolvers.directive.addOverride(directive, override);\n    this.pendingDirectives.add(directive);\n  }\n  overridePipe(pipe, override) {\n    this.verifyNoStandaloneFlagOverrides(pipe, override);\n    this.resolvers.pipe.addOverride(pipe, override);\n    this.pendingPipes.add(pipe);\n  }\n  verifyNoStandaloneFlagOverrides(type, override) {\n    if (override.add?.hasOwnProperty('standalone') || override.set?.hasOwnProperty('standalone') || override.remove?.hasOwnProperty('standalone')) {\n      throw new Error(`An override for the ${type.name} class has the \\`standalone\\` flag. ` + `Changing the \\`standalone\\` flag via TestBed overrides is not supported.`);\n    }\n  }\n  overrideProvider(token, provider) {\n    let providerDef;\n    if (provider.useFactory !== undefined) {\n      providerDef = {\n        provide: token,\n        useFactory: provider.useFactory,\n        deps: provider.deps || [],\n        multi: provider.multi\n      };\n    } else if (provider.useValue !== undefined) {\n      providerDef = {\n        provide: token,\n        useValue: provider.useValue,\n        multi: provider.multi\n      };\n    } else {\n      providerDef = {\n        provide: token\n      };\n    }\n    const injectableDef = typeof token !== 'string' ? _getInjectableDef(token) : null;\n    const providedIn = injectableDef === null ? null : resolveForwardRef(injectableDef.providedIn);\n    const overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n    overridesBucket.push(providerDef);\n    // Keep overrides grouped by token as well for fast lookups using token\n    this.providerOverridesByToken.set(token, providerDef);\n    if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n      const existingOverrides = this.providerOverridesByModule.get(providedIn);\n      if (existingOverrides !== undefined) {\n        existingOverrides.push(providerDef);\n      } else {\n        this.providerOverridesByModule.set(providedIn, [providerDef]);\n      }\n    }\n  }\n  overrideTemplateUsingTestingModule(type, template) {\n    const def = type[_NG_COMP_DEF];\n    const hasStyleUrls = () => {\n      const metadata = this.resolvers.component.resolve(type);\n      return !!metadata.styleUrl || !!metadata.styleUrls?.length;\n    };\n    const overrideStyleUrls = !!def && !_isComponentDefPendingResolution(type) && hasStyleUrls();\n    // In Ivy, compiling a component does not require knowing the module providing the\n    // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n    // overrideComponent. Important: overriding template requires full Component re-compilation,\n    // which may fail in case styleUrls are also present (thus Component is considered as required\n    // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n    // preserve current styles available on Component def and restore styles back once compilation\n    // is complete.\n    const override = overrideStyleUrls ? {\n      template,\n      styles: [],\n      styleUrls: [],\n      styleUrl: undefined\n    } : {\n      template\n    };\n    this.overrideComponent(type, {\n      set: override\n    });\n    if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n      this.existingComponentStyles.set(type, def.styles);\n    }\n    // Set the component's scope to be the testing module.\n    this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n  }\n  resolvePendingComponentsWithAsyncMetadata() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.componentsWithAsyncMetadata.size === 0) return;\n      const promises = [];\n      for (const component of _this2.componentsWithAsyncMetadata) {\n        const asyncMetadataFn = _getAsyncClassMetadataFn(component);\n        if (asyncMetadataFn) {\n          promises.push(asyncMetadataFn());\n        }\n      }\n      _this2.componentsWithAsyncMetadata.clear();\n      const resolvedDeps = yield Promise.all(promises);\n      const flatResolvedDeps = resolvedDeps.flat(2);\n      _this2.queueTypesFromModulesArray(flatResolvedDeps);\n      // Loaded standalone components might contain imports of NgModules\n      // with providers, make sure we override providers there too.\n      for (const component of flatResolvedDeps) {\n        _this2.applyProviderOverridesInScope(component);\n      }\n    })();\n  }\n  compileComponents() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.clearComponentResolutionQueue();\n      // Wait for all async metadata for components that were\n      // overridden, we need resolved metadata to perform an override\n      // and re-compile a component.\n      yield _this3.resolvePendingComponentsWithAsyncMetadata();\n      // Verify that there were no standalone components present in the `declarations` field\n      // during the `TestBed.configureTestingModule` call. We perform this check here in addition\n      // to the logic in the `configureTestingModule` function, since at this point we have\n      // all async metadata resolved.\n      assertNoStandaloneComponents(_this3.declarations, _this3.resolvers.component, '\"TestBed.configureTestingModule\" call');\n      // Run compilers for all queued types.\n      let needsAsyncResources = _this3.compileTypesSync();\n      // compileComponents() should not be async unless it needs to be.\n      if (needsAsyncResources) {\n        let resourceLoader;\n        let resolver = url => {\n          if (!resourceLoader) {\n            resourceLoader = _this3.injector.get(ResourceLoader);\n          }\n          return Promise.resolve(resourceLoader.get(url));\n        };\n        yield _resolveComponentResources(resolver);\n      }\n    })();\n  }\n  finalize() {\n    // One last compile\n    this.compileTypesSync();\n    // Create the testing module itself.\n    this.compileTestModule();\n    this.applyTransitiveScopes();\n    this.applyProviderOverrides();\n    // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\n    // Components have `styleUrls` fields defined and template override was requested.\n    this.patchComponentsWithExistingStyles();\n    // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n    // every component.\n    this.componentToModuleScope.clear();\n    const parentInjector = this.platform.injector;\n    this.testModuleRef = new _Render3NgModuleRef(this.testModuleType, parentInjector, []);\n    // ApplicationInitStatus.runInitializers() is marked @internal to core.\n    // Cast it to any before accessing it.\n    this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers();\n    // Set locale ID after running app initializers, since locale information might be updated while\n    // running initializers. This is also consistent with the execution order while bootstrapping an\n    // app (see `packages/core/src/application_ref.ts` file).\n    const localeId = this.testModuleRef.injector.get(LOCALE_ID, _DEFAULT_LOCALE_ID);\n    _setLocaleId(localeId);\n    return this.testModuleRef;\n  }\n  /**\n   * @internal\n   */\n  _compileNgModuleSync(moduleType) {\n    this.queueTypesFromModulesArray([moduleType]);\n    this.compileTypesSync();\n    this.applyProviderOverrides();\n    this.applyProviderOverridesInScope(moduleType);\n    this.applyTransitiveScopes();\n  }\n  /**\n   * @internal\n   */\n  _compileNgModuleAsync(moduleType) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      _this4.queueTypesFromModulesArray([moduleType]);\n      yield _this4.compileComponents();\n      _this4.applyProviderOverrides();\n      _this4.applyProviderOverridesInScope(moduleType);\n      _this4.applyTransitiveScopes();\n    })();\n  }\n  /**\n   * @internal\n   */\n  _getModuleResolver() {\n    return this.resolvers.module;\n  }\n  /**\n   * @internal\n   */\n  _getComponentFactories(moduleType) {\n    return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories, declaration) => {\n      const componentDef = declaration.ɵcmp;\n      componentDef && factories.push(new _Render3ComponentFactory(componentDef, this.testModuleRef));\n      return factories;\n    }, []);\n  }\n  compileTypesSync() {\n    // Compile all queued components, directives, pipes.\n    let needsAsyncResources = false;\n    this.pendingComponents.forEach(declaration => {\n      if (_getAsyncClassMetadataFn(declaration)) {\n        throw new Error(`Component '${declaration.name}' has unresolved metadata. ` + `Please call \\`await TestBed.compileComponents()\\` before running this test.`);\n      }\n      needsAsyncResources = needsAsyncResources || _isComponentDefPendingResolution(declaration);\n      const metadata = this.resolvers.component.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Component');\n      }\n      this.maybeStoreNgDef(_NG_COMP_DEF, declaration);\n      if (_USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n        _depsTracker.clearScopeCacheFor(declaration);\n      }\n      _compileComponent(declaration, metadata);\n    });\n    this.pendingComponents.clear();\n    this.pendingDirectives.forEach(declaration => {\n      const metadata = this.resolvers.directive.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Directive');\n      }\n      this.maybeStoreNgDef(_NG_DIR_DEF, declaration);\n      _compileDirective(declaration, metadata);\n    });\n    this.pendingDirectives.clear();\n    this.pendingPipes.forEach(declaration => {\n      const metadata = this.resolvers.pipe.resolve(declaration);\n      if (metadata === null) {\n        throw invalidTypeError(declaration.name, 'Pipe');\n      }\n      this.maybeStoreNgDef(_NG_PIPE_DEF, declaration);\n      _compilePipe(declaration, metadata);\n    });\n    this.pendingPipes.clear();\n    return needsAsyncResources;\n  }\n  applyTransitiveScopes() {\n    if (this.overriddenModules.size > 0) {\n      // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n      // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n      // collect all affected modules and reset scopes to force their re-calculation.\n      const testingModuleDef = this.testModuleType[_NG_MOD_DEF];\n      const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n      if (affectedModules.size > 0) {\n        affectedModules.forEach(moduleType => {\n          if (!_USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n            this.storeFieldOfDefOnType(moduleType, _NG_MOD_DEF, 'transitiveCompileScopes');\n            moduleType[_NG_MOD_DEF].transitiveCompileScopes = null;\n          } else {\n            _depsTracker.clearScopeCacheFor(moduleType);\n          }\n        });\n      }\n    }\n    const moduleToScope = new Map();\n    const getScopeOfModule = moduleType => {\n      if (!moduleToScope.has(moduleType)) {\n        const isTestingModule = isTestingModuleOverride(moduleType);\n        const realType = isTestingModule ? this.testModuleType : moduleType;\n        moduleToScope.set(moduleType, _transitiveScopesFor(realType));\n      }\n      return moduleToScope.get(moduleType);\n    };\n    this.componentToModuleScope.forEach((moduleType, componentType) => {\n      if (moduleType !== null) {\n        const moduleScope = getScopeOfModule(moduleType);\n        this.storeFieldOfDefOnType(componentType, _NG_COMP_DEF, 'directiveDefs');\n        this.storeFieldOfDefOnType(componentType, _NG_COMP_DEF, 'pipeDefs');\n        _patchComponentDefWithScope(getComponentDef(componentType), moduleScope);\n      }\n      // `tView` that is stored on component def contains information about directives and pipes\n      // that are in the scope of this component. Patching component scope will cause `tView` to be\n      // changed. Store original `tView` before patching scope, so the `tView` (including scope\n      // information) is restored back to its previous/original state before running next test.\n      // Resetting `tView` is also needed for cases when we apply provider overrides and those\n      // providers are defined on component's level, in which case they may end up included into\n      // `tView.blueprint`.\n      this.storeFieldOfDefOnType(componentType, _NG_COMP_DEF, 'tView');\n    });\n    this.componentToModuleScope.clear();\n  }\n  applyProviderOverrides() {\n    const maybeApplyOverrides = field => type => {\n      const resolver = field === _NG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n      const metadata = resolver.resolve(type);\n      if (this.hasProviderOverrides(metadata.providers)) {\n        this.patchDefWithProviderOverrides(type, field);\n      }\n    };\n    this.seenComponents.forEach(maybeApplyOverrides(_NG_COMP_DEF));\n    this.seenDirectives.forEach(maybeApplyOverrides(_NG_DIR_DEF));\n    this.seenComponents.clear();\n    this.seenDirectives.clear();\n  }\n  /**\n   * Applies provider overrides to a given type (either an NgModule or a standalone component)\n   * and all imported NgModules and standalone components recursively.\n   */\n  applyProviderOverridesInScope(type) {\n    const hasScope = isStandaloneComponent(type) || isNgModule(type);\n    // The function can be re-entered recursively while inspecting dependencies\n    // of an NgModule or a standalone component. Exit early if we come across a\n    // type that can not have a scope (directive or pipe) or the type is already\n    // processed earlier.\n    if (!hasScope || this.scopesWithOverriddenProviders.has(type)) {\n      return;\n    }\n    this.scopesWithOverriddenProviders.add(type);\n    // NOTE: the line below triggers JIT compilation of the module injector,\n    // which also invokes verification of the NgModule semantics, which produces\n    // detailed error messages. The fact that the code relies on this line being\n    // present here is suspicious and should be refactored in a way that the line\n    // below can be moved (for ex. after an early exit check below).\n    const injectorDef = type[_NG_INJ_DEF];\n    // No provider overrides, exit early.\n    if (this.providerOverridesByToken.size === 0) return;\n    if (isStandaloneComponent(type)) {\n      // Visit all component dependencies and override providers there.\n      const def = getComponentDef(type);\n      const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n      for (const dependency of dependencies) {\n        this.applyProviderOverridesInScope(dependency);\n      }\n    } else {\n      const providers = [...injectorDef.providers, ...(this.providerOverridesByModule.get(type) || [])];\n      if (this.hasProviderOverrides(providers)) {\n        this.maybeStoreNgDef(_NG_INJ_DEF, type);\n        this.storeFieldOfDefOnType(type, _NG_INJ_DEF, 'providers');\n        injectorDef.providers = this.getOverriddenProviders(providers);\n      }\n      // Apply provider overrides to imported modules recursively\n      const moduleDef = type[_NG_MOD_DEF];\n      const imports = maybeUnwrapFn(moduleDef.imports);\n      for (const importedModule of imports) {\n        this.applyProviderOverridesInScope(importedModule);\n      }\n      // Also override the providers on any ModuleWithProviders imports since those don't appear in\n      // the moduleDef.\n      for (const importedModule of flatten(injectorDef.imports)) {\n        if (isModuleWithProviders(importedModule)) {\n          this.defCleanupOps.push({\n            object: importedModule,\n            fieldName: 'providers',\n            originalValue: importedModule.providers\n          });\n          importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n        }\n      }\n    }\n  }\n  patchComponentsWithExistingStyles() {\n    this.existingComponentStyles.forEach((styles, type) => type[_NG_COMP_DEF].styles = styles);\n    this.existingComponentStyles.clear();\n  }\n  queueTypeArray(arr, moduleType) {\n    for (const value of arr) {\n      if (Array.isArray(value)) {\n        this.queueTypeArray(value, moduleType);\n      } else {\n        this.queueType(value, moduleType);\n      }\n    }\n  }\n  recompileNgModule(ngModule, metadata) {\n    // Cache the initial ngModuleDef as it will be overwritten.\n    this.maybeStoreNgDef(_NG_MOD_DEF, ngModule);\n    this.maybeStoreNgDef(_NG_INJ_DEF, ngModule);\n    _compileNgModuleDefs(ngModule, metadata);\n  }\n  maybeRegisterComponentWithAsyncMetadata(type) {\n    const asyncMetadataFn = _getAsyncClassMetadataFn(type);\n    if (asyncMetadataFn) {\n      this.componentsWithAsyncMetadata.add(type);\n    }\n  }\n  queueType(type, moduleType) {\n    // If this is a component with async metadata (i.e. a component with a `@defer` block\n    // in a template) - store it for future processing.\n    this.maybeRegisterComponentWithAsyncMetadata(type);\n    const component = this.resolvers.component.resolve(type);\n    if (component) {\n      // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\n      // missing. That might happen in case a class without any Angular decorators extends another\n      // class where Component/Directive/Pipe decorator is defined.\n      if (_isComponentDefPendingResolution(type) || !type.hasOwnProperty(_NG_COMP_DEF)) {\n        this.pendingComponents.add(type);\n      }\n      this.seenComponents.add(type);\n      // Keep track of the module which declares this component, so later the component's scope\n      // can be set correctly. If the component has already been recorded here, then one of several\n      // cases is true:\n      // * the module containing the component was imported multiple times (common).\n      // * the component is declared in multiple modules (which is an error).\n      // * the component was in 'declarations' of the testing module, and also in an imported module\n      //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n      // * overrideTemplateUsingTestingModule was called for the component in which case the module\n      //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n      //\n      // If the component was previously in the testing module's 'declarations' (meaning the\n      // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n      // real module, which was imported. This pattern is understood to mean that the component\n      // should use its original scope, but that the testing module should also contain the\n      // component in its scope.\n      if (!this.componentToModuleScope.has(type) || this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\n        this.componentToModuleScope.set(type, moduleType);\n      }\n      return;\n    }\n    const directive = this.resolvers.directive.resolve(type);\n    if (directive) {\n      if (!type.hasOwnProperty(_NG_DIR_DEF)) {\n        this.pendingDirectives.add(type);\n      }\n      this.seenDirectives.add(type);\n      return;\n    }\n    const pipe = this.resolvers.pipe.resolve(type);\n    if (pipe && !type.hasOwnProperty(_NG_PIPE_DEF)) {\n      this.pendingPipes.add(type);\n      return;\n    }\n  }\n  queueTypesFromModulesArray(arr) {\n    // Because we may encounter the same NgModule or a standalone Component while processing\n    // the dependencies of an NgModule or a standalone Component, we cache them in this set so we\n    // can skip ones that have already been seen encountered. In some test setups, this caching\n    // resulted in 10X runtime improvement.\n    const processedDefs = new Set();\n    const queueTypesFromModulesArrayRecur = arr => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          queueTypesFromModulesArrayRecur(value);\n        } else if (hasNgModuleDef(value)) {\n          const def = value.ɵmod;\n          if (processedDefs.has(def)) {\n            continue;\n          }\n          processedDefs.add(def);\n          // Look through declarations, imports, and exports, and queue\n          // everything found there.\n          this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n          queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n        } else if (isModuleWithProviders(value)) {\n          queueTypesFromModulesArrayRecur([value.ngModule]);\n        } else if (isStandaloneComponent(value)) {\n          this.queueType(value, null);\n          const def = getComponentDef(value);\n          if (processedDefs.has(def)) {\n            continue;\n          }\n          processedDefs.add(def);\n          const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n          dependencies.forEach(dependency => {\n            // Note: in AOT, the `dependencies` might also contain regular\n            // (NgModule-based) Component, Directive and Pipes, so we handle\n            // them separately and proceed with recursive process for standalone\n            // Components and NgModules only.\n            if (isStandaloneComponent(dependency) || hasNgModuleDef(dependency)) {\n              queueTypesFromModulesArrayRecur([dependency]);\n            } else {\n              this.queueType(dependency, null);\n            }\n          });\n        }\n      }\n    };\n    queueTypesFromModulesArrayRecur(arr);\n  }\n  // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n  // that import (even transitively) an overridden one. For all affected modules we need to\n  // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n  // of this function is to collect all affected modules in a set for further processing. Example:\n  // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n  // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n  // invalidated with the override.\n  collectModulesAffectedByOverrides(arr) {\n    const seenModules = new Set();\n    const affectedModules = new Set();\n    const calcAffectedModulesRecur = (arr, path) => {\n      for (const value of arr) {\n        if (Array.isArray(value)) {\n          // If the value is an array, just flatten it (by invoking this function recursively),\n          // keeping \"path\" the same.\n          calcAffectedModulesRecur(value, path);\n        } else if (hasNgModuleDef(value)) {\n          if (seenModules.has(value)) {\n            // If we've seen this module before and it's included into \"affected modules\" list, mark\n            // the whole path that leads to that module as affected, but do not descend into its\n            // imports, since we already examined them before.\n            if (affectedModules.has(value)) {\n              path.forEach(item => affectedModules.add(item));\n            }\n            continue;\n          }\n          seenModules.add(value);\n          if (this.overriddenModules.has(value)) {\n            path.forEach(item => affectedModules.add(item));\n          }\n          // Examine module imports recursively to look for overridden modules.\n          const moduleDef = value[_NG_MOD_DEF];\n          calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n        }\n      }\n    };\n    calcAffectedModulesRecur(arr, []);\n    return affectedModules;\n  }\n  /**\n   * Preserve an original def (such as ɵmod, ɵinj, etc) before applying an override.\n   * Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of\n   * an NgModule). If there is a def in a set already, don't override it, since\n   * an original one should be restored at the end of a test.\n   */\n  maybeStoreNgDef(prop, type) {\n    if (!this.initialNgDefs.has(type)) {\n      this.initialNgDefs.set(type, new Map());\n    }\n    const currentDefs = this.initialNgDefs.get(type);\n    if (!currentDefs.has(prop)) {\n      const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n      currentDefs.set(prop, currentDef);\n    }\n  }\n  storeFieldOfDefOnType(type, defField, fieldName) {\n    const def = type[defField];\n    const originalValue = def[fieldName];\n    this.defCleanupOps.push({\n      object: def,\n      fieldName,\n      originalValue\n    });\n  }\n  /**\n   * Clears current components resolution queue, but stores the state of the queue, so we can\n   * restore it later. Clearing the queue is required before we try to compile components (via\n   * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n   */\n  clearComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue === null) {\n      this.originalComponentResolutionQueue = new Map();\n    }\n    _clearResolutionOfComponentResourcesQueue().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));\n  }\n  /*\n   * Restores component resolution queue to the previously saved state. This operation is performed\n   * as a part of restoring the state after completion of the current set of tests (that might\n   * potentially mutate the state).\n   */\n  restoreComponentResolutionQueue() {\n    if (this.originalComponentResolutionQueue !== null) {\n      _restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n      this.originalComponentResolutionQueue = null;\n    }\n  }\n  restoreOriginalState() {\n    // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n    // case there were multiple overrides for the same field).\n    forEachRight(this.defCleanupOps, op => {\n      op.object[op.fieldName] = op.originalValue;\n    });\n    // Restore initial component/directive/pipe defs\n    this.initialNgDefs.forEach((defs, type) => {\n      if (_USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n        _depsTracker.clearScopeCacheFor(type);\n      }\n      defs.forEach((descriptor, prop) => {\n        if (!descriptor) {\n          // Delete operations are generally undesirable since they have performance\n          // implications on objects they were applied to. In this particular case, situations\n          // where this code is invoked should be quite rare to cause any noticeable impact,\n          // since it's applied only to some test cases (for example when class with no\n          // annotations extends some @Component) when we need to clear 'ɵcmp' field on a given\n          // class to restore its original state (before applying overrides and running tests).\n          delete type[prop];\n        } else {\n          Object.defineProperty(type, prop, descriptor);\n        }\n      });\n    });\n    this.initialNgDefs.clear();\n    this.scopesWithOverriddenProviders.clear();\n    this.restoreComponentResolutionQueue();\n    // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n    _setLocaleId(_DEFAULT_LOCALE_ID);\n  }\n  compileTestModule() {\n    class RootScopeModule {}\n    _compileNgModuleDefs(RootScopeModule, {\n      providers: [...this.rootProviderOverrides, _internalProvideZoneChangeDetection({}), TestBedApplicationErrorHandler, {\n        provide: _ChangeDetectionScheduler,\n        useExisting: _ChangeDetectionSchedulerImpl\n      }]\n    });\n    const providers = [{\n      provide: Compiler,\n      useFactory: () => new R3TestCompiler(this)\n    }, {\n      provide: _DEFER_BLOCK_CONFIG,\n      useValue: {\n        behavior: this.deferBlockBehavior\n      }\n    }, {\n      provide: _INTERNAL_APPLICATION_ERROR_HANDLER,\n      useFactory: () => {\n        if (this.rethrowApplicationTickErrors) {\n          const handler = inject$1(TestBedApplicationErrorHandler);\n          return e => {\n            handler.handleError(e);\n          };\n        } else {\n          const userErrorHandler = inject$1(ErrorHandler);\n          const ngZone = inject$1(NgZone);\n          return e => ngZone.runOutsideAngular(() => userErrorHandler.handleError(e));\n        }\n      }\n    }, ...this.providers, ...this.providerOverrides];\n    const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\n    _compileNgModuleDefs(this.testModuleType, {\n      declarations: this.declarations,\n      imports,\n      schemas: this.schemas,\n      providers\n    }, /* allowDuplicateDeclarationsInRoot */true);\n    this.applyProviderOverridesInScope(this.testModuleType);\n  }\n  get injector() {\n    if (this._injector !== null) {\n      return this._injector;\n    }\n    const providers = [];\n    const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS, []);\n    compilerOptions.forEach(opts => {\n      if (opts.providers) {\n        providers.push(opts.providers);\n      }\n    });\n    if (this.compilerProviders !== null) {\n      providers.push(...this.compilerProviders);\n    }\n    this._injector = Injector.create({\n      providers,\n      parent: this.platform.injector\n    });\n    return this._injector;\n  }\n  // get overrides for a specific provider (if any)\n  getSingleProviderOverrides(provider) {\n    const token = getProviderToken(provider);\n    return this.providerOverridesByToken.get(token) || null;\n  }\n  getProviderOverrides(providers) {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n    // There are two flattening operations here. The inner flattenProviders() operates on the\n    // metadata's providers and applies a mapping function which retrieves overrides for each\n    // incoming provider. The outer flatten() then flattens the produced overrides array. If this is\n    // not done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n    // providers array and contaminate any error messages that might be generated.\n    return flatten(flattenProviders(providers, provider => this.getSingleProviderOverrides(provider) || []));\n  }\n  getOverriddenProviders(providers) {\n    if (!providers || !providers.length || this.providerOverridesByToken.size === 0) return [];\n    const flattenedProviders = flattenProviders(providers);\n    const overrides = this.getProviderOverrides(flattenedProviders);\n    const overriddenProviders = [...flattenedProviders, ...overrides];\n    const final = [];\n    const seenOverriddenProviders = new Set();\n    // We iterate through the list of providers in reverse order to make sure provider overrides\n    // take precedence over the values defined in provider list. We also filter out all providers\n    // that have overrides, keeping overridden values only. This is needed, since presence of a\n    // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n    forEachRight(overriddenProviders, provider => {\n      const token = getProviderToken(provider);\n      if (this.providerOverridesByToken.has(token)) {\n        if (!seenOverriddenProviders.has(token)) {\n          seenOverriddenProviders.add(token);\n          // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n          // make sure that provided override takes highest precedence and is not combined with\n          // other instances of the same multi provider.\n          final.unshift({\n            ...provider,\n            multi: false\n          });\n        }\n      } else {\n        final.unshift(provider);\n      }\n    });\n    return final;\n  }\n  hasProviderOverrides(providers) {\n    return this.getProviderOverrides(providers).length > 0;\n  }\n  patchDefWithProviderOverrides(declaration, field) {\n    const def = declaration[field];\n    if (def && def.providersResolver) {\n      this.maybeStoreNgDef(field, declaration);\n      const resolver = def.providersResolver;\n      const processProvidersFn = providers => this.getOverriddenProviders(providers);\n      this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n      def.providersResolver = ngDef => resolver(ngDef, processProvidersFn);\n    }\n  }\n}\nfunction initResolvers() {\n  return {\n    module: new NgModuleResolver(),\n    component: new ComponentResolver(),\n    directive: new DirectiveResolver(),\n    pipe: new PipeResolver()\n  };\n}\nfunction isStandaloneComponent(value) {\n  const def = getComponentDef(value);\n  return !!def?.standalone;\n}\nfunction getComponentDef(value) {\n  return value.ɵcmp ?? null;\n}\nfunction hasNgModuleDef(value) {\n  return value.hasOwnProperty('ɵmod');\n}\nfunction isNgModule(value) {\n  return hasNgModuleDef(value);\n}\nfunction maybeUnwrapFn(maybeFn) {\n  return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\nfunction flatten(values) {\n  const out = [];\n  values.forEach(value => {\n    if (Array.isArray(value)) {\n      out.push(...flatten(value));\n    } else {\n      out.push(value);\n    }\n  });\n  return out;\n}\nfunction identityFn(value) {\n  return value;\n}\nfunction flattenProviders(providers, mapFn = identityFn) {\n  const out = [];\n  for (let provider of providers) {\n    if (_isEnvironmentProviders(provider)) {\n      provider = provider.ɵproviders;\n    }\n    if (Array.isArray(provider)) {\n      out.push(...flattenProviders(provider, mapFn));\n    } else {\n      out.push(mapFn(provider));\n    }\n  }\n  return out;\n}\nfunction getProviderField(provider, field) {\n  return provider && typeof provider === 'object' && provider[field];\n}\nfunction getProviderToken(provider) {\n  return getProviderField(provider, 'provide') || provider;\n}\nfunction isModuleWithProviders(value) {\n  return value.hasOwnProperty('ngModule');\n}\nfunction forEachRight(values, fn) {\n  for (let idx = values.length - 1; idx >= 0; idx--) {\n    fn(values[idx], idx);\n  }\n}\nfunction invalidTypeError(name, expectedType) {\n  return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\nclass R3TestCompiler {\n  testBed;\n  constructor(testBed) {\n    this.testBed = testBed;\n  }\n  compileModuleSync(moduleType) {\n    this.testBed._compileNgModuleSync(moduleType);\n    return new _NgModuleFactory(moduleType);\n  }\n  compileModuleAsync(moduleType) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      yield _this5.testBed._compileNgModuleAsync(moduleType);\n      return new _NgModuleFactory(moduleType);\n    })();\n  }\n  compileModuleAndAllComponentsSync(moduleType) {\n    const ngModuleFactory = this.compileModuleSync(moduleType);\n    const componentFactories = this.testBed._getComponentFactories(moduleType);\n    return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n  }\n  compileModuleAndAllComponentsAsync(moduleType) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const ngModuleFactory = yield _this6.compileModuleAsync(moduleType);\n      const componentFactories = _this6.testBed._getComponentFactories(moduleType);\n      return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    })();\n  }\n  clearCache() {}\n  clearCacheFor(type) {}\n  getModuleId(moduleType) {\n    const meta = this.testBed._getModuleResolver().resolve(moduleType);\n    return meta && meta.id || undefined;\n  }\n}\n\n// The formatter and CI disagree on how this import statement should be formatted. Both try to keep\n// it on one line, too, which has gotten very hard to read & manage. So disable the formatter for\n// this statement only.\nlet _nextRootElementId = 0;\n/**\n * Returns a singleton of the `TestBed` class.\n *\n * @publicApi\n */\nfunction getTestBed() {\n  return TestBedImpl.INSTANCE;\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n */\nclass TestBedImpl {\n  static _INSTANCE = null;\n  static get INSTANCE() {\n    return TestBedImpl._INSTANCE = TestBedImpl._INSTANCE || new TestBedImpl();\n  }\n  /**\n   * Teardown options that have been configured at the environment level.\n   * Used as a fallback if no instance-level options have been provided.\n   */\n  static _environmentTeardownOptions;\n  /**\n   * \"Error on unknown elements\" option that has been configured at the environment level.\n   * Used as a fallback if no instance-level option has been provided.\n   */\n  static _environmentErrorOnUnknownElementsOption;\n  /**\n   * \"Error on unknown properties\" option that has been configured at the environment level.\n   * Used as a fallback if no instance-level option has been provided.\n   */\n  static _environmentErrorOnUnknownPropertiesOption;\n  /**\n   * Teardown options that have been configured at the `TestBed` instance level.\n   * These options take precedence over the environment-level ones.\n   */\n  _instanceTeardownOptions;\n  /**\n   * Defer block behavior option that specifies whether defer blocks will be triggered manually\n   * or set to play through.\n   */\n  _instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n  /**\n   * \"Error on unknown elements\" option that has been configured at the `TestBed` instance level.\n   * This option takes precedence over the environment-level one.\n   */\n  _instanceErrorOnUnknownElementsOption;\n  /**\n   * \"Error on unknown properties\" option that has been configured at the `TestBed` instance level.\n   * This option takes precedence over the environment-level one.\n   */\n  _instanceErrorOnUnknownPropertiesOption;\n  /**\n   * Stores the previous \"Error on unknown elements\" option value,\n   * allowing to restore it in the reset testing module logic.\n   */\n  _previousErrorOnUnknownElementsOption;\n  /**\n   * Stores the previous \"Error on unknown properties\" option value,\n   * allowing to restore it in the reset testing module logic.\n   */\n  _previousErrorOnUnknownPropertiesOption;\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   *\n   * @publicApi\n   */\n  static initTestEnvironment(ngModule, platform, options) {\n    const testBed = TestBedImpl.INSTANCE;\n    testBed.initTestEnvironment(ngModule, platform, options);\n    return testBed;\n  }\n  /**\n   * Reset the providers for the test injector.\n   *\n   * @publicApi\n   */\n  static resetTestEnvironment() {\n    TestBedImpl.INSTANCE.resetTestEnvironment();\n  }\n  static configureCompiler(config) {\n    return TestBedImpl.INSTANCE.configureCompiler(config);\n  }\n  /**\n   * Allows overriding default providers, directives, pipes, modules of the test injector,\n   * which are defined in test_injector.js\n   */\n  static configureTestingModule(moduleDef) {\n    return TestBedImpl.INSTANCE.configureTestingModule(moduleDef);\n  }\n  /**\n   * Compile components with a `templateUrl` for the test's NgModule.\n   * It is necessary to call this function\n   * as fetching urls is asynchronous.\n   */\n  static compileComponents() {\n    return TestBedImpl.INSTANCE.compileComponents();\n  }\n  static overrideModule(ngModule, override) {\n    return TestBedImpl.INSTANCE.overrideModule(ngModule, override);\n  }\n  static overrideComponent(component, override) {\n    return TestBedImpl.INSTANCE.overrideComponent(component, override);\n  }\n  static overrideDirective(directive, override) {\n    return TestBedImpl.INSTANCE.overrideDirective(directive, override);\n  }\n  static overridePipe(pipe, override) {\n    return TestBedImpl.INSTANCE.overridePipe(pipe, override);\n  }\n  static overrideTemplate(component, template) {\n    return TestBedImpl.INSTANCE.overrideTemplate(component, template);\n  }\n  /**\n   * Overrides the template of the given component, compiling the template\n   * in the context of the TestingModule.\n   *\n   * Note: This works for JIT and AOTed components as well.\n   */\n  static overrideTemplateUsingTestingModule(component, template) {\n    return TestBedImpl.INSTANCE.overrideTemplateUsingTestingModule(component, template);\n  }\n  static overrideProvider(token, provider) {\n    return TestBedImpl.INSTANCE.overrideProvider(token, provider);\n  }\n  static inject(token, notFoundValue, flags) {\n    return TestBedImpl.INSTANCE.inject(token, notFoundValue, _convertToBitFlags(flags));\n  }\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  static get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n    return TestBedImpl.INSTANCE.inject(token, notFoundValue, flags);\n  }\n  /**\n   * Runs the given function in the `EnvironmentInjector` context of `TestBed`.\n   *\n   * @see {@link EnvironmentInjector#runInContext}\n   */\n  static runInInjectionContext(fn) {\n    return TestBedImpl.INSTANCE.runInInjectionContext(fn);\n  }\n  static createComponent(component) {\n    return TestBedImpl.INSTANCE.createComponent(component);\n  }\n  static resetTestingModule() {\n    return TestBedImpl.INSTANCE.resetTestingModule();\n  }\n  static execute(tokens, fn, context) {\n    return TestBedImpl.INSTANCE.execute(tokens, fn, context);\n  }\n  static get platform() {\n    return TestBedImpl.INSTANCE.platform;\n  }\n  static get ngModule() {\n    return TestBedImpl.INSTANCE.ngModule;\n  }\n  static flushEffects() {\n    return TestBedImpl.INSTANCE.flushEffects();\n  }\n  // Properties\n  platform = null;\n  ngModule = null;\n  _compiler = null;\n  _testModuleRef = null;\n  _activeFixtures = [];\n  /**\n   * Internal-only flag to indicate whether a module\n   * scoping queue has been checked and flushed already.\n   * @nodoc\n   */\n  globalCompilationChecked = false;\n  /**\n   * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n   * angular module. These are common to every test in the suite.\n   *\n   * This may only be called once, to set up the common providers for the current test\n   * suite on the current platform. If you absolutely need to change the providers,\n   * first use `resetTestEnvironment`.\n   *\n   * Test modules and platforms for individual platforms are available from\n   * '@angular/<platform_name>/testing'.\n   *\n   * @publicApi\n   */\n  initTestEnvironment(ngModule, platform, options) {\n    if (this.platform || this.ngModule) {\n      throw new Error('Cannot set base providers because it has already been called');\n    }\n    TestBedImpl._environmentTeardownOptions = options?.teardown;\n    TestBedImpl._environmentErrorOnUnknownElementsOption = options?.errorOnUnknownElements;\n    TestBedImpl._environmentErrorOnUnknownPropertiesOption = options?.errorOnUnknownProperties;\n    this.platform = platform;\n    this.ngModule = ngModule;\n    this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n    // TestBed does not have an API which can reliably detect the start of a test, and thus could be\n    // used to track the state of the NgModule registry and reset it correctly. Instead, when we\n    // know we're in a testing scenario, we disable the check for duplicate NgModule registration\n    // completely.\n    _setAllowDuplicateNgModuleIdsForTest(true);\n  }\n  /**\n   * Reset the providers for the test injector.\n   *\n   * @publicApi\n   */\n  resetTestEnvironment() {\n    this.resetTestingModule();\n    this._compiler = null;\n    this.platform = null;\n    this.ngModule = null;\n    TestBedImpl._environmentTeardownOptions = undefined;\n    _setAllowDuplicateNgModuleIdsForTest(false);\n  }\n  resetTestingModule() {\n    this.checkGlobalCompilationFinished();\n    _resetCompiledComponents();\n    if (this._compiler !== null) {\n      this.compiler.restoreOriginalState();\n    }\n    this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n    // Restore the previous value of the \"error on unknown elements\" option\n    _setUnknownElementStrictMode(this._previousErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT);\n    // Restore the previous value of the \"error on unknown properties\" option\n    _setUnknownPropertyStrictMode(this._previousErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT);\n    // We have to chain a couple of try/finally blocks, because each step can\n    // throw errors and we don't want it to interrupt the next step and we also\n    // want an error to be thrown at the end.\n    try {\n      this.destroyActiveFixtures();\n    } finally {\n      try {\n        if (this.shouldTearDownTestingModule()) {\n          this.tearDownTestingModule();\n        }\n      } finally {\n        this._testModuleRef = null;\n        this._instanceTeardownOptions = undefined;\n        this._instanceErrorOnUnknownElementsOption = undefined;\n        this._instanceErrorOnUnknownPropertiesOption = undefined;\n        this._instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n      }\n    }\n    return this;\n  }\n  configureCompiler(config) {\n    if (config.useJit != null) {\n      throw new Error('JIT compiler is not configurable via TestBed APIs.');\n    }\n    if (config.providers !== undefined) {\n      this.compiler.setCompilerProviders(config.providers);\n    }\n    return this;\n  }\n  configureTestingModule(moduleDef) {\n    this.assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n    // Trigger module scoping queue flush before executing other TestBed operations in a test.\n    // This is needed for the first test invocation to ensure that globally declared modules have\n    // their components scoped properly. See the `checkGlobalCompilationFinished` function\n    // description for additional info.\n    this.checkGlobalCompilationFinished();\n    // Always re-assign the options, even if they're undefined.\n    // This ensures that we don't carry them between tests.\n    this._instanceTeardownOptions = moduleDef.teardown;\n    this._instanceErrorOnUnknownElementsOption = moduleDef.errorOnUnknownElements;\n    this._instanceErrorOnUnknownPropertiesOption = moduleDef.errorOnUnknownProperties;\n    this._instanceDeferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    // Store the current value of the strict mode option,\n    // so we can restore it later\n    this._previousErrorOnUnknownElementsOption = _getUnknownElementStrictMode();\n    _setUnknownElementStrictMode(this.shouldThrowErrorOnUnknownElements());\n    this._previousErrorOnUnknownPropertiesOption = _getUnknownPropertyStrictMode();\n    _setUnknownPropertyStrictMode(this.shouldThrowErrorOnUnknownProperties());\n    this.compiler.configureTestingModule(moduleDef);\n    return this;\n  }\n  compileComponents() {\n    return this.compiler.compileComponents();\n  }\n  inject(token, notFoundValue, flags) {\n    if (token === TestBed) {\n      return this;\n    }\n    const UNDEFINED = {};\n    const result = this.testModuleRef.injector.get(token, UNDEFINED, _convertToBitFlags(flags));\n    return result === UNDEFINED ? this.compiler.injector.get(token, notFoundValue, flags) : result;\n  }\n  /** @deprecated from v9.0.0 use TestBed.inject */\n  get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n    return this.inject(token, notFoundValue, flags);\n  }\n  runInInjectionContext(fn) {\n    return runInInjectionContext(this.inject(EnvironmentInjector), fn);\n  }\n  execute(tokens, fn, context) {\n    const params = tokens.map(t => this.inject(t));\n    return fn.apply(context, params);\n  }\n  overrideModule(ngModule, override) {\n    this.assertNotInstantiated('overrideModule', 'override module metadata');\n    this.compiler.overrideModule(ngModule, override);\n    return this;\n  }\n  overrideComponent(component, override) {\n    this.assertNotInstantiated('overrideComponent', 'override component metadata');\n    this.compiler.overrideComponent(component, override);\n    return this;\n  }\n  overrideTemplateUsingTestingModule(component, template) {\n    this.assertNotInstantiated('TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n    this.compiler.overrideTemplateUsingTestingModule(component, template);\n    return this;\n  }\n  overrideDirective(directive, override) {\n    this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n    this.compiler.overrideDirective(directive, override);\n    return this;\n  }\n  overridePipe(pipe, override) {\n    this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n    this.compiler.overridePipe(pipe, override);\n    return this;\n  }\n  /**\n   * Overwrites all providers for the given token with the given provider definition.\n   */\n  overrideProvider(token, provider) {\n    this.assertNotInstantiated('overrideProvider', 'override provider');\n    this.compiler.overrideProvider(token, provider);\n    return this;\n  }\n  overrideTemplate(component, template) {\n    return this.overrideComponent(component, {\n      set: {\n        template,\n        templateUrl: null\n      }\n    });\n  }\n  createComponent(type) {\n    const testComponentRenderer = this.inject(TestComponentRenderer);\n    const rootElId = `root${_nextRootElementId++}`;\n    testComponentRenderer.insertRootElement(rootElId);\n    if (_getAsyncClassMetadataFn(type)) {\n      throw new Error(`Component '${type.name}' has unresolved metadata. ` + `Please call \\`await TestBed.compileComponents()\\` before running this test.`);\n    }\n    const componentDef = type.ɵcmp;\n    if (!componentDef) {\n      throw new Error(`It looks like '${_stringify(type)}' has not been compiled.`);\n    }\n    const componentFactory = new _Render3ComponentFactory(componentDef);\n    const initComponent = () => {\n      const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this.testModuleRef);\n      return this.runInInjectionContext(() => new ComponentFixture(componentRef));\n    };\n    const noNgZone = this.inject(ComponentFixtureNoNgZone, false);\n    const ngZone = noNgZone ? null : this.inject(NgZone, null);\n    const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n    this._activeFixtures.push(fixture);\n    return fixture;\n  }\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  get compiler() {\n    if (this._compiler === null) {\n      throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n    }\n    return this._compiler;\n  }\n  /**\n   * @internal strip this from published d.ts files due to\n   * https://github.com/microsoft/TypeScript/issues/36216\n   */\n  get testModuleRef() {\n    if (this._testModuleRef === null) {\n      this._testModuleRef = this.compiler.finalize();\n    }\n    return this._testModuleRef;\n  }\n  assertNotInstantiated(methodName, methodDescription) {\n    if (this._testModuleRef !== null) {\n      throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` + `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n    }\n  }\n  /**\n   * Check whether the module scoping queue should be flushed, and flush it if needed.\n   *\n   * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n   * in-progress module compilation. This creates a potential hazard - the very first time the\n   * TestBed is initialized (or if it's reset without being initialized), there may be pending\n   * compilations of modules declared in global scope. These compilations should be finished.\n   *\n   * To ensure that globally declared modules have their components scoped properly, this function\n   * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n   * to any other operations, the scoping queue is flushed.\n   */\n  checkGlobalCompilationFinished() {\n    // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n    // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n    if (!this.globalCompilationChecked && this._testModuleRef === null) {\n      _flushModuleScopingQueueAsMuchAsPossible();\n    }\n    this.globalCompilationChecked = true;\n  }\n  destroyActiveFixtures() {\n    let errorCount = 0;\n    this._activeFixtures.forEach(fixture => {\n      try {\n        fixture.destroy();\n      } catch (e) {\n        errorCount++;\n        console.error('Error during cleanup of component', {\n          component: fixture.componentInstance,\n          stacktrace: e\n        });\n      }\n    });\n    this._activeFixtures = [];\n    if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n      throw Error(`${errorCount} ${errorCount === 1 ? 'component' : 'components'} ` + `threw errors during cleanup`);\n    }\n  }\n  shouldRethrowTeardownErrors() {\n    const instanceOptions = this._instanceTeardownOptions;\n    const environmentOptions = TestBedImpl._environmentTeardownOptions;\n    // If the new teardown behavior hasn't been configured, preserve the old behavior.\n    if (!instanceOptions && !environmentOptions) {\n      return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n    }\n    // Otherwise use the configured behavior or default to rethrowing.\n    return instanceOptions?.rethrowErrors ?? environmentOptions?.rethrowErrors ?? this.shouldTearDownTestingModule();\n  }\n  shouldThrowErrorOnUnknownElements() {\n    // Check if a configuration has been provided to throw when an unknown element is found\n    return this._instanceErrorOnUnknownElementsOption ?? TestBedImpl._environmentErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT;\n  }\n  shouldThrowErrorOnUnknownProperties() {\n    // Check if a configuration has been provided to throw when an unknown property is found\n    return this._instanceErrorOnUnknownPropertiesOption ?? TestBedImpl._environmentErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT;\n  }\n  shouldTearDownTestingModule() {\n    return this._instanceTeardownOptions?.destroyAfterEach ?? TestBedImpl._environmentTeardownOptions?.destroyAfterEach ?? TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n  }\n  getDeferBlockBehavior() {\n    return this._instanceDeferBlockBehavior;\n  }\n  tearDownTestingModule() {\n    // If the module ref has already been destroyed, we won't be able to get a test renderer.\n    if (this._testModuleRef === null) {\n      return;\n    }\n    // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n    // last step, but the injector will be destroyed as a part of the module ref destruction.\n    const testRenderer = this.inject(TestComponentRenderer);\n    try {\n      this._testModuleRef.destroy();\n    } catch (e) {\n      if (this.shouldRethrowTeardownErrors()) {\n        throw e;\n      } else {\n        console.error('Error during cleanup of a testing module', {\n          component: this._testModuleRef.instance,\n          stacktrace: e\n        });\n      }\n    } finally {\n      testRenderer.removeAllRootElements?.();\n    }\n  }\n  /**\n   * Execute any pending effects.\n   *\n   * @developerPreview\n   */\n  flushEffects() {\n    this.inject(_MicrotaskEffectScheduler).flush();\n    this.inject(_EffectScheduler).flush();\n  }\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * @publicApi\n */\nconst TestBed = TestBedImpl;\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`. Note: this function\n * (imported from the `@angular/core/testing` package) can **only** be used to inject dependencies\n * in tests. To inject dependencies in your application code, use the [`inject`](api/core/inject)\n * function from the `@angular/core` package instead.\n *\n * Example:\n *\n * ```ts\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * @publicApi\n */\nfunction inject(tokens, fn) {\n  const testBed = TestBedImpl.INSTANCE;\n  // Not using an arrow function to preserve context passed from call site\n  return function () {\n    return testBed.execute(tokens, fn, this);\n  };\n}\n/**\n * @publicApi\n */\nclass InjectSetupWrapper {\n  _moduleDef;\n  constructor(_moduleDef) {\n    this._moduleDef = _moduleDef;\n  }\n  _addModule() {\n    const moduleDef = this._moduleDef();\n    if (moduleDef) {\n      TestBedImpl.configureTestingModule(moduleDef);\n    }\n  }\n  inject(tokens, fn) {\n    const self = this;\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n      self._addModule();\n      return inject(tokens, fn).call(this);\n    };\n  }\n}\nfunction withModule(moduleDef, fn) {\n  if (fn) {\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n      const testBed = TestBedImpl.INSTANCE;\n      if (moduleDef) {\n        testBed.configureTestingModule(moduleDef);\n      }\n      return fn.apply(this);\n    };\n  }\n  return new InjectSetupWrapper(() => moduleDef);\n}\n\n/**\n * Public Test Library for unit testing Angular applications. Assumes that you are running\n * with Jasmine, Mocha, or a similar framework which exports a beforeEach function and\n * allows tests to be asynchronous by either returning a promise or using a 'done' parameter.\n */\n// Reset the test providers and the fake async zone before each test.\n// We keep a guard because somehow this file can make it into a bundle and be executed\n// beforeEach is only defined when executing the tests\nglobalThis.beforeEach?.(getCleanupHook(false));\n// We provide both a `beforeEach` and `afterEach`, because the updated behavior for\n// tearing down the module is supposed to run after the test so that we can associate\n// teardown errors with the correct test.\n// We keep a guard because somehow this file can make it into a bundle and be executed\n// afterEach is only defined when executing the tests\nglobalThis.afterEach?.(getCleanupHook(true));\nfunction getCleanupHook(expectedTeardownValue) {\n  return () => {\n    const testBed = TestBedImpl.INSTANCE;\n    if (testBed.shouldTearDownTestingModule() === expectedTeardownValue) {\n      testBed.resetTestingModule();\n      resetFakeAsyncZoneIfExists();\n    }\n  };\n}\n/**\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\n * investigation.\n *\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\n *\n * @codeGenApi\n */\n// TODO(iminar): Remove this code in a safe way.\nconst __core_private_testing_placeholder__ = '';\n\n/**\n * Fake implementation of user agent history and navigation behavior. This is a\n * high-fidelity implementation of browser behavior that attempts to emulate\n * things like traversal delay.\n */\nclass FakeNavigation {\n  window;\n  /**\n   * The fake implementation of an entries array. Only same-document entries\n   * allowed.\n   */\n  entriesArr = [];\n  /**\n   * The current active entry index into `entriesArr`.\n   */\n  currentEntryIndex = 0;\n  /**\n   * The current navigate event.\n   * @internal\n   */\n  navigateEvent = null;\n  /**\n   * A Map of pending traversals, so that traversals to the same entry can be\n   * re-used.\n   */\n  traversalQueue = new Map();\n  /**\n   * A Promise that resolves when the previous traversals have finished. Used to\n   * simulate the cross-process communication necessary for traversals.\n   */\n  nextTraversal = Promise.resolve();\n  /**\n   * A prospective current active entry index, which includes unresolved\n   * traversals. Used by `go` to determine where navigations are intended to go.\n   */\n  prospectiveEntryIndex = 0;\n  /**\n   * A test-only option to make traversals synchronous, rather than emulate\n   * cross-process communication.\n   */\n  synchronousTraversals = false;\n  /** Whether to allow a call to setInitialEntryForTesting. */\n  canSetInitialEntry = true;\n  /**\n   * `EventTarget` to dispatch events.\n   * @internal\n   */\n  eventTarget;\n  /** The next unique id for created entries. Replace recreates this id. */\n  nextId = 0;\n  /** The next unique key for created entries. Replace inherits this id. */\n  nextKey = 0;\n  /** Whether this fake is disposed. */\n  disposed = false;\n  /** Equivalent to `navigation.currentEntry`. */\n  get currentEntry() {\n    return this.entriesArr[this.currentEntryIndex];\n  }\n  get canGoBack() {\n    return this.currentEntryIndex > 0;\n  }\n  get canGoForward() {\n    return this.currentEntryIndex < this.entriesArr.length - 1;\n  }\n  constructor(window, startURL) {\n    this.window = window;\n    this.eventTarget = this.window.document.createElement('div');\n    // First entry.\n    this.setInitialEntryForTesting(startURL);\n  }\n  /**\n   * Sets the initial entry.\n   */\n  setInitialEntryForTesting(url, options = {\n    historyState: null\n  }) {\n    if (!this.canSetInitialEntry) {\n      throw new Error('setInitialEntryForTesting can only be called before any ' + 'navigation has occurred');\n    }\n    const currentInitialEntry = this.entriesArr[0];\n    this.entriesArr[0] = new FakeNavigationHistoryEntry(this.window.document.createElement('div'), new URL(url).toString(), {\n      index: 0,\n      key: currentInitialEntry?.key ?? String(this.nextKey++),\n      id: currentInitialEntry?.id ?? String(this.nextId++),\n      sameDocument: true,\n      historyState: options?.historyState,\n      state: options.state\n    });\n  }\n  /** Returns whether the initial entry is still eligible to be set. */\n  canSetInitialEntryForTesting() {\n    return this.canSetInitialEntry;\n  }\n  /**\n   * Sets whether to emulate traversals as synchronous rather than\n   * asynchronous.\n   */\n  setSynchronousTraversalsForTesting(synchronousTraversals) {\n    this.synchronousTraversals = synchronousTraversals;\n  }\n  /** Equivalent to `navigation.entries()`. */\n  entries() {\n    return this.entriesArr.slice();\n  }\n  /** Equivalent to `navigation.navigate()`. */\n  navigate(url, options) {\n    const fromUrl = new URL(this.currentEntry.url);\n    const toUrl = new URL(url, this.currentEntry.url);\n    let navigationType;\n    if (!options?.history || options.history === 'auto') {\n      // Auto defaults to push, but if the URLs are the same, is a replace.\n      if (fromUrl.toString() === toUrl.toString()) {\n        navigationType = 'replace';\n      } else {\n        navigationType = 'push';\n      }\n    } else {\n      navigationType = options.history;\n    }\n    const hashChange = isHashChange(fromUrl, toUrl);\n    const destination = new FakeNavigationDestination({\n      url: toUrl.toString(),\n      state: options?.state,\n      sameDocument: hashChange,\n      historyState: null\n    });\n    const result = new InternalNavigationResult(this);\n    this.userAgentNavigate(destination, result, {\n      navigationType,\n      cancelable: true,\n      canIntercept: true,\n      // Always false for navigate().\n      userInitiated: false,\n      hashChange,\n      info: options?.info\n    });\n    return {\n      committed: result.committed,\n      finished: result.finished\n    };\n  }\n  /** Equivalent to `history.pushState()`. */\n  pushState(data, title, url) {\n    this.pushOrReplaceState('push', data, title, url);\n  }\n  /** Equivalent to `history.replaceState()`. */\n  replaceState(data, title, url) {\n    this.pushOrReplaceState('replace', data, title, url);\n  }\n  pushOrReplaceState(navigationType, data, _title, url) {\n    const fromUrl = new URL(this.currentEntry.url);\n    const toUrl = url ? new URL(url, this.currentEntry.url) : fromUrl;\n    const hashChange = isHashChange(fromUrl, toUrl);\n    const destination = new FakeNavigationDestination({\n      url: toUrl.toString(),\n      sameDocument: true,\n      historyState: data\n    });\n    const result = new InternalNavigationResult(this);\n    this.userAgentNavigate(destination, result, {\n      navigationType,\n      cancelable: true,\n      canIntercept: true,\n      // Always false for pushState() or replaceState().\n      userInitiated: false,\n      hashChange\n    });\n  }\n  /** Equivalent to `navigation.traverseTo()`. */\n  traverseTo(key, options) {\n    const fromUrl = new URL(this.currentEntry.url);\n    const entry = this.findEntry(key);\n    if (!entry) {\n      const domException = new DOMException('Invalid key', 'InvalidStateError');\n      const committed = Promise.reject(domException);\n      const finished = Promise.reject(domException);\n      committed.catch(() => {});\n      finished.catch(() => {});\n      return {\n        committed,\n        finished\n      };\n    }\n    if (entry === this.currentEntry) {\n      return {\n        committed: Promise.resolve(this.currentEntry),\n        finished: Promise.resolve(this.currentEntry)\n      };\n    }\n    if (this.traversalQueue.has(entry.key)) {\n      const existingResult = this.traversalQueue.get(entry.key);\n      return {\n        committed: existingResult.committed,\n        finished: existingResult.finished\n      };\n    }\n    const hashChange = isHashChange(fromUrl, new URL(entry.url, this.currentEntry.url));\n    const destination = new FakeNavigationDestination({\n      url: entry.url,\n      state: entry.getState(),\n      historyState: entry.getHistoryState(),\n      key: entry.key,\n      id: entry.id,\n      index: entry.index,\n      sameDocument: entry.sameDocument\n    });\n    this.prospectiveEntryIndex = entry.index;\n    const result = new InternalNavigationResult(this);\n    this.traversalQueue.set(entry.key, result);\n    this.runTraversal(() => {\n      this.traversalQueue.delete(entry.key);\n      const event = this.userAgentNavigate(destination, result, {\n        navigationType: 'traverse',\n        cancelable: true,\n        canIntercept: true,\n        // Always false for traverseTo().\n        userInitiated: false,\n        hashChange,\n        info: options?.info\n      });\n      // Note this does not pay attention at all to the commit status of the event (and thus, does not support deferred commit for traversals)\n      this.userAgentTraverse(event);\n    });\n    return {\n      committed: result.committed,\n      finished: result.finished\n    };\n  }\n  /** Equivalent to `navigation.back()`. */\n  back(options) {\n    if (this.currentEntryIndex === 0) {\n      const domException = new DOMException('Cannot go back', 'InvalidStateError');\n      const committed = Promise.reject(domException);\n      const finished = Promise.reject(domException);\n      committed.catch(() => {});\n      finished.catch(() => {});\n      return {\n        committed,\n        finished\n      };\n    }\n    const entry = this.entriesArr[this.currentEntryIndex - 1];\n    return this.traverseTo(entry.key, options);\n  }\n  /** Equivalent to `navigation.forward()`. */\n  forward(options) {\n    if (this.currentEntryIndex === this.entriesArr.length - 1) {\n      const domException = new DOMException('Cannot go forward', 'InvalidStateError');\n      const committed = Promise.reject(domException);\n      const finished = Promise.reject(domException);\n      committed.catch(() => {});\n      finished.catch(() => {});\n      return {\n        committed,\n        finished\n      };\n    }\n    const entry = this.entriesArr[this.currentEntryIndex + 1];\n    return this.traverseTo(entry.key, options);\n  }\n  /**\n   * Equivalent to `history.go()`.\n   * Note that this method does not actually work precisely to how Chrome\n   * does, instead choosing a simpler model with less unexpected behavior.\n   * Chrome has a few edge case optimizations, for instance with repeated\n   * `back(); forward()` chains it collapses certain traversals.\n   */\n  go(direction) {\n    const targetIndex = this.prospectiveEntryIndex + direction;\n    if (targetIndex >= this.entriesArr.length || targetIndex < 0) {\n      return;\n    }\n    this.prospectiveEntryIndex = targetIndex;\n    this.runTraversal(() => {\n      // Check again that destination is in the entries array.\n      if (targetIndex >= this.entriesArr.length || targetIndex < 0) {\n        return;\n      }\n      const fromUrl = new URL(this.currentEntry.url);\n      const entry = this.entriesArr[targetIndex];\n      const hashChange = isHashChange(fromUrl, new URL(entry.url, this.currentEntry.url));\n      const destination = new FakeNavigationDestination({\n        url: entry.url,\n        state: entry.getState(),\n        historyState: entry.getHistoryState(),\n        key: entry.key,\n        id: entry.id,\n        index: entry.index,\n        sameDocument: entry.sameDocument\n      });\n      const result = new InternalNavigationResult(this);\n      const event = this.userAgentNavigate(destination, result, {\n        navigationType: 'traverse',\n        cancelable: true,\n        canIntercept: true,\n        // Always false for go().\n        userInitiated: false,\n        hashChange\n      });\n      // Note this does not pay attention at all to the commit status of the event (and thus, does not support deferred commit for traversals)\n      this.userAgentTraverse(event);\n    });\n  }\n  /** Runs a traversal synchronously or asynchronously */\n  runTraversal(traversal) {\n    if (this.synchronousTraversals) {\n      traversal();\n      return;\n    }\n    // Each traversal occupies a single timeout resolution.\n    // This means that Promises added to commit and finish should resolve\n    // before the next traversal.\n    this.nextTraversal = this.nextTraversal.then(() => {\n      return new Promise(resolve => {\n        setTimeout(() => {\n          resolve();\n          traversal();\n        });\n      });\n    });\n  }\n  /** Equivalent to `navigation.addEventListener()`. */\n  addEventListener(type, callback, options) {\n    this.eventTarget.addEventListener(type, callback, options);\n  }\n  /** Equivalent to `navigation.removeEventListener()`. */\n  removeEventListener(type, callback, options) {\n    this.eventTarget.removeEventListener(type, callback, options);\n  }\n  /** Equivalent to `navigation.dispatchEvent()` */\n  dispatchEvent(event) {\n    return this.eventTarget.dispatchEvent(event);\n  }\n  /** Cleans up resources. */\n  dispose() {\n    // Recreate eventTarget to release current listeners.\n    // `document.createElement` because NodeJS `EventTarget` is incompatible with Domino's `Event`.\n    this.eventTarget = this.window.document.createElement('div');\n    this.disposed = true;\n  }\n  /** Returns whether this fake is disposed. */\n  isDisposed() {\n    return this.disposed;\n  }\n  /** Implementation for all navigations and traversals. */\n  userAgentNavigate(destination, result, options) {\n    // The first navigation should disallow any future calls to set the initial\n    // entry.\n    this.canSetInitialEntry = false;\n    if (this.navigateEvent) {\n      this.navigateEvent.cancel(new DOMException('Navigation was aborted', 'AbortError'));\n      this.navigateEvent = null;\n    }\n    return dispatchNavigateEvent({\n      navigationType: options.navigationType,\n      cancelable: options.cancelable,\n      canIntercept: options.canIntercept,\n      userInitiated: options.userInitiated,\n      hashChange: options.hashChange,\n      signal: result.signal,\n      destination,\n      info: options.info,\n      sameDocument: destination.sameDocument,\n      result\n    });\n  }\n  /**\n   * Implementation to commit a navigation.\n   * https://whatpr.org/html/10919/nav-history-apis.html#navigateevent-commit\n   * @internal\n   */\n  commitNavigateEvent(navigateEvent) {\n    navigateEvent.interceptionState = 'committed';\n    const from = this.currentEntry;\n    if (!from) {\n      throw new Error('cannot commit navigation when current entry is null');\n    }\n    if (!navigateEvent.sameDocument) {\n      const error = new Error('Cannot navigate to a non-same-document URL.');\n      navigateEvent.cancel(error);\n      throw error;\n    }\n    // \"If navigationType is \"push\" or \"replace\", then run the URL and history update steps given document and event's destination's URL, with serialiedData set to event's classic history API state and historyHandling set to navigationType.\"\n    if (navigateEvent.navigationType === 'push' || navigateEvent.navigationType === 'replace') {\n      this.urlAndHistoryUpdateSteps(navigateEvent);\n    } else if (navigateEvent.navigationType === 'reload') {\n      this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent);\n    } else ;\n  }\n  /**\n   * Implementation for a push or replace navigation.\n   * https://whatpr.org/html/10919/browsing-the-web.html#url-and-history-update-steps\n   * https://whatpr.org/html/10919/nav-history-apis.html#update-the-navigation-api-entries-for-a-same-document-navigation\n   */\n  urlAndHistoryUpdateSteps(navigateEvent) {\n    this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent);\n  }\n  /**\n   * Implementation for a traverse navigation.\n   *\n   * https://whatpr.org/html/10919/browsing-the-web.html#apply-the-traverse-history-step\n   * ...\n   * > Let updateDocument be an algorithm step which performs update document for history step application given targetEntry's document, targetEntry, changingNavigableContinuation's update-only, scriptHistoryLength, scriptHistoryIndex, navigationType, entriesForNavigationAPI, and previousEntry.\n   * > If targetEntry's document is equal to displayedDocument, then perform updateDocument.\n   * https://whatpr.org/html/10919/browsing-the-web.html#update-document-for-history-step-application\n   * which then goes to https://whatpr.org/html/10919/nav-history-apis.html#update-the-navigation-api-entries-for-a-same-document-navigation\n   */\n  userAgentTraverse(navigateEvent) {\n    this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent);\n    // Happens as part of \"updating the document\" steps https://whatpr.org/html/10919/browsing-the-web.html#updating-the-document\n    const popStateEvent = createPopStateEvent({\n      state: navigateEvent.destination.getHistoryState()\n    });\n    this.window.dispatchEvent(popStateEvent);\n    // TODO(atscott): If oldURL's fragment is not equal to entry's URL's fragment, then queue a global task to fire an event named hashchange\n  }\n  /** https://whatpr.org/html/10919/nav-history-apis.html#update-the-navigation-api-entries-for-a-same-document-navigation */\n  updateNavigationEntriesForSameDocumentNavigation({\n    destination,\n    navigationType,\n    result\n  }) {\n    const oldCurrentNHE = this.currentEntry;\n    const disposedNHEs = [];\n    if (navigationType === 'traverse') {\n      this.currentEntryIndex = destination.index;\n      if (this.currentEntryIndex === -1) {\n        throw new Error('unexpected current entry index');\n      }\n    } else if (navigationType === 'push') {\n      this.currentEntryIndex++;\n      this.prospectiveEntryIndex = this.currentEntryIndex; // prospectiveEntryIndex isn't in the spec but is an implementation detail\n      disposedNHEs.push(...this.entriesArr.splice(this.currentEntryIndex));\n    } else if (navigationType === 'replace') {\n      disposedNHEs.push(oldCurrentNHE);\n    }\n    if (navigationType === 'push' || navigationType === 'replace') {\n      const index = this.currentEntryIndex;\n      const key = navigationType === 'push' ? String(this.nextKey++) : this.currentEntry.key;\n      const newNHE = new FakeNavigationHistoryEntry(this.window.document.createElement('div'), destination.url, {\n        id: String(this.nextId++),\n        key,\n        index,\n        sameDocument: true,\n        state: destination.getState(),\n        historyState: destination.getHistoryState()\n      });\n      this.entriesArr[this.currentEntryIndex] = newNHE;\n    }\n    result.committedResolve(this.currentEntry);\n    const currentEntryChangeEvent = createFakeNavigationCurrentEntryChangeEvent({\n      from: oldCurrentNHE,\n      navigationType: navigationType\n    });\n    this.eventTarget.dispatchEvent(currentEntryChangeEvent);\n    for (const disposedNHE of disposedNHEs) {\n      disposedNHE.dispose();\n    }\n  }\n  /** Utility method for finding entries with the given `key`. */\n  findEntry(key) {\n    for (const entry of this.entriesArr) {\n      if (entry.key === key) return entry;\n    }\n    return undefined;\n  }\n  set onnavigate(\n  // tslint:disable-next-line:no-any\n  _handler) {\n    throw new Error('unimplemented');\n  }\n  // tslint:disable-next-line:no-any\n  get onnavigate() {\n    throw new Error('unimplemented');\n  }\n  set oncurrententrychange(_handler) {\n    throw new Error('unimplemented');\n  }\n  get oncurrententrychange() {\n    throw new Error('unimplemented');\n  }\n  set onnavigatesuccess(\n  // tslint:disable-next-line:no-any\n  _handler) {\n    throw new Error('unimplemented');\n  }\n  // tslint:disable-next-line:no-any\n  get onnavigatesuccess() {\n    throw new Error('unimplemented');\n  }\n  set onnavigateerror(\n  // tslint:disable-next-line:no-any\n  _handler) {\n    throw new Error('unimplemented');\n  }\n  // tslint:disable-next-line:no-any\n  get onnavigateerror() {\n    throw new Error('unimplemented');\n  }\n  _transition = null;\n  /** @internal */\n  set transition(t) {\n    this._transition = t;\n  }\n  get transition() {\n    return this._transition;\n  }\n  updateCurrentEntry(_options) {\n    throw new Error('unimplemented');\n  }\n  reload(_options) {\n    throw new Error('unimplemented');\n  }\n}\n/**\n * Fake equivalent of `NavigationHistoryEntry`.\n */\nclass FakeNavigationHistoryEntry {\n  eventTarget;\n  url;\n  sameDocument;\n  id;\n  key;\n  index;\n  state;\n  historyState;\n  // tslint:disable-next-line:no-any\n  ondispose = null;\n  constructor(eventTarget, url, {\n    id,\n    key,\n    index,\n    sameDocument,\n    state,\n    historyState\n  }) {\n    this.eventTarget = eventTarget;\n    this.url = url;\n    this.id = id;\n    this.key = key;\n    this.index = index;\n    this.sameDocument = sameDocument;\n    this.state = state;\n    this.historyState = historyState;\n  }\n  getState() {\n    // Budget copy.\n    return this.state ? JSON.parse(JSON.stringify(this.state)) : this.state;\n  }\n  getHistoryState() {\n    // Budget copy.\n    return this.historyState ? JSON.parse(JSON.stringify(this.historyState)) : this.historyState;\n  }\n  addEventListener(type, callback, options) {\n    this.eventTarget.addEventListener(type, callback, options);\n  }\n  removeEventListener(type, callback, options) {\n    this.eventTarget.removeEventListener(type, callback, options);\n  }\n  dispatchEvent(event) {\n    return this.eventTarget.dispatchEvent(event);\n  }\n  /** internal */\n  dispose() {\n    const disposeEvent = new Event('disposed');\n    this.dispatchEvent(disposeEvent);\n    // release current listeners\n    this.eventTarget = null;\n  }\n}\n/**\n * Create a fake equivalent of `NavigateEvent`. This is not a class because ES5\n * transpiled JavaScript cannot extend native Event.\n *\n * https://html.spec.whatwg.org/multipage/nav-history-apis.html#navigate-event-firing\n */\nfunction dispatchNavigateEvent({\n  cancelable,\n  canIntercept,\n  userInitiated,\n  hashChange,\n  navigationType,\n  signal,\n  destination,\n  info,\n  sameDocument,\n  result\n}) {\n  const {\n    navigation\n  } = result;\n  const event = new Event('navigate', {\n    bubbles: false,\n    cancelable\n  });\n  event.focusResetBehavior = null;\n  event.scrollBehavior = null;\n  event.interceptionState = 'none';\n  event.canIntercept = canIntercept;\n  event.userInitiated = userInitiated;\n  event.hashChange = hashChange;\n  event.navigationType = navigationType;\n  event.signal = signal;\n  event.destination = destination;\n  event.info = info;\n  event.downloadRequest = null;\n  event.formData = null;\n  event.result = result;\n  event.sameDocument = sameDocument;\n  event.commitOption = 'immediate';\n  let handlersFinished = [Promise.resolve()];\n  let dispatchedNavigateEvent = false;\n  event.intercept = function (options) {\n    if (!this.canIntercept) {\n      throw new DOMException(`Cannot intercept when canIntercept is 'false'`, 'SecurityError');\n    }\n    this.interceptionState = 'intercepted';\n    event.sameDocument = true;\n    const handler = options?.handler;\n    if (handler) {\n      handlersFinished.push(handler());\n    }\n    // override old options with new ones. UA _may_ report a console warning if new options differ from previous\n    event.commitOption = options?.commit ?? event.commitOption;\n    event.scrollBehavior = options?.scroll ?? event.scrollBehavior;\n    event.focusResetBehavior = options?.focusReset ?? event.focusResetBehavior;\n  };\n  event.scroll = function () {\n    if (event.interceptionState !== 'committed') {\n      throw new DOMException(`Failed to execute 'scroll' on 'NavigateEvent': scroll() must be ` + `called after commit() and interception options must specify manual scroll.`, 'InvalidStateError');\n    }\n    processScrollBehavior(event);\n  };\n  event.commit = function (internal = false) {\n    if (!internal && this.interceptionState !== 'intercepted') {\n      throw new DOMException(`Failed to execute 'commit' on 'NavigateEvent': intercept() must be ` + `called before commit() and commit() cannot be already called.`, 'InvalidStateError');\n    }\n    if (!internal && event.commitOption !== 'after-transition') {\n      throw new DOMException(`Failed to execute 'commit' on 'NavigateEvent': commit() may not be ` + `called if commit behavior is not \"after-transition\",.`, 'InvalidStateError');\n    }\n    if (!dispatchedNavigateEvent) {\n      throw new DOMException(`Failed to execute 'commit' on 'NavigateEvent': commit() may not be ` + `called during event dispatch.`, 'InvalidStateError');\n    }\n    this.interceptionState = 'committed';\n    result.navigation.commitNavigateEvent(event);\n  };\n  // Internal only.\n  event.cancel = function (reason) {\n    result.committedReject(reason);\n    result.finishedReject(reason);\n  };\n  function dispatch() {\n    navigation.navigateEvent = event;\n    navigation.eventTarget.dispatchEvent(event);\n    dispatchedNavigateEvent = true;\n    if (event.interceptionState !== 'none') {\n      navigation.transition = new InternalNavigationTransition(navigation.currentEntry, navigationType);\n      if (event.commitOption !== 'after-transition') {\n        event.commit(/** internal */true);\n      }\n    } else {\n      // In the spec, this isn't really part of the navigate API. Instead, the navigate event firing returns \"true\" to indicate\n      // navigation steps should \"continue\" (https://whatpr.org/html/10919/browsing-the-web.html#beginning-navigation)\n      event.commit(/** internal */true);\n    }\n    Promise.all(handlersFinished).then(() => {\n      // Follows steps outlined under \"Wait for all of promisesList, with the following success steps:\"\n      // in the spec https://html.spec.whatwg.org/multipage/nav-history-apis.html#navigate-event-firing.\n      if (result.signal.aborted) {\n        return;\n      }\n      if (event !== navigation.navigateEvent) {\n        throw new Error(\"Navigation's ongoing event not equal to resolved event\");\n      }\n      navigation.navigateEvent = null;\n      if (event.interceptionState === 'intercepted') {\n        navigation.commitNavigateEvent(event);\n      }\n      finishNavigationEvent(event, true);\n      const navigatesuccessEvent = new Event('navigatesuccess', {\n        bubbles: false,\n        cancelable\n      });\n      navigation.eventTarget.dispatchEvent(navigatesuccessEvent);\n      result.finishedResolve();\n      if (navigation.transition !== null) {\n        navigation.transition.finishedResolve();\n      }\n      navigation.transition = null;\n    }, reason => {\n      if (result.signal.aborted) {\n        return;\n      }\n      if (event !== navigation.navigateEvent) {\n        throw new Error(\"Navigation's ongoing event not equal to resolved event\");\n      }\n      navigation.navigateEvent = null;\n      event.interceptionState = 'rejected'; // TODO(atscott): this is not in the spec https://github.com/whatwg/html/issues/11087\n      finishNavigationEvent(event, false);\n      const navigateerrorEvent = new Event('navigateerror', {\n        bubbles: false,\n        cancelable\n      });\n      navigation.eventTarget.dispatchEvent(navigateerrorEvent);\n      result.finishedReject(reason);\n      if (navigation.transition !== null) {\n        navigation.transition.finishedResolve();\n      }\n      navigation.transition = null;\n    });\n  }\n  dispatch();\n  return event;\n}\n/** https://whatpr.org/html/10919/nav-history-apis.html#navigateevent-finish */\nfunction finishNavigationEvent(event, didFulfill) {\n  if (event.interceptionState === 'intercepted' || event.interceptionState === 'finished') {\n    throw new Error('Attempting to finish navigation event that was incomplete or already finished');\n  }\n  if (event.interceptionState === 'none') {\n    return;\n  }\n  if (didFulfill) {\n    // TODO(atscott): https://github.com/whatwg/html/issues/11087 focus reset is not guarded by didFulfill in the spec\n    potentiallyResetFocus(event);\n    potentiallyResetScroll(event);\n  }\n  event.interceptionState = 'finished';\n}\n/** https://whatpr.org/html/10919/nav-history-apis.html#potentially-reset-the-focus */\nfunction potentiallyResetFocus(event) {\n  if (event.interceptionState !== 'committed' && event.interceptionState !== 'scrolled') {\n    throw new Error('cannot reset focus if navigation event is not committed or scrolled');\n  }\n  // TODO(atscott): The rest of the steps\n}\nfunction potentiallyResetScroll(event) {\n  if (event.interceptionState !== 'committed' && event.interceptionState !== 'scrolled') {\n    throw new Error('cannot reset scroll if navigation event is not committed or scrolled');\n  }\n  if (event.interceptionState === 'scrolled' || event.scrollBehavior === 'manual') {\n    return;\n  }\n  processScrollBehavior(event);\n}\n/* https://whatpr.org/html/10919/nav-history-apis.html#process-scroll-behavior */\nfunction processScrollBehavior(event) {\n  if (event.interceptionState !== 'committed') {\n    throw new Error('invalid event interception state when processing scroll behavior');\n  }\n  event.interceptionState = 'scrolled';\n  // TODO(atscott): the rest of the steps\n}\n/**\n * Create a fake equivalent of `NavigationCurrentEntryChange`. This does not use\n * a class because ES5 transpiled JavaScript cannot extend native Event.\n */\nfunction createFakeNavigationCurrentEntryChangeEvent({\n  from,\n  navigationType\n}) {\n  const event = new Event('currententrychange', {\n    bubbles: false,\n    cancelable: false\n  });\n  event.from = from;\n  event.navigationType = navigationType;\n  return event;\n}\n/**\n * Create a fake equivalent of `PopStateEvent`. This does not use a class\n * because ES5 transpiled JavaScript cannot extend native Event.\n */\nfunction createPopStateEvent({\n  state\n}) {\n  const event = new Event('popstate', {\n    bubbles: false,\n    cancelable: false\n  });\n  event.state = state;\n  return event;\n}\n/**\n * Fake equivalent of `NavigationDestination`.\n */\nclass FakeNavigationDestination {\n  url;\n  sameDocument;\n  key;\n  id;\n  index;\n  state;\n  historyState;\n  constructor({\n    url,\n    sameDocument,\n    historyState,\n    state,\n    key = null,\n    id = null,\n    index = -1\n  }) {\n    this.url = url;\n    this.sameDocument = sameDocument;\n    this.state = state;\n    this.historyState = historyState;\n    this.key = key;\n    this.id = id;\n    this.index = index;\n  }\n  getState() {\n    return this.state;\n  }\n  getHistoryState() {\n    return this.historyState;\n  }\n}\n/** Utility function to determine whether two UrlLike have the same hash. */\nfunction isHashChange(from, to) {\n  return to.hash !== from.hash && to.hostname === from.hostname && to.pathname === from.pathname && to.search === from.search;\n}\nclass InternalNavigationTransition {\n  from;\n  navigationType;\n  finished;\n  finishedResolve;\n  finishedReject;\n  constructor(from, navigationType) {\n    this.from = from;\n    this.navigationType = navigationType;\n    this.finished = new Promise((resolve, reject) => {\n      this.finishedReject = reject;\n      this.finishedResolve = resolve;\n    });\n  }\n}\n/**\n * Internal utility class for representing the result of a navigation.\n * Generally equivalent to the \"apiMethodTracker\" in the spec.\n */\nclass InternalNavigationResult {\n  navigation;\n  committedTo = null;\n  committedResolve;\n  committedReject;\n  finishedResolve;\n  finishedReject;\n  committed;\n  finished;\n  get signal() {\n    return this.abortController.signal;\n  }\n  abortController = new AbortController();\n  constructor(navigation) {\n    var _this7 = this;\n    this.navigation = navigation;\n    this.committed = new Promise((resolve, reject) => {\n      this.committedResolve = entry => {\n        this.committedTo = entry;\n        resolve(entry);\n      };\n      this.committedReject = reject;\n    });\n    this.finished = new Promise(/*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (resolve, reject) {\n        _this7.finishedResolve = () => {\n          if (_this7.committedTo === null) {\n            throw new Error('NavigateEvent should have been committed before resolving finished promise.');\n          }\n          resolve(_this7.committedTo);\n        };\n        _this7.finishedReject = reason => {\n          reject(reason);\n          _this7.abortController.abort(reason);\n        };\n      });\n      return function (_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n    // All rejections are handled.\n    this.committed.catch(() => {});\n    this.finished.catch(() => {});\n  }\n}\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, DeferBlockFixture, InjectSetupWrapper, TestBed, TestComponentRenderer, __core_private_testing_placeholder__, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick, waitForAsync, withModule, FakeNavigation as ɵFakeNavigation, MetadataOverrider as ɵMetadataOverrider };","map":{"version":3,"names":["i0","ɵDeferBlockState","_DeferBlockState","ɵtriggerResourceLoading","_triggerResourceLoading","ɵrenderDeferBlockState","_renderDeferBlockState","ɵCONTAINER_HEADER_OFFSET","_CONTAINER_HEADER_OFFSET","ɵgetDeferBlocks","_getDeferBlocks","InjectionToken","ɵDeferBlockBehavior","_DeferBlockBehavior","inject","inject$1","NgZone","ErrorHandler","Injectable","ɵNoopNgZone","_NoopNgZone","ApplicationRef","ɵPendingTasksInternal","_PendingTasksInternal","ɵZONELESS_ENABLED","_ZONELESS_ENABLED","ɵChangeDetectionScheduler","_ChangeDetectionScheduler","ɵEffectScheduler","_EffectScheduler","ɵMicrotaskEffectScheduler","_MicrotaskEffectScheduler","getDebugNode","RendererFactory2","ɵstringify","_stringify","Pipe","Directive","Component","NgModule","ɵReflectionCapabilities","_ReflectionCapabilities","ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT","_USE_RUNTIME_DEPS_TRACKER_FOR_JIT","ɵdepsTracker","_depsTracker","ɵgetInjectableDef","_getInjectableDef","resolveForwardRef","ɵisComponentDefPendingResolution","_isComponentDefPendingResolution","ɵgetAsyncClassMetadataFn","_getAsyncClassMetadataFn","ɵresolveComponentResources","_resolveComponentResources","ɵRender3NgModuleRef","_Render3NgModuleRef","ApplicationInitStatus","LOCALE_ID","ɵDEFAULT_LOCALE_ID","_DEFAULT_LOCALE_ID","ɵsetLocaleId","_setLocaleId","ɵRender3ComponentFactory","_Render3ComponentFactory","ɵNG_COMP_DEF","_NG_COMP_DEF","ɵcompileComponent","_compileComponent","ɵNG_DIR_DEF","_NG_DIR_DEF","ɵcompileDirective","_compileDirective","ɵNG_PIPE_DEF","_NG_PIPE_DEF","ɵcompilePipe","_compilePipe","ɵNG_MOD_DEF","_NG_MOD_DEF","ɵpatchComponentDefWithScope","_patchComponentDefWithScope","ɵNG_INJ_DEF","_NG_INJ_DEF","ɵcompileNgModuleDefs","_compileNgModuleDefs","ɵclearResolutionOfComponentResourcesQueue","_clearResolutionOfComponentResourcesQueue","ɵrestoreComponentResolutionQueue","_restoreComponentResolutionQueue","ɵinternalProvideZoneChangeDetection","_internalProvideZoneChangeDetection","ɵChangeDetectionSchedulerImpl","_ChangeDetectionSchedulerImpl","Compiler","ɵDEFER_BLOCK_CONFIG","_DEFER_BLOCK_CONFIG","ɵINTERNAL_APPLICATION_ERROR_HANDLER","_INTERNAL_APPLICATION_ERROR_HANDLER","COMPILER_OPTIONS","Injector","ɵtransitiveScopesFor","_transitiveScopesFor","ɵgenerateStandaloneInDeclarationsError","_generateStandaloneInDeclarationsError","ɵNgModuleFactory","_NgModuleFactory","ModuleWithComponentFactories","ɵisEnvironmentProviders","_isEnvironmentProviders","ɵconvertToBitFlags","_convertToBitFlags","InjectFlags","ɵsetAllowDuplicateNgModuleIdsForTest","_setAllowDuplicateNgModuleIdsForTest","ɵresetCompiledComponents","_resetCompiledComponents","ɵsetUnknownElementStrictMode","_setUnknownElementStrictMode","ɵsetUnknownPropertyStrictMode","_setUnknownPropertyStrictMode","ɵgetUnknownElementStrictMode","_getUnknownElementStrictMode","ɵgetUnknownPropertyStrictMode","_getUnknownPropertyStrictMode","runInInjectionContext","EnvironmentInjector","ɵflushModuleScopingQueueAsMuchAsPossible","_flushModuleScopingQueueAsMuchAsPossible","DeferBlockBehavior","DeferBlockState","Subscription","ResourceLoader","waitForAsync","fn","_Zone","Zone","Promise","reject","asyncTest","__symbol__","DeferBlockFixture","block","componentFixture","constructor","render","state","_this","_asyncToGenerator","hasStateTemplate","stateAsString","getDeferBlockStateNameFromEnum","Error","toLowerCase","Complete","tDetails","lView","tNode","skipTimerScheduling","lContainer","detectChanges","getDeferBlocks","deferBlocks","deferBlockFixtures","length","push","resolve","Placeholder","placeholderTmplIndex","Loading","loadingTmplIndex","errorTmplIndex","TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT","THROW_ON_UNKNOWN_ELEMENTS_DEFAULT","THROW_ON_UNKNOWN_PROPERTIES_DEFAULT","DEFER_BLOCK_DEFAULT_BEHAVIOR","Playthrough","TestComponentRenderer","insertRootElement","rootElementId","removeAllRootElements","ComponentFixtureAutoDetect","ComponentFixtureNoNgZone","RETHROW_APPLICATION_ERRORS_DEFAULT","TestBedApplicationErrorHandler","zone","userErrorHandler","whenStableRejectFunctions","Set","handleError","e","runOutsideAngular","userError","size","values","clear","ɵfac","TestBedApplicationErrorHandler_Factory","__ngFactoryType__","ɵprov","ɵɵdefineInjectable","token","factory","ngDevMode","ɵsetClassMetadata","type","ComponentFixture","componentRef","debugElement","componentInstance","nativeElement","elementRef","changeDetectorRef","_renderer","_isDestroyed","_noZoneOptionIsSet","optional","_ngZone","_appRef","_testAppRef","pendingTasks","appErrorHandler","zonelessEnabled","scheduler","rootEffectScheduler","microtaskEffectScheduler","autoDetectDefault","autoDetect","subscriptions","ngZone","location","instance","externalTestViews","add","hostView","notify","onDestroy","delete","onError","subscribe","next","error","checkNoChanges","flush","originalCheckNoChanges","tick","run","autoDetectChanges","isStable","hasPendingTasks","value","whenStable","then","_getRenderer","undefined","injector","get","whenRenderingDone","renderer","destroy","unsubscribe","fakeAsyncTestModule","fakeAsyncTestModuleNotLoadedErrorMessage","resetFakeAsyncZone","resetFakeAsyncZoneIfExists","fakeAsync","options","millis","tickOptions","processNewMacroTasksSynchronously","maxTurns","discardPeriodicTasks","flushMicrotasks","_nextReferenceId","MetadataOverrider","_references","Map","overrideMetadata","metadataClass","oldMetadata","override","props","_valueProps","forEach","prop","set","remove","setMetadata","removeMetadata","addMetadata","metadata","references","removeObjects","removeValue","Array","isArray","_propHashKey","propValue","filter","has","addValue","concat","propName","nextObjectId","objectIds","replacer","key","_serializeReference","JSON","stringify","ref","id","obj","Object","keys","startsWith","proto","getPrototypeOf","protoProp","desc","getOwnPropertyDescriptor","reflection","OverrideResolver","overrides","resolved","addOverride","setOverrides","getAnnotation","annotations","i","annotation","isKnownType","overrider","DirectiveResolver","ComponentResolver","PipeResolver","NgModuleResolver","TestingModuleOverride","isTestingModuleOverride","DECLARATION","OVERRIDE_TEMPLATE","assertNoStandaloneComponents","types","resolver","component","standalone","TestBedCompiler","platform","additionalModuleTypes","originalComponentResolutionQueue","declarations","imports","providers","schemas","pendingComponents","pendingDirectives","pendingPipes","componentsWithAsyncMetadata","seenComponents","seenDirectives","overriddenModules","existingComponentStyles","resolvers","initResolvers","componentToModuleScope","initialNgDefs","defCleanupOps","_injector","compilerProviders","providerOverrides","rootProviderOverrides","providerOverridesByModule","providerOverridesByToken","scopesWithOverriddenProviders","testModuleType","testModuleRef","deferBlockBehavior","rethrowApplicationTickErrors","DynamicTestModule","setCompilerProviders","configureTestingModule","moduleDef","queueTypeArray","queueTypesFromModulesArray","rethrowApplicationErrors","overrideModule","ngModule","clearScopeCacheFor","module","invalidTypeError","name","recompileNgModule","overrideComponent","verifyNoStandaloneFlagOverrides","maybeRegisterComponentWithAsyncMetadata","overrideDirective","directive","overridePipe","pipe","hasOwnProperty","overrideProvider","provider","providerDef","useFactory","provide","deps","multi","useValue","injectableDef","providedIn","overridesBucket","existingOverrides","overrideTemplateUsingTestingModule","template","def","hasStyleUrls","styleUrl","styleUrls","overrideStyleUrls","styles","resolvePendingComponentsWithAsyncMetadata","_this2","promises","asyncMetadataFn","resolvedDeps","all","flatResolvedDeps","flat","applyProviderOverridesInScope","compileComponents","_this3","clearComponentResolutionQueue","needsAsyncResources","compileTypesSync","resourceLoader","url","finalize","compileTestModule","applyTransitiveScopes","applyProviderOverrides","patchComponentsWithExistingStyles","parentInjector","runInitializers","localeId","_compileNgModuleSync","moduleType","_compileNgModuleAsync","_this4","_getModuleResolver","_getComponentFactories","maybeUnwrapFn","ɵmod","reduce","factories","declaration","componentDef","ɵcmp","maybeStoreNgDef","testingModuleDef","affectedModules","collectModulesAffectedByOverrides","storeFieldOfDefOnType","transitiveCompileScopes","moduleToScope","getScopeOfModule","isTestingModule","realType","componentType","moduleScope","getComponentDef","maybeApplyOverrides","field","hasProviderOverrides","patchDefWithProviderOverrides","hasScope","isStandaloneComponent","isNgModule","injectorDef","dependencies","dependency","getOverriddenProviders","importedModule","flatten","isModuleWithProviders","object","fieldName","originalValue","arr","queueType","processedDefs","queueTypesFromModulesArrayRecur","hasNgModuleDef","exports","seenModules","calcAffectedModulesRecur","path","item","currentDefs","currentDef","defField","restoreComponentResolutionQueue","restoreOriginalState","forEachRight","op","defs","descriptor","defineProperty","RootScopeModule","useExisting","R3TestCompiler","behavior","handler","compilerOptions","opts","create","parent","getSingleProviderOverrides","getProviderToken","getProviderOverrides","flattenProviders","flattenedProviders","overriddenProviders","final","seenOverriddenProviders","unshift","providersResolver","processProvidersFn","ngDef","maybeFn","Function","out","identityFn","mapFn","ɵproviders","getProviderField","idx","expectedType","testBed","compileModuleSync","compileModuleAsync","_this5","compileModuleAndAllComponentsSync","ngModuleFactory","componentFactories","compileModuleAndAllComponentsAsync","_this6","clearCache","clearCacheFor","getModuleId","meta","_nextRootElementId","getTestBed","TestBedImpl","INSTANCE","_INSTANCE","_environmentTeardownOptions","_environmentErrorOnUnknownElementsOption","_environmentErrorOnUnknownPropertiesOption","_instanceTeardownOptions","_instanceDeferBlockBehavior","_instanceErrorOnUnknownElementsOption","_instanceErrorOnUnknownPropertiesOption","_previousErrorOnUnknownElementsOption","_previousErrorOnUnknownPropertiesOption","initTestEnvironment","resetTestEnvironment","configureCompiler","config","overrideTemplate","notFoundValue","flags","THROW_IF_NOT_FOUND","Default","createComponent","resetTestingModule","execute","tokens","context","flushEffects","_compiler","_testModuleRef","_activeFixtures","globalCompilationChecked","teardown","errorOnUnknownElements","errorOnUnknownProperties","checkGlobalCompilationFinished","compiler","destroyActiveFixtures","shouldTearDownTestingModule","tearDownTestingModule","useJit","assertNotInstantiated","shouldThrowErrorOnUnknownElements","shouldThrowErrorOnUnknownProperties","TestBed","UNDEFINED","result","params","map","t","apply","templateUrl","testComponentRenderer","rootElId","componentFactory","initComponent","NULL","noNgZone","fixture","methodName","methodDescription","errorCount","console","stacktrace","shouldRethrowTeardownErrors","instanceOptions","environmentOptions","rethrowErrors","destroyAfterEach","getDeferBlockBehavior","testRenderer","InjectSetupWrapper","_moduleDef","_addModule","self","call","withModule","globalThis","beforeEach","getCleanupHook","afterEach","expectedTeardownValue","__core_private_testing_placeholder__","FakeNavigation","window","entriesArr","currentEntryIndex","navigateEvent","traversalQueue","nextTraversal","prospectiveEntryIndex","synchronousTraversals","canSetInitialEntry","eventTarget","nextId","nextKey","disposed","currentEntry","canGoBack","canGoForward","startURL","document","createElement","setInitialEntryForTesting","historyState","currentInitialEntry","FakeNavigationHistoryEntry","URL","toString","index","String","sameDocument","canSetInitialEntryForTesting","setSynchronousTraversalsForTesting","entries","slice","navigate","fromUrl","toUrl","navigationType","history","hashChange","isHashChange","destination","FakeNavigationDestination","InternalNavigationResult","userAgentNavigate","cancelable","canIntercept","userInitiated","info","committed","finished","pushState","data","title","pushOrReplaceState","replaceState","_title","traverseTo","entry","findEntry","domException","DOMException","catch","existingResult","getState","getHistoryState","runTraversal","event","userAgentTraverse","back","forward","go","direction","targetIndex","traversal","setTimeout","addEventListener","callback","removeEventListener","dispatchEvent","dispose","isDisposed","cancel","dispatchNavigateEvent","signal","commitNavigateEvent","interceptionState","from","urlAndHistoryUpdateSteps","updateNavigationEntriesForSameDocumentNavigation","popStateEvent","createPopStateEvent","oldCurrentNHE","disposedNHEs","splice","newNHE","committedResolve","currentEntryChangeEvent","createFakeNavigationCurrentEntryChangeEvent","disposedNHE","onnavigate","_handler","oncurrententrychange","onnavigatesuccess","onnavigateerror","_transition","transition","updateCurrentEntry","_options","reload","ondispose","parse","disposeEvent","Event","navigation","bubbles","focusResetBehavior","scrollBehavior","downloadRequest","formData","commitOption","handlersFinished","dispatchedNavigateEvent","intercept","commit","scroll","focusReset","processScrollBehavior","internal","reason","committedReject","finishedReject","dispatch","InternalNavigationTransition","aborted","finishNavigationEvent","navigatesuccessEvent","finishedResolve","navigateerrorEvent","didFulfill","potentiallyResetFocus","potentiallyResetScroll","to","hash","hostname","pathname","search","committedTo","abortController","AbortController","_this7","_ref","abort","_x","_x2","arguments","ɵFakeNavigation","ɵMetadataOverrider"],"sources":["C:/projetos/meus projetos/portfolio/node_modules/@angular/core/fesm2022/testing.mjs"],"sourcesContent":["/**\n * @license Angular v19.2.3\n * (c) 2010-2025 Google LLC. https://angular.io/\n * License: MIT\n */\n\nimport * as i0 from '@angular/core';\nimport { ɵDeferBlockState as _DeferBlockState, ɵtriggerResourceLoading as _triggerResourceLoading, ɵrenderDeferBlockState as _renderDeferBlockState, ɵCONTAINER_HEADER_OFFSET as _CONTAINER_HEADER_OFFSET, ɵgetDeferBlocks as _getDeferBlocks, InjectionToken, ɵDeferBlockBehavior as _DeferBlockBehavior, inject as inject$1, NgZone, ErrorHandler, Injectable, ɵNoopNgZone as _NoopNgZone, ApplicationRef, ɵPendingTasksInternal as _PendingTasksInternal, ɵZONELESS_ENABLED as _ZONELESS_ENABLED, ɵChangeDetectionScheduler as _ChangeDetectionScheduler, ɵEffectScheduler as _EffectScheduler, ɵMicrotaskEffectScheduler as _MicrotaskEffectScheduler, getDebugNode, RendererFactory2, ɵstringify as _stringify, Pipe, Directive, Component, NgModule, ɵReflectionCapabilities as _ReflectionCapabilities, ɵUSE_RUNTIME_DEPS_TRACKER_FOR_JIT as _USE_RUNTIME_DEPS_TRACKER_FOR_JIT, ɵdepsTracker as _depsTracker, ɵgetInjectableDef as _getInjectableDef, resolveForwardRef, ɵisComponentDefPendingResolution as _isComponentDefPendingResolution, ɵgetAsyncClassMetadataFn as _getAsyncClassMetadataFn, ɵresolveComponentResources as _resolveComponentResources, ɵRender3NgModuleRef as _Render3NgModuleRef, ApplicationInitStatus, LOCALE_ID, ɵDEFAULT_LOCALE_ID as _DEFAULT_LOCALE_ID, ɵsetLocaleId as _setLocaleId, ɵRender3ComponentFactory as _Render3ComponentFactory, ɵNG_COMP_DEF as _NG_COMP_DEF, ɵcompileComponent as _compileComponent, ɵNG_DIR_DEF as _NG_DIR_DEF, ɵcompileDirective as _compileDirective, ɵNG_PIPE_DEF as _NG_PIPE_DEF, ɵcompilePipe as _compilePipe, ɵNG_MOD_DEF as _NG_MOD_DEF, ɵpatchComponentDefWithScope as _patchComponentDefWithScope, ɵNG_INJ_DEF as _NG_INJ_DEF, ɵcompileNgModuleDefs as _compileNgModuleDefs, ɵclearResolutionOfComponentResourcesQueue as _clearResolutionOfComponentResourcesQueue, ɵrestoreComponentResolutionQueue as _restoreComponentResolutionQueue, ɵinternalProvideZoneChangeDetection as _internalProvideZoneChangeDetection, ɵChangeDetectionSchedulerImpl as _ChangeDetectionSchedulerImpl, Compiler, ɵDEFER_BLOCK_CONFIG as _DEFER_BLOCK_CONFIG, ɵINTERNAL_APPLICATION_ERROR_HANDLER as _INTERNAL_APPLICATION_ERROR_HANDLER, COMPILER_OPTIONS, Injector, ɵtransitiveScopesFor as _transitiveScopesFor, ɵgenerateStandaloneInDeclarationsError as _generateStandaloneInDeclarationsError, ɵNgModuleFactory as _NgModuleFactory, ModuleWithComponentFactories, ɵisEnvironmentProviders as _isEnvironmentProviders, ɵconvertToBitFlags as _convertToBitFlags, InjectFlags, ɵsetAllowDuplicateNgModuleIdsForTest as _setAllowDuplicateNgModuleIdsForTest, ɵresetCompiledComponents as _resetCompiledComponents, ɵsetUnknownElementStrictMode as _setUnknownElementStrictMode, ɵsetUnknownPropertyStrictMode as _setUnknownPropertyStrictMode, ɵgetUnknownElementStrictMode as _getUnknownElementStrictMode, ɵgetUnknownPropertyStrictMode as _getUnknownPropertyStrictMode, runInInjectionContext, EnvironmentInjector, ɵflushModuleScopingQueueAsMuchAsPossible as _flushModuleScopingQueueAsMuchAsPossible } from '@angular/core';\nexport { ɵDeferBlockBehavior as DeferBlockBehavior, ɵDeferBlockState as DeferBlockState } from '@angular/core';\nimport { Subscription } from 'rxjs';\nimport { ResourceLoader } from '@angular/compiler';\n\n/**\n * Wraps a test function in an asynchronous test zone. The test will automatically\n * complete when all asynchronous calls within this zone are done. Can be used\n * to wrap an {@link inject} call.\n *\n * Example:\n *\n * ```ts\n * it('...', waitForAsync(inject([AClass], (object) => {\n *   object.doSomething.then(() => {\n *     expect(...);\n *   })\n * })));\n * ```\n *\n * @publicApi\n */\nfunction waitForAsync(fn) {\n    const _Zone = typeof Zone !== 'undefined' ? Zone : null;\n    if (!_Zone) {\n        return function () {\n            return Promise.reject('Zone is needed for the waitForAsync() test helper but could not be found. ' +\n                'Please make sure that your environment includes zone.js');\n        };\n    }\n    const asyncTest = _Zone && _Zone[_Zone.__symbol__('asyncTest')];\n    if (typeof asyncTest === 'function') {\n        return asyncTest(fn);\n    }\n    return function () {\n        return Promise.reject('zone-testing.js is needed for the async() test helper but could not be found. ' +\n            'Please make sure that your environment includes zone.js/testing');\n    };\n}\n\n/**\n * Represents an individual defer block for testing purposes.\n *\n * @publicApi\n */\nclass DeferBlockFixture {\n    block;\n    componentFixture;\n    /** @nodoc */\n    constructor(block, componentFixture) {\n        this.block = block;\n        this.componentFixture = componentFixture;\n    }\n    /**\n     * Renders the specified state of the defer fixture.\n     * @param state the defer state to render\n     */\n    async render(state) {\n        if (!hasStateTemplate(state, this.block)) {\n            const stateAsString = getDeferBlockStateNameFromEnum(state);\n            throw new Error(`Tried to render this defer block in the \\`${stateAsString}\\` state, ` +\n                `but there was no @${stateAsString.toLowerCase()} block defined in a template.`);\n        }\n        if (state === _DeferBlockState.Complete) {\n            await _triggerResourceLoading(this.block.tDetails, this.block.lView, this.block.tNode);\n        }\n        // If the `render` method is used explicitly - skip timer-based scheduling for\n        // `@placeholder` and `@loading` blocks and render them immediately.\n        const skipTimerScheduling = true;\n        _renderDeferBlockState(state, this.block.tNode, this.block.lContainer, skipTimerScheduling);\n        this.componentFixture.detectChanges();\n    }\n    /**\n     * Retrieves all nested child defer block fixtures\n     * in a given defer block.\n     */\n    getDeferBlocks() {\n        const deferBlocks = [];\n        // An LContainer that represents a defer block has at most 1 view, which is\n        // located right after an LContainer header. Get a hold of that view and inspect\n        // it for nested defer blocks.\n        const deferBlockFixtures = [];\n        if (this.block.lContainer.length >= _CONTAINER_HEADER_OFFSET) {\n            const lView = this.block.lContainer[_CONTAINER_HEADER_OFFSET];\n            _getDeferBlocks(lView, deferBlocks);\n            for (const block of deferBlocks) {\n                deferBlockFixtures.push(new DeferBlockFixture(block, this.componentFixture));\n            }\n        }\n        return Promise.resolve(deferBlockFixtures);\n    }\n}\nfunction hasStateTemplate(state, block) {\n    switch (state) {\n        case _DeferBlockState.Placeholder:\n            return block.tDetails.placeholderTmplIndex !== null;\n        case _DeferBlockState.Loading:\n            return block.tDetails.loadingTmplIndex !== null;\n        case _DeferBlockState.Error:\n            return block.tDetails.errorTmplIndex !== null;\n        case _DeferBlockState.Complete:\n            return true;\n        default:\n            return false;\n    }\n}\nfunction getDeferBlockStateNameFromEnum(state) {\n    switch (state) {\n        case _DeferBlockState.Placeholder:\n            return 'Placeholder';\n        case _DeferBlockState.Loading:\n            return 'Loading';\n        case _DeferBlockState.Error:\n            return 'Error';\n        default:\n            return 'Main';\n    }\n}\n\n/** Whether test modules should be torn down by default. */\nconst TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT = true;\n/** Whether unknown elements in templates should throw by default. */\nconst THROW_ON_UNKNOWN_ELEMENTS_DEFAULT = false;\n/** Whether unknown properties in templates should throw by default. */\nconst THROW_ON_UNKNOWN_PROPERTIES_DEFAULT = false;\n/** Whether defer blocks should use manual triggering or play through normally. */\nconst DEFER_BLOCK_DEFAULT_BEHAVIOR = _DeferBlockBehavior.Playthrough;\n/**\n * An abstract class for inserting the root test component element in a platform independent way.\n *\n * @publicApi\n */\nclass TestComponentRenderer {\n    insertRootElement(rootElementId) { }\n    removeAllRootElements() { }\n}\n/**\n * @publicApi\n */\nconst ComponentFixtureAutoDetect = new InjectionToken('ComponentFixtureAutoDetect');\n/**\n * @publicApi\n */\nconst ComponentFixtureNoNgZone = new InjectionToken('ComponentFixtureNoNgZone');\n\nconst RETHROW_APPLICATION_ERRORS_DEFAULT = true;\nclass TestBedApplicationErrorHandler {\n    zone = inject$1(NgZone);\n    userErrorHandler = inject$1(ErrorHandler);\n    whenStableRejectFunctions = new Set();\n    handleError(e) {\n        try {\n            this.zone.runOutsideAngular(() => this.userErrorHandler.handleError(e));\n        }\n        catch (userError) {\n            e = userError;\n        }\n        // Instead of throwing the error when there are outstanding `fixture.whenStable` promises,\n        // reject those promises with the error. This allows developers to write\n        // expectAsync(fix.whenStable()).toBeRejected();\n        if (this.whenStableRejectFunctions.size > 0) {\n            for (const fn of this.whenStableRejectFunctions.values()) {\n                fn(e);\n            }\n            this.whenStableRejectFunctions.clear();\n        }\n        else {\n            throw e;\n        }\n    }\n    static ɵfac = function TestBedApplicationErrorHandler_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || TestBedApplicationErrorHandler)(); };\n    static ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: TestBedApplicationErrorHandler, factory: TestBedApplicationErrorHandler.ɵfac });\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(TestBedApplicationErrorHandler, [{\n        type: Injectable\n    }], null, null); })();\n\n/**\n * Fixture for debugging and testing a component.\n *\n * @publicApi\n */\nclass ComponentFixture {\n    componentRef;\n    /**\n     * The DebugElement associated with the root element of this component.\n     */\n    debugElement;\n    /**\n     * The instance of the root component class.\n     */\n    componentInstance;\n    /**\n     * The native element at the root of the component.\n     */\n    nativeElement;\n    /**\n     * The ElementRef for the element at the root of the component.\n     */\n    elementRef;\n    /**\n     * The ChangeDetectorRef for the component\n     */\n    changeDetectorRef;\n    _renderer;\n    _isDestroyed = false;\n    /** @internal */\n    _noZoneOptionIsSet = inject$1(ComponentFixtureNoNgZone, { optional: true });\n    /** @internal */\n    _ngZone = this._noZoneOptionIsSet ? new _NoopNgZone() : inject$1(NgZone);\n    // Inject ApplicationRef to ensure NgZone stableness causes after render hooks to run\n    // This will likely happen as a result of fixture.detectChanges because it calls ngZone.run\n    // This is a crazy way of doing things but hey, it's the world we live in.\n    // The zoneless scheduler should instead do this more imperatively by attaching\n    // the `ComponentRef` to `ApplicationRef` and calling `appRef.tick` as the `detectChanges`\n    // behavior.\n    /** @internal */\n    _appRef = inject$1(ApplicationRef);\n    _testAppRef = this._appRef;\n    pendingTasks = inject$1(_PendingTasksInternal);\n    appErrorHandler = inject$1(TestBedApplicationErrorHandler);\n    zonelessEnabled = inject$1(_ZONELESS_ENABLED);\n    scheduler = inject$1(_ChangeDetectionScheduler);\n    rootEffectScheduler = inject$1(_EffectScheduler);\n    microtaskEffectScheduler = inject$1(_MicrotaskEffectScheduler);\n    autoDetectDefault = this.zonelessEnabled ? true : false;\n    autoDetect = inject$1(ComponentFixtureAutoDetect, { optional: true }) ?? this.autoDetectDefault;\n    subscriptions = new Subscription();\n    // TODO(atscott): Remove this from public API\n    ngZone = this._noZoneOptionIsSet ? null : this._ngZone;\n    /** @nodoc */\n    constructor(componentRef) {\n        this.componentRef = componentRef;\n        this.changeDetectorRef = componentRef.changeDetectorRef;\n        this.elementRef = componentRef.location;\n        this.debugElement = getDebugNode(this.elementRef.nativeElement);\n        this.componentInstance = componentRef.instance;\n        this.nativeElement = this.elementRef.nativeElement;\n        this.componentRef = componentRef;\n        if (this.autoDetect) {\n            this._testAppRef.externalTestViews.add(this.componentRef.hostView);\n            this.scheduler?.notify(8 /* ɵNotificationSource.ViewAttached */);\n            this.scheduler?.notify(0 /* ɵNotificationSource.MarkAncestorsForTraversal */);\n        }\n        this.componentRef.hostView.onDestroy(() => {\n            this._testAppRef.externalTestViews.delete(this.componentRef.hostView);\n        });\n        // Create subscriptions outside the NgZone so that the callbacks run outside\n        // of NgZone.\n        this._ngZone.runOutsideAngular(() => {\n            this.subscriptions.add(this._ngZone.onError.subscribe({\n                next: (error) => {\n                    throw error;\n                },\n            }));\n        });\n    }\n    /**\n     * Trigger a change detection cycle for the component.\n     */\n    detectChanges(checkNoChanges = true) {\n        this.microtaskEffectScheduler.flush();\n        const originalCheckNoChanges = this.componentRef.changeDetectorRef.checkNoChanges;\n        try {\n            if (!checkNoChanges) {\n                this.componentRef.changeDetectorRef.checkNoChanges = () => { };\n            }\n            if (this.zonelessEnabled) {\n                try {\n                    this._testAppRef.externalTestViews.add(this.componentRef.hostView);\n                    this._appRef.tick();\n                }\n                finally {\n                    if (!this.autoDetect) {\n                        this._testAppRef.externalTestViews.delete(this.componentRef.hostView);\n                    }\n                }\n            }\n            else {\n                // Run the change detection inside the NgZone so that any async tasks as part of the change\n                // detection are captured by the zone and can be waited for in isStable.\n                this._ngZone.run(() => {\n                    // Flush root effects before `detectChanges()`, to emulate the sequencing of `tick()`.\n                    this.rootEffectScheduler.flush();\n                    this.changeDetectorRef.detectChanges();\n                    this.checkNoChanges();\n                });\n            }\n        }\n        finally {\n            this.componentRef.changeDetectorRef.checkNoChanges = originalCheckNoChanges;\n        }\n        this.microtaskEffectScheduler.flush();\n    }\n    /**\n     * Do a change detection run to make sure there were no changes.\n     */\n    checkNoChanges() {\n        this.changeDetectorRef.checkNoChanges();\n    }\n    /**\n     * Set whether the fixture should autodetect changes.\n     *\n     * Also runs detectChanges once so that any existing change is detected.\n     *\n     * @param autoDetect Whether to autodetect changes. By default, `true`.\n     */\n    autoDetectChanges(autoDetect = true) {\n        if (this._noZoneOptionIsSet && !this.zonelessEnabled) {\n            throw new Error('Cannot call autoDetectChanges when ComponentFixtureNoNgZone is set.');\n        }\n        if (autoDetect !== this.autoDetect) {\n            if (autoDetect) {\n                this._testAppRef.externalTestViews.add(this.componentRef.hostView);\n            }\n            else {\n                this._testAppRef.externalTestViews.delete(this.componentRef.hostView);\n            }\n        }\n        this.autoDetect = autoDetect;\n        this.detectChanges();\n    }\n    /**\n     * Return whether the fixture is currently stable or has async tasks that have not been completed\n     * yet.\n     */\n    isStable() {\n        return !this.pendingTasks.hasPendingTasks.value;\n    }\n    /**\n     * Get a promise that resolves when the fixture is stable.\n     *\n     * This can be used to resume testing after events have triggered asynchronous activity or\n     * asynchronous change detection.\n     */\n    whenStable() {\n        if (this.isStable()) {\n            return Promise.resolve(false);\n        }\n        return new Promise((resolve, reject) => {\n            this.appErrorHandler.whenStableRejectFunctions.add(reject);\n            this._appRef.whenStable().then(() => {\n                this.appErrorHandler.whenStableRejectFunctions.delete(reject);\n                resolve(true);\n            });\n        });\n    }\n    /**\n     * Retrieves all defer block fixtures in the component fixture.\n     */\n    getDeferBlocks() {\n        const deferBlocks = [];\n        const lView = this.componentRef.hostView['_lView'];\n        _getDeferBlocks(lView, deferBlocks);\n        const deferBlockFixtures = [];\n        for (const block of deferBlocks) {\n            deferBlockFixtures.push(new DeferBlockFixture(block, this));\n        }\n        return Promise.resolve(deferBlockFixtures);\n    }\n    _getRenderer() {\n        if (this._renderer === undefined) {\n            this._renderer = this.componentRef.injector.get(RendererFactory2, null);\n        }\n        return this._renderer;\n    }\n    /**\n     * Get a promise that resolves when the ui state is stable following animations.\n     */\n    whenRenderingDone() {\n        const renderer = this._getRenderer();\n        if (renderer && renderer.whenRenderingDone) {\n            return renderer.whenRenderingDone();\n        }\n        return this.whenStable();\n    }\n    /**\n     * Trigger component destruction.\n     */\n    destroy() {\n        this.subscriptions.unsubscribe();\n        this._testAppRef.externalTestViews.delete(this.componentRef.hostView);\n        if (!this._isDestroyed) {\n            this.componentRef.destroy();\n            this._isDestroyed = true;\n        }\n    }\n}\n\nconst _Zone = typeof Zone !== 'undefined' ? Zone : null;\nconst fakeAsyncTestModule = _Zone && _Zone[_Zone.__symbol__('fakeAsyncTest')];\nconst fakeAsyncTestModuleNotLoadedErrorMessage = `zone-testing.js is needed for the fakeAsync() test helper but could not be found.\n        Please make sure that your environment includes zone.js/testing`;\n/**\n * Clears out the shared fake async zone for a test.\n * To be called in a global `beforeEach`.\n *\n * @publicApi\n */\nfunction resetFakeAsyncZone() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.resetFakeAsyncZone();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\nfunction resetFakeAsyncZoneIfExists() {\n    if (fakeAsyncTestModule) {\n        fakeAsyncTestModule.resetFakeAsyncZone();\n    }\n}\n/**\n * Wraps a function to be executed in the `fakeAsync` zone:\n * - Microtasks are manually executed by calling `flushMicrotasks()`.\n * - Timers are synchronous; `tick()` simulates the asynchronous passage of time.\n *\n * Can be used to wrap `inject()` calls.\n *\n * @param fn The function that you want to wrap in the `fakeAsync` zone.\n * @param options\n *   - flush: When true, will drain the macrotask queue after the test function completes.\n *     When false, will throw an exception at the end of the function if there are pending timers.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n *\n * @returns The function wrapped to be executed in the `fakeAsync` zone.\n * Any arguments passed when calling this returned function will be passed through to the `fn`\n * function in the parameters when it is called.\n *\n * @publicApi\n */\nfunction fakeAsync(fn, options) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.fakeAsync(fn, options);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Simulates the asynchronous passage of time for the timers in the `fakeAsync` zone.\n *\n * The microtasks queue is drained at the very start of this function and after any timer callback\n * has been executed.\n *\n * @param millis The number of milliseconds to advance the virtual timer.\n * @param tickOptions The options to pass to the `tick()` function.\n *\n * @usageNotes\n *\n * The `tick()` option is a flag called `processNewMacroTasksSynchronously`,\n * which determines whether or not to invoke new macroTasks.\n *\n * If you provide a `tickOptions` object, but do not specify a\n * `processNewMacroTasksSynchronously` property (`tick(100, {})`),\n * then `processNewMacroTasksSynchronously` defaults to true.\n *\n * If you omit the `tickOptions` parameter (`tick(100))`), then\n * `tickOptions` defaults to `{processNewMacroTasksSynchronously: true}`.\n *\n * ### Example\n *\n * {@example core/testing/ts/fake_async.ts region='basic'}\n *\n * The following example includes a nested timeout (new macroTask), and\n * the `tickOptions` parameter is allowed to default. In this case,\n * `processNewMacroTasksSynchronously` defaults to true, and the nested\n * function is executed on each tick.\n *\n * ```ts\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick();\n *   expect(nestedTimeoutInvoked).toBe(true);\n * }));\n * ```\n *\n * In the following case, `processNewMacroTasksSynchronously` is explicitly\n * set to false, so the nested timeout function is not invoked.\n *\n * ```ts\n * it ('test with nested setTimeout', fakeAsync(() => {\n *   let nestedTimeoutInvoked = false;\n *   function funcWithNestedTimeout() {\n *     setTimeout(() => {\n *       nestedTimeoutInvoked = true;\n *     });\n *   };\n *   setTimeout(funcWithNestedTimeout);\n *   tick(0, {processNewMacroTasksSynchronously: false});\n *   expect(nestedTimeoutInvoked).toBe(false);\n * }));\n * ```\n *\n *\n * @publicApi\n */\nfunction tick(millis = 0, tickOptions = {\n    processNewMacroTasksSynchronously: true,\n}) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.tick(millis, tickOptions);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flushes any pending microtasks and simulates the asynchronous passage of time for the timers in\n * the `fakeAsync` zone by\n * draining the macrotask queue until it is empty.\n *\n * @param maxTurns The maximum number of times the scheduler attempts to clear its queue before\n *     throwing an error.\n * @returns The simulated time elapsed, in milliseconds.\n *\n * @publicApi\n */\nfunction flush(maxTurns) {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flush(maxTurns);\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Discard all remaining periodic tasks.\n *\n * @publicApi\n */\nfunction discardPeriodicTasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.discardPeriodicTasks();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n/**\n * Flush any pending microtasks.\n *\n * @publicApi\n */\nfunction flushMicrotasks() {\n    if (fakeAsyncTestModule) {\n        return fakeAsyncTestModule.flushMicrotasks();\n    }\n    throw new Error(fakeAsyncTestModuleNotLoadedErrorMessage);\n}\n\nlet _nextReferenceId = 0;\nclass MetadataOverrider {\n    _references = new Map();\n    /**\n     * Creates a new instance for the given metadata class\n     * based on an old instance and overrides.\n     */\n    overrideMetadata(metadataClass, oldMetadata, override) {\n        const props = {};\n        if (oldMetadata) {\n            _valueProps(oldMetadata).forEach((prop) => (props[prop] = oldMetadata[prop]));\n        }\n        if (override.set) {\n            if (override.remove || override.add) {\n                throw new Error(`Cannot set and add/remove ${_stringify(metadataClass)} at the same time!`);\n            }\n            setMetadata(props, override.set);\n        }\n        if (override.remove) {\n            removeMetadata(props, override.remove, this._references);\n        }\n        if (override.add) {\n            addMetadata(props, override.add);\n        }\n        return new metadataClass(props);\n    }\n}\nfunction removeMetadata(metadata, remove, references) {\n    const removeObjects = new Set();\n    for (const prop in remove) {\n        const removeValue = remove[prop];\n        if (Array.isArray(removeValue)) {\n            removeValue.forEach((value) => {\n                removeObjects.add(_propHashKey(prop, value, references));\n            });\n        }\n        else {\n            removeObjects.add(_propHashKey(prop, removeValue, references));\n        }\n    }\n    for (const prop in metadata) {\n        const propValue = metadata[prop];\n        if (Array.isArray(propValue)) {\n            metadata[prop] = propValue.filter((value) => !removeObjects.has(_propHashKey(prop, value, references)));\n        }\n        else {\n            if (removeObjects.has(_propHashKey(prop, propValue, references))) {\n                metadata[prop] = undefined;\n            }\n        }\n    }\n}\nfunction addMetadata(metadata, add) {\n    for (const prop in add) {\n        const addValue = add[prop];\n        const propValue = metadata[prop];\n        if (propValue != null && Array.isArray(propValue)) {\n            metadata[prop] = propValue.concat(addValue);\n        }\n        else {\n            metadata[prop] = addValue;\n        }\n    }\n}\nfunction setMetadata(metadata, set) {\n    for (const prop in set) {\n        metadata[prop] = set[prop];\n    }\n}\nfunction _propHashKey(propName, propValue, references) {\n    let nextObjectId = 0;\n    const objectIds = new Map();\n    const replacer = (key, value) => {\n        if (value !== null && typeof value === 'object') {\n            if (objectIds.has(value)) {\n                return objectIds.get(value);\n            }\n            // Record an id for this object such that any later references use the object's id instead\n            // of the object itself, in order to break cyclic pointers in objects.\n            objectIds.set(value, `ɵobj#${nextObjectId++}`);\n            // The first time an object is seen the object itself is serialized.\n            return value;\n        }\n        else if (typeof value === 'function') {\n            value = _serializeReference(value, references);\n        }\n        return value;\n    };\n    return `${propName}:${JSON.stringify(propValue, replacer)}`;\n}\nfunction _serializeReference(ref, references) {\n    let id = references.get(ref);\n    if (!id) {\n        id = `${_stringify(ref)}${_nextReferenceId++}`;\n        references.set(ref, id);\n    }\n    return id;\n}\nfunction _valueProps(obj) {\n    const props = [];\n    // regular public props\n    Object.keys(obj).forEach((prop) => {\n        if (!prop.startsWith('_')) {\n            props.push(prop);\n        }\n    });\n    // getters\n    let proto = obj;\n    while ((proto = Object.getPrototypeOf(proto))) {\n        Object.keys(proto).forEach((protoProp) => {\n            const desc = Object.getOwnPropertyDescriptor(proto, protoProp);\n            if (!protoProp.startsWith('_') && desc && 'get' in desc) {\n                props.push(protoProp);\n            }\n        });\n    }\n    return props;\n}\n\nconst reflection = new _ReflectionCapabilities();\n/**\n * Allows to override ivy metadata for tests (via the `TestBed`).\n */\nclass OverrideResolver {\n    overrides = new Map();\n    resolved = new Map();\n    addOverride(type, override) {\n        const overrides = this.overrides.get(type) || [];\n        overrides.push(override);\n        this.overrides.set(type, overrides);\n        this.resolved.delete(type);\n    }\n    setOverrides(overrides) {\n        this.overrides.clear();\n        overrides.forEach(([type, override]) => {\n            this.addOverride(type, override);\n        });\n    }\n    getAnnotation(type) {\n        const annotations = reflection.annotations(type);\n        // Try to find the nearest known Type annotation and make sure that this annotation is an\n        // instance of the type we are looking for, so we can use it for resolution. Note: there might\n        // be multiple known annotations found due to the fact that Components can extend Directives (so\n        // both Directive and Component annotations would be present), so we always check if the known\n        // annotation has the right type.\n        for (let i = annotations.length - 1; i >= 0; i--) {\n            const annotation = annotations[i];\n            const isKnownType = annotation instanceof Directive ||\n                annotation instanceof Component ||\n                annotation instanceof Pipe ||\n                annotation instanceof NgModule;\n            if (isKnownType) {\n                return annotation instanceof this.type ? annotation : null;\n            }\n        }\n        return null;\n    }\n    resolve(type) {\n        let resolved = this.resolved.get(type) || null;\n        if (!resolved) {\n            resolved = this.getAnnotation(type);\n            if (resolved) {\n                const overrides = this.overrides.get(type);\n                if (overrides) {\n                    const overrider = new MetadataOverrider();\n                    overrides.forEach((override) => {\n                        resolved = overrider.overrideMetadata(this.type, resolved, override);\n                    });\n                }\n            }\n            this.resolved.set(type, resolved);\n        }\n        return resolved;\n    }\n}\nclass DirectiveResolver extends OverrideResolver {\n    get type() {\n        return Directive;\n    }\n}\nclass ComponentResolver extends OverrideResolver {\n    get type() {\n        return Component;\n    }\n}\nclass PipeResolver extends OverrideResolver {\n    get type() {\n        return Pipe;\n    }\n}\nclass NgModuleResolver extends OverrideResolver {\n    get type() {\n        return NgModule;\n    }\n}\n\nvar TestingModuleOverride;\n(function (TestingModuleOverride) {\n    TestingModuleOverride[TestingModuleOverride[\"DECLARATION\"] = 0] = \"DECLARATION\";\n    TestingModuleOverride[TestingModuleOverride[\"OVERRIDE_TEMPLATE\"] = 1] = \"OVERRIDE_TEMPLATE\";\n})(TestingModuleOverride || (TestingModuleOverride = {}));\nfunction isTestingModuleOverride(value) {\n    return (value === TestingModuleOverride.DECLARATION || value === TestingModuleOverride.OVERRIDE_TEMPLATE);\n}\nfunction assertNoStandaloneComponents(types, resolver, location) {\n    types.forEach((type) => {\n        if (!_getAsyncClassMetadataFn(type)) {\n            const component = resolver.resolve(type);\n            if (component && (component.standalone == null || component.standalone)) {\n                throw new Error(_generateStandaloneInDeclarationsError(type, location));\n            }\n        }\n    });\n}\nclass TestBedCompiler {\n    platform;\n    additionalModuleTypes;\n    originalComponentResolutionQueue = null;\n    // Testing module configuration\n    declarations = [];\n    imports = [];\n    providers = [];\n    schemas = [];\n    // Queues of components/directives/pipes that should be recompiled.\n    pendingComponents = new Set();\n    pendingDirectives = new Set();\n    pendingPipes = new Set();\n    // Set of components with async metadata, i.e. components with `@defer` blocks\n    // in their templates.\n    componentsWithAsyncMetadata = new Set();\n    // Keep track of all components and directives, so we can patch Providers onto defs later.\n    seenComponents = new Set();\n    seenDirectives = new Set();\n    // Keep track of overridden modules, so that we can collect all affected ones in the module tree.\n    overriddenModules = new Set();\n    // Store resolved styles for Components that have template overrides present and `styleUrls`\n    // defined at the same time.\n    existingComponentStyles = new Map();\n    resolvers = initResolvers();\n    // Map of component type to an NgModule that declares it.\n    //\n    // There are a couple special cases:\n    // - for standalone components, the module scope value is `null`\n    // - when a component is declared in `TestBed.configureTestingModule()` call or\n    //   a component's template is overridden via `TestBed.overrideTemplateUsingTestingModule()`.\n    //   we use a special value from the `TestingModuleOverride` enum.\n    componentToModuleScope = new Map();\n    // Map that keeps initial version of component/directive/pipe defs in case\n    // we compile a Type again, thus overriding respective static fields. This is\n    // required to make sure we restore defs to their initial states between test runs.\n    // Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of an\n    // NgModule), store all of them in a map.\n    initialNgDefs = new Map();\n    // Array that keeps cleanup operations for initial versions of component/directive/pipe/module\n    // defs in case TestBed makes changes to the originals.\n    defCleanupOps = [];\n    _injector = null;\n    compilerProviders = null;\n    providerOverrides = [];\n    rootProviderOverrides = [];\n    // Overrides for injectables with `{providedIn: SomeModule}` need to be tracked and added to that\n    // module's provider list.\n    providerOverridesByModule = new Map();\n    providerOverridesByToken = new Map();\n    scopesWithOverriddenProviders = new Set();\n    testModuleType;\n    testModuleRef = null;\n    deferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    rethrowApplicationTickErrors = RETHROW_APPLICATION_ERRORS_DEFAULT;\n    constructor(platform, additionalModuleTypes) {\n        this.platform = platform;\n        this.additionalModuleTypes = additionalModuleTypes;\n        class DynamicTestModule {\n        }\n        this.testModuleType = DynamicTestModule;\n    }\n    setCompilerProviders(providers) {\n        this.compilerProviders = providers;\n        this._injector = null;\n    }\n    configureTestingModule(moduleDef) {\n        // Enqueue any compilation tasks for the directly declared component.\n        if (moduleDef.declarations !== undefined) {\n            // Verify that there are no standalone components\n            assertNoStandaloneComponents(moduleDef.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\n            this.queueTypeArray(moduleDef.declarations, TestingModuleOverride.DECLARATION);\n            this.declarations.push(...moduleDef.declarations);\n        }\n        // Enqueue any compilation tasks for imported modules.\n        if (moduleDef.imports !== undefined) {\n            this.queueTypesFromModulesArray(moduleDef.imports);\n            this.imports.push(...moduleDef.imports);\n        }\n        if (moduleDef.providers !== undefined) {\n            this.providers.push(...moduleDef.providers);\n        }\n        if (moduleDef.schemas !== undefined) {\n            this.schemas.push(...moduleDef.schemas);\n        }\n        this.deferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n        this.rethrowApplicationTickErrors =\n            moduleDef.rethrowApplicationErrors ?? RETHROW_APPLICATION_ERRORS_DEFAULT;\n    }\n    overrideModule(ngModule, override) {\n        if (_USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n            _depsTracker.clearScopeCacheFor(ngModule);\n        }\n        this.overriddenModules.add(ngModule);\n        // Compile the module right away.\n        this.resolvers.module.addOverride(ngModule, override);\n        const metadata = this.resolvers.module.resolve(ngModule);\n        if (metadata === null) {\n            throw invalidTypeError(ngModule.name, 'NgModule');\n        }\n        this.recompileNgModule(ngModule, metadata);\n        // At this point, the module has a valid module def (ɵmod), but the override may have introduced\n        // new declarations or imported modules. Ingest any possible new types and add them to the\n        // current queue.\n        this.queueTypesFromModulesArray([ngModule]);\n    }\n    overrideComponent(component, override) {\n        this.verifyNoStandaloneFlagOverrides(component, override);\n        this.resolvers.component.addOverride(component, override);\n        this.pendingComponents.add(component);\n        // If this is a component with async metadata (i.e. a component with a `@defer` block\n        // in a template) - store it for future processing.\n        this.maybeRegisterComponentWithAsyncMetadata(component);\n    }\n    overrideDirective(directive, override) {\n        this.verifyNoStandaloneFlagOverrides(directive, override);\n        this.resolvers.directive.addOverride(directive, override);\n        this.pendingDirectives.add(directive);\n    }\n    overridePipe(pipe, override) {\n        this.verifyNoStandaloneFlagOverrides(pipe, override);\n        this.resolvers.pipe.addOverride(pipe, override);\n        this.pendingPipes.add(pipe);\n    }\n    verifyNoStandaloneFlagOverrides(type, override) {\n        if (override.add?.hasOwnProperty('standalone') ||\n            override.set?.hasOwnProperty('standalone') ||\n            override.remove?.hasOwnProperty('standalone')) {\n            throw new Error(`An override for the ${type.name} class has the \\`standalone\\` flag. ` +\n                `Changing the \\`standalone\\` flag via TestBed overrides is not supported.`);\n        }\n    }\n    overrideProvider(token, provider) {\n        let providerDef;\n        if (provider.useFactory !== undefined) {\n            providerDef = {\n                provide: token,\n                useFactory: provider.useFactory,\n                deps: provider.deps || [],\n                multi: provider.multi,\n            };\n        }\n        else if (provider.useValue !== undefined) {\n            providerDef = { provide: token, useValue: provider.useValue, multi: provider.multi };\n        }\n        else {\n            providerDef = { provide: token };\n        }\n        const injectableDef = typeof token !== 'string' ? _getInjectableDef(token) : null;\n        const providedIn = injectableDef === null ? null : resolveForwardRef(injectableDef.providedIn);\n        const overridesBucket = providedIn === 'root' ? this.rootProviderOverrides : this.providerOverrides;\n        overridesBucket.push(providerDef);\n        // Keep overrides grouped by token as well for fast lookups using token\n        this.providerOverridesByToken.set(token, providerDef);\n        if (injectableDef !== null && providedIn !== null && typeof providedIn !== 'string') {\n            const existingOverrides = this.providerOverridesByModule.get(providedIn);\n            if (existingOverrides !== undefined) {\n                existingOverrides.push(providerDef);\n            }\n            else {\n                this.providerOverridesByModule.set(providedIn, [providerDef]);\n            }\n        }\n    }\n    overrideTemplateUsingTestingModule(type, template) {\n        const def = type[_NG_COMP_DEF];\n        const hasStyleUrls = () => {\n            const metadata = this.resolvers.component.resolve(type);\n            return !!metadata.styleUrl || !!metadata.styleUrls?.length;\n        };\n        const overrideStyleUrls = !!def && !_isComponentDefPendingResolution(type) && hasStyleUrls();\n        // In Ivy, compiling a component does not require knowing the module providing the\n        // component's scope, so overrideTemplateUsingTestingModule can be implemented purely via\n        // overrideComponent. Important: overriding template requires full Component re-compilation,\n        // which may fail in case styleUrls are also present (thus Component is considered as required\n        // resolution). In order to avoid this, we preemptively set styleUrls to an empty array,\n        // preserve current styles available on Component def and restore styles back once compilation\n        // is complete.\n        const override = overrideStyleUrls\n            ? { template, styles: [], styleUrls: [], styleUrl: undefined }\n            : { template };\n        this.overrideComponent(type, { set: override });\n        if (overrideStyleUrls && def.styles && def.styles.length > 0) {\n            this.existingComponentStyles.set(type, def.styles);\n        }\n        // Set the component's scope to be the testing module.\n        this.componentToModuleScope.set(type, TestingModuleOverride.OVERRIDE_TEMPLATE);\n    }\n    async resolvePendingComponentsWithAsyncMetadata() {\n        if (this.componentsWithAsyncMetadata.size === 0)\n            return;\n        const promises = [];\n        for (const component of this.componentsWithAsyncMetadata) {\n            const asyncMetadataFn = _getAsyncClassMetadataFn(component);\n            if (asyncMetadataFn) {\n                promises.push(asyncMetadataFn());\n            }\n        }\n        this.componentsWithAsyncMetadata.clear();\n        const resolvedDeps = await Promise.all(promises);\n        const flatResolvedDeps = resolvedDeps.flat(2);\n        this.queueTypesFromModulesArray(flatResolvedDeps);\n        // Loaded standalone components might contain imports of NgModules\n        // with providers, make sure we override providers there too.\n        for (const component of flatResolvedDeps) {\n            this.applyProviderOverridesInScope(component);\n        }\n    }\n    async compileComponents() {\n        this.clearComponentResolutionQueue();\n        // Wait for all async metadata for components that were\n        // overridden, we need resolved metadata to perform an override\n        // and re-compile a component.\n        await this.resolvePendingComponentsWithAsyncMetadata();\n        // Verify that there were no standalone components present in the `declarations` field\n        // during the `TestBed.configureTestingModule` call. We perform this check here in addition\n        // to the logic in the `configureTestingModule` function, since at this point we have\n        // all async metadata resolved.\n        assertNoStandaloneComponents(this.declarations, this.resolvers.component, '\"TestBed.configureTestingModule\" call');\n        // Run compilers for all queued types.\n        let needsAsyncResources = this.compileTypesSync();\n        // compileComponents() should not be async unless it needs to be.\n        if (needsAsyncResources) {\n            let resourceLoader;\n            let resolver = (url) => {\n                if (!resourceLoader) {\n                    resourceLoader = this.injector.get(ResourceLoader);\n                }\n                return Promise.resolve(resourceLoader.get(url));\n            };\n            await _resolveComponentResources(resolver);\n        }\n    }\n    finalize() {\n        // One last compile\n        this.compileTypesSync();\n        // Create the testing module itself.\n        this.compileTestModule();\n        this.applyTransitiveScopes();\n        this.applyProviderOverrides();\n        // Patch previously stored `styles` Component values (taken from ɵcmp), in case these\n        // Components have `styleUrls` fields defined and template override was requested.\n        this.patchComponentsWithExistingStyles();\n        // Clear the componentToModuleScope map, so that future compilations don't reset the scope of\n        // every component.\n        this.componentToModuleScope.clear();\n        const parentInjector = this.platform.injector;\n        this.testModuleRef = new _Render3NgModuleRef(this.testModuleType, parentInjector, []);\n        // ApplicationInitStatus.runInitializers() is marked @internal to core.\n        // Cast it to any before accessing it.\n        this.testModuleRef.injector.get(ApplicationInitStatus).runInitializers();\n        // Set locale ID after running app initializers, since locale information might be updated while\n        // running initializers. This is also consistent with the execution order while bootstrapping an\n        // app (see `packages/core/src/application_ref.ts` file).\n        const localeId = this.testModuleRef.injector.get(LOCALE_ID, _DEFAULT_LOCALE_ID);\n        _setLocaleId(localeId);\n        return this.testModuleRef;\n    }\n    /**\n     * @internal\n     */\n    _compileNgModuleSync(moduleType) {\n        this.queueTypesFromModulesArray([moduleType]);\n        this.compileTypesSync();\n        this.applyProviderOverrides();\n        this.applyProviderOverridesInScope(moduleType);\n        this.applyTransitiveScopes();\n    }\n    /**\n     * @internal\n     */\n    async _compileNgModuleAsync(moduleType) {\n        this.queueTypesFromModulesArray([moduleType]);\n        await this.compileComponents();\n        this.applyProviderOverrides();\n        this.applyProviderOverridesInScope(moduleType);\n        this.applyTransitiveScopes();\n    }\n    /**\n     * @internal\n     */\n    _getModuleResolver() {\n        return this.resolvers.module;\n    }\n    /**\n     * @internal\n     */\n    _getComponentFactories(moduleType) {\n        return maybeUnwrapFn(moduleType.ɵmod.declarations).reduce((factories, declaration) => {\n            const componentDef = declaration.ɵcmp;\n            componentDef && factories.push(new _Render3ComponentFactory(componentDef, this.testModuleRef));\n            return factories;\n        }, []);\n    }\n    compileTypesSync() {\n        // Compile all queued components, directives, pipes.\n        let needsAsyncResources = false;\n        this.pendingComponents.forEach((declaration) => {\n            if (_getAsyncClassMetadataFn(declaration)) {\n                throw new Error(`Component '${declaration.name}' has unresolved metadata. ` +\n                    `Please call \\`await TestBed.compileComponents()\\` before running this test.`);\n            }\n            needsAsyncResources = needsAsyncResources || _isComponentDefPendingResolution(declaration);\n            const metadata = this.resolvers.component.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Component');\n            }\n            this.maybeStoreNgDef(_NG_COMP_DEF, declaration);\n            if (_USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n                _depsTracker.clearScopeCacheFor(declaration);\n            }\n            _compileComponent(declaration, metadata);\n        });\n        this.pendingComponents.clear();\n        this.pendingDirectives.forEach((declaration) => {\n            const metadata = this.resolvers.directive.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Directive');\n            }\n            this.maybeStoreNgDef(_NG_DIR_DEF, declaration);\n            _compileDirective(declaration, metadata);\n        });\n        this.pendingDirectives.clear();\n        this.pendingPipes.forEach((declaration) => {\n            const metadata = this.resolvers.pipe.resolve(declaration);\n            if (metadata === null) {\n                throw invalidTypeError(declaration.name, 'Pipe');\n            }\n            this.maybeStoreNgDef(_NG_PIPE_DEF, declaration);\n            _compilePipe(declaration, metadata);\n        });\n        this.pendingPipes.clear();\n        return needsAsyncResources;\n    }\n    applyTransitiveScopes() {\n        if (this.overriddenModules.size > 0) {\n            // Module overrides (via `TestBed.overrideModule`) might affect scopes that were previously\n            // calculated and stored in `transitiveCompileScopes`. If module overrides are present,\n            // collect all affected modules and reset scopes to force their re-calculation.\n            const testingModuleDef = this.testModuleType[_NG_MOD_DEF];\n            const affectedModules = this.collectModulesAffectedByOverrides(testingModuleDef.imports);\n            if (affectedModules.size > 0) {\n                affectedModules.forEach((moduleType) => {\n                    if (!_USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n                        this.storeFieldOfDefOnType(moduleType, _NG_MOD_DEF, 'transitiveCompileScopes');\n                        moduleType[_NG_MOD_DEF].transitiveCompileScopes = null;\n                    }\n                    else {\n                        _depsTracker.clearScopeCacheFor(moduleType);\n                    }\n                });\n            }\n        }\n        const moduleToScope = new Map();\n        const getScopeOfModule = (moduleType) => {\n            if (!moduleToScope.has(moduleType)) {\n                const isTestingModule = isTestingModuleOverride(moduleType);\n                const realType = isTestingModule ? this.testModuleType : moduleType;\n                moduleToScope.set(moduleType, _transitiveScopesFor(realType));\n            }\n            return moduleToScope.get(moduleType);\n        };\n        this.componentToModuleScope.forEach((moduleType, componentType) => {\n            if (moduleType !== null) {\n                const moduleScope = getScopeOfModule(moduleType);\n                this.storeFieldOfDefOnType(componentType, _NG_COMP_DEF, 'directiveDefs');\n                this.storeFieldOfDefOnType(componentType, _NG_COMP_DEF, 'pipeDefs');\n                _patchComponentDefWithScope(getComponentDef(componentType), moduleScope);\n            }\n            // `tView` that is stored on component def contains information about directives and pipes\n            // that are in the scope of this component. Patching component scope will cause `tView` to be\n            // changed. Store original `tView` before patching scope, so the `tView` (including scope\n            // information) is restored back to its previous/original state before running next test.\n            // Resetting `tView` is also needed for cases when we apply provider overrides and those\n            // providers are defined on component's level, in which case they may end up included into\n            // `tView.blueprint`.\n            this.storeFieldOfDefOnType(componentType, _NG_COMP_DEF, 'tView');\n        });\n        this.componentToModuleScope.clear();\n    }\n    applyProviderOverrides() {\n        const maybeApplyOverrides = (field) => (type) => {\n            const resolver = field === _NG_COMP_DEF ? this.resolvers.component : this.resolvers.directive;\n            const metadata = resolver.resolve(type);\n            if (this.hasProviderOverrides(metadata.providers)) {\n                this.patchDefWithProviderOverrides(type, field);\n            }\n        };\n        this.seenComponents.forEach(maybeApplyOverrides(_NG_COMP_DEF));\n        this.seenDirectives.forEach(maybeApplyOverrides(_NG_DIR_DEF));\n        this.seenComponents.clear();\n        this.seenDirectives.clear();\n    }\n    /**\n     * Applies provider overrides to a given type (either an NgModule or a standalone component)\n     * and all imported NgModules and standalone components recursively.\n     */\n    applyProviderOverridesInScope(type) {\n        const hasScope = isStandaloneComponent(type) || isNgModule(type);\n        // The function can be re-entered recursively while inspecting dependencies\n        // of an NgModule or a standalone component. Exit early if we come across a\n        // type that can not have a scope (directive or pipe) or the type is already\n        // processed earlier.\n        if (!hasScope || this.scopesWithOverriddenProviders.has(type)) {\n            return;\n        }\n        this.scopesWithOverriddenProviders.add(type);\n        // NOTE: the line below triggers JIT compilation of the module injector,\n        // which also invokes verification of the NgModule semantics, which produces\n        // detailed error messages. The fact that the code relies on this line being\n        // present here is suspicious and should be refactored in a way that the line\n        // below can be moved (for ex. after an early exit check below).\n        const injectorDef = type[_NG_INJ_DEF];\n        // No provider overrides, exit early.\n        if (this.providerOverridesByToken.size === 0)\n            return;\n        if (isStandaloneComponent(type)) {\n            // Visit all component dependencies and override providers there.\n            const def = getComponentDef(type);\n            const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n            for (const dependency of dependencies) {\n                this.applyProviderOverridesInScope(dependency);\n            }\n        }\n        else {\n            const providers = [\n                ...injectorDef.providers,\n                ...(this.providerOverridesByModule.get(type) || []),\n            ];\n            if (this.hasProviderOverrides(providers)) {\n                this.maybeStoreNgDef(_NG_INJ_DEF, type);\n                this.storeFieldOfDefOnType(type, _NG_INJ_DEF, 'providers');\n                injectorDef.providers = this.getOverriddenProviders(providers);\n            }\n            // Apply provider overrides to imported modules recursively\n            const moduleDef = type[_NG_MOD_DEF];\n            const imports = maybeUnwrapFn(moduleDef.imports);\n            for (const importedModule of imports) {\n                this.applyProviderOverridesInScope(importedModule);\n            }\n            // Also override the providers on any ModuleWithProviders imports since those don't appear in\n            // the moduleDef.\n            for (const importedModule of flatten(injectorDef.imports)) {\n                if (isModuleWithProviders(importedModule)) {\n                    this.defCleanupOps.push({\n                        object: importedModule,\n                        fieldName: 'providers',\n                        originalValue: importedModule.providers,\n                    });\n                    importedModule.providers = this.getOverriddenProviders(importedModule.providers);\n                }\n            }\n        }\n    }\n    patchComponentsWithExistingStyles() {\n        this.existingComponentStyles.forEach((styles, type) => (type[_NG_COMP_DEF].styles = styles));\n        this.existingComponentStyles.clear();\n    }\n    queueTypeArray(arr, moduleType) {\n        for (const value of arr) {\n            if (Array.isArray(value)) {\n                this.queueTypeArray(value, moduleType);\n            }\n            else {\n                this.queueType(value, moduleType);\n            }\n        }\n    }\n    recompileNgModule(ngModule, metadata) {\n        // Cache the initial ngModuleDef as it will be overwritten.\n        this.maybeStoreNgDef(_NG_MOD_DEF, ngModule);\n        this.maybeStoreNgDef(_NG_INJ_DEF, ngModule);\n        _compileNgModuleDefs(ngModule, metadata);\n    }\n    maybeRegisterComponentWithAsyncMetadata(type) {\n        const asyncMetadataFn = _getAsyncClassMetadataFn(type);\n        if (asyncMetadataFn) {\n            this.componentsWithAsyncMetadata.add(type);\n        }\n    }\n    queueType(type, moduleType) {\n        // If this is a component with async metadata (i.e. a component with a `@defer` block\n        // in a template) - store it for future processing.\n        this.maybeRegisterComponentWithAsyncMetadata(type);\n        const component = this.resolvers.component.resolve(type);\n        if (component) {\n            // Check whether a give Type has respective NG def (ɵcmp) and compile if def is\n            // missing. That might happen in case a class without any Angular decorators extends another\n            // class where Component/Directive/Pipe decorator is defined.\n            if (_isComponentDefPendingResolution(type) || !type.hasOwnProperty(_NG_COMP_DEF)) {\n                this.pendingComponents.add(type);\n            }\n            this.seenComponents.add(type);\n            // Keep track of the module which declares this component, so later the component's scope\n            // can be set correctly. If the component has already been recorded here, then one of several\n            // cases is true:\n            // * the module containing the component was imported multiple times (common).\n            // * the component is declared in multiple modules (which is an error).\n            // * the component was in 'declarations' of the testing module, and also in an imported module\n            //   in which case the module scope will be TestingModuleOverride.DECLARATION.\n            // * overrideTemplateUsingTestingModule was called for the component in which case the module\n            //   scope will be TestingModuleOverride.OVERRIDE_TEMPLATE.\n            //\n            // If the component was previously in the testing module's 'declarations' (meaning the\n            // current value is TestingModuleOverride.DECLARATION), then `moduleType` is the component's\n            // real module, which was imported. This pattern is understood to mean that the component\n            // should use its original scope, but that the testing module should also contain the\n            // component in its scope.\n            if (!this.componentToModuleScope.has(type) ||\n                this.componentToModuleScope.get(type) === TestingModuleOverride.DECLARATION) {\n                this.componentToModuleScope.set(type, moduleType);\n            }\n            return;\n        }\n        const directive = this.resolvers.directive.resolve(type);\n        if (directive) {\n            if (!type.hasOwnProperty(_NG_DIR_DEF)) {\n                this.pendingDirectives.add(type);\n            }\n            this.seenDirectives.add(type);\n            return;\n        }\n        const pipe = this.resolvers.pipe.resolve(type);\n        if (pipe && !type.hasOwnProperty(_NG_PIPE_DEF)) {\n            this.pendingPipes.add(type);\n            return;\n        }\n    }\n    queueTypesFromModulesArray(arr) {\n        // Because we may encounter the same NgModule or a standalone Component while processing\n        // the dependencies of an NgModule or a standalone Component, we cache them in this set so we\n        // can skip ones that have already been seen encountered. In some test setups, this caching\n        // resulted in 10X runtime improvement.\n        const processedDefs = new Set();\n        const queueTypesFromModulesArrayRecur = (arr) => {\n            for (const value of arr) {\n                if (Array.isArray(value)) {\n                    queueTypesFromModulesArrayRecur(value);\n                }\n                else if (hasNgModuleDef(value)) {\n                    const def = value.ɵmod;\n                    if (processedDefs.has(def)) {\n                        continue;\n                    }\n                    processedDefs.add(def);\n                    // Look through declarations, imports, and exports, and queue\n                    // everything found there.\n                    this.queueTypeArray(maybeUnwrapFn(def.declarations), value);\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.imports));\n                    queueTypesFromModulesArrayRecur(maybeUnwrapFn(def.exports));\n                }\n                else if (isModuleWithProviders(value)) {\n                    queueTypesFromModulesArrayRecur([value.ngModule]);\n                }\n                else if (isStandaloneComponent(value)) {\n                    this.queueType(value, null);\n                    const def = getComponentDef(value);\n                    if (processedDefs.has(def)) {\n                        continue;\n                    }\n                    processedDefs.add(def);\n                    const dependencies = maybeUnwrapFn(def.dependencies ?? []);\n                    dependencies.forEach((dependency) => {\n                        // Note: in AOT, the `dependencies` might also contain regular\n                        // (NgModule-based) Component, Directive and Pipes, so we handle\n                        // them separately and proceed with recursive process for standalone\n                        // Components and NgModules only.\n                        if (isStandaloneComponent(dependency) || hasNgModuleDef(dependency)) {\n                            queueTypesFromModulesArrayRecur([dependency]);\n                        }\n                        else {\n                            this.queueType(dependency, null);\n                        }\n                    });\n                }\n            }\n        };\n        queueTypesFromModulesArrayRecur(arr);\n    }\n    // When module overrides (via `TestBed.overrideModule`) are present, it might affect all modules\n    // that import (even transitively) an overridden one. For all affected modules we need to\n    // recalculate their scopes for a given test run and restore original scopes at the end. The goal\n    // of this function is to collect all affected modules in a set for further processing. Example:\n    // if we have the following module hierarchy: A -> B -> C (where `->` means `imports`) and module\n    // `C` is overridden, we consider `A` and `B` as affected, since their scopes might become\n    // invalidated with the override.\n    collectModulesAffectedByOverrides(arr) {\n        const seenModules = new Set();\n        const affectedModules = new Set();\n        const calcAffectedModulesRecur = (arr, path) => {\n            for (const value of arr) {\n                if (Array.isArray(value)) {\n                    // If the value is an array, just flatten it (by invoking this function recursively),\n                    // keeping \"path\" the same.\n                    calcAffectedModulesRecur(value, path);\n                }\n                else if (hasNgModuleDef(value)) {\n                    if (seenModules.has(value)) {\n                        // If we've seen this module before and it's included into \"affected modules\" list, mark\n                        // the whole path that leads to that module as affected, but do not descend into its\n                        // imports, since we already examined them before.\n                        if (affectedModules.has(value)) {\n                            path.forEach((item) => affectedModules.add(item));\n                        }\n                        continue;\n                    }\n                    seenModules.add(value);\n                    if (this.overriddenModules.has(value)) {\n                        path.forEach((item) => affectedModules.add(item));\n                    }\n                    // Examine module imports recursively to look for overridden modules.\n                    const moduleDef = value[_NG_MOD_DEF];\n                    calcAffectedModulesRecur(maybeUnwrapFn(moduleDef.imports), path.concat(value));\n                }\n            }\n        };\n        calcAffectedModulesRecur(arr, []);\n        return affectedModules;\n    }\n    /**\n     * Preserve an original def (such as ɵmod, ɵinj, etc) before applying an override.\n     * Note: one class may have multiple defs (for example: ɵmod and ɵinj in case of\n     * an NgModule). If there is a def in a set already, don't override it, since\n     * an original one should be restored at the end of a test.\n     */\n    maybeStoreNgDef(prop, type) {\n        if (!this.initialNgDefs.has(type)) {\n            this.initialNgDefs.set(type, new Map());\n        }\n        const currentDefs = this.initialNgDefs.get(type);\n        if (!currentDefs.has(prop)) {\n            const currentDef = Object.getOwnPropertyDescriptor(type, prop);\n            currentDefs.set(prop, currentDef);\n        }\n    }\n    storeFieldOfDefOnType(type, defField, fieldName) {\n        const def = type[defField];\n        const originalValue = def[fieldName];\n        this.defCleanupOps.push({ object: def, fieldName, originalValue });\n    }\n    /**\n     * Clears current components resolution queue, but stores the state of the queue, so we can\n     * restore it later. Clearing the queue is required before we try to compile components (via\n     * `TestBed.compileComponents`), so that component defs are in sync with the resolution queue.\n     */\n    clearComponentResolutionQueue() {\n        if (this.originalComponentResolutionQueue === null) {\n            this.originalComponentResolutionQueue = new Map();\n        }\n        _clearResolutionOfComponentResourcesQueue().forEach((value, key) => this.originalComponentResolutionQueue.set(key, value));\n    }\n    /*\n     * Restores component resolution queue to the previously saved state. This operation is performed\n     * as a part of restoring the state after completion of the current set of tests (that might\n     * potentially mutate the state).\n     */\n    restoreComponentResolutionQueue() {\n        if (this.originalComponentResolutionQueue !== null) {\n            _restoreComponentResolutionQueue(this.originalComponentResolutionQueue);\n            this.originalComponentResolutionQueue = null;\n        }\n    }\n    restoreOriginalState() {\n        // Process cleanup ops in reverse order so the field's original value is restored correctly (in\n        // case there were multiple overrides for the same field).\n        forEachRight(this.defCleanupOps, (op) => {\n            op.object[op.fieldName] = op.originalValue;\n        });\n        // Restore initial component/directive/pipe defs\n        this.initialNgDefs.forEach((defs, type) => {\n            if (_USE_RUNTIME_DEPS_TRACKER_FOR_JIT) {\n                _depsTracker.clearScopeCacheFor(type);\n            }\n            defs.forEach((descriptor, prop) => {\n                if (!descriptor) {\n                    // Delete operations are generally undesirable since they have performance\n                    // implications on objects they were applied to. In this particular case, situations\n                    // where this code is invoked should be quite rare to cause any noticeable impact,\n                    // since it's applied only to some test cases (for example when class with no\n                    // annotations extends some @Component) when we need to clear 'ɵcmp' field on a given\n                    // class to restore its original state (before applying overrides and running tests).\n                    delete type[prop];\n                }\n                else {\n                    Object.defineProperty(type, prop, descriptor);\n                }\n            });\n        });\n        this.initialNgDefs.clear();\n        this.scopesWithOverriddenProviders.clear();\n        this.restoreComponentResolutionQueue();\n        // Restore the locale ID to the default value, this shouldn't be necessary but we never know\n        _setLocaleId(_DEFAULT_LOCALE_ID);\n    }\n    compileTestModule() {\n        class RootScopeModule {\n        }\n        _compileNgModuleDefs(RootScopeModule, {\n            providers: [\n                ...this.rootProviderOverrides,\n                _internalProvideZoneChangeDetection({}),\n                TestBedApplicationErrorHandler,\n                { provide: _ChangeDetectionScheduler, useExisting: _ChangeDetectionSchedulerImpl },\n            ],\n        });\n        const providers = [\n            { provide: Compiler, useFactory: () => new R3TestCompiler(this) },\n            { provide: _DEFER_BLOCK_CONFIG, useValue: { behavior: this.deferBlockBehavior } },\n            {\n                provide: _INTERNAL_APPLICATION_ERROR_HANDLER,\n                useFactory: () => {\n                    if (this.rethrowApplicationTickErrors) {\n                        const handler = inject$1(TestBedApplicationErrorHandler);\n                        return (e) => {\n                            handler.handleError(e);\n                        };\n                    }\n                    else {\n                        const userErrorHandler = inject$1(ErrorHandler);\n                        const ngZone = inject$1(NgZone);\n                        return (e) => ngZone.runOutsideAngular(() => userErrorHandler.handleError(e));\n                    }\n                },\n            },\n            ...this.providers,\n            ...this.providerOverrides,\n        ];\n        const imports = [RootScopeModule, this.additionalModuleTypes, this.imports || []];\n        _compileNgModuleDefs(this.testModuleType, {\n            declarations: this.declarations,\n            imports,\n            schemas: this.schemas,\n            providers,\n        }, \n        /* allowDuplicateDeclarationsInRoot */ true);\n        this.applyProviderOverridesInScope(this.testModuleType);\n    }\n    get injector() {\n        if (this._injector !== null) {\n            return this._injector;\n        }\n        const providers = [];\n        const compilerOptions = this.platform.injector.get(COMPILER_OPTIONS, []);\n        compilerOptions.forEach((opts) => {\n            if (opts.providers) {\n                providers.push(opts.providers);\n            }\n        });\n        if (this.compilerProviders !== null) {\n            providers.push(...this.compilerProviders);\n        }\n        this._injector = Injector.create({ providers, parent: this.platform.injector });\n        return this._injector;\n    }\n    // get overrides for a specific provider (if any)\n    getSingleProviderOverrides(provider) {\n        const token = getProviderToken(provider);\n        return this.providerOverridesByToken.get(token) || null;\n    }\n    getProviderOverrides(providers) {\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\n            return [];\n        // There are two flattening operations here. The inner flattenProviders() operates on the\n        // metadata's providers and applies a mapping function which retrieves overrides for each\n        // incoming provider. The outer flatten() then flattens the produced overrides array. If this is\n        // not done, the array can contain other empty arrays (e.g. `[[], []]`) which leak into the\n        // providers array and contaminate any error messages that might be generated.\n        return flatten(flattenProviders(providers, (provider) => this.getSingleProviderOverrides(provider) || []));\n    }\n    getOverriddenProviders(providers) {\n        if (!providers || !providers.length || this.providerOverridesByToken.size === 0)\n            return [];\n        const flattenedProviders = flattenProviders(providers);\n        const overrides = this.getProviderOverrides(flattenedProviders);\n        const overriddenProviders = [...flattenedProviders, ...overrides];\n        const final = [];\n        const seenOverriddenProviders = new Set();\n        // We iterate through the list of providers in reverse order to make sure provider overrides\n        // take precedence over the values defined in provider list. We also filter out all providers\n        // that have overrides, keeping overridden values only. This is needed, since presence of a\n        // provider with `ngOnDestroy` hook will cause this hook to be registered and invoked later.\n        forEachRight(overriddenProviders, (provider) => {\n            const token = getProviderToken(provider);\n            if (this.providerOverridesByToken.has(token)) {\n                if (!seenOverriddenProviders.has(token)) {\n                    seenOverriddenProviders.add(token);\n                    // Treat all overridden providers as `{multi: false}` (even if it's a multi-provider) to\n                    // make sure that provided override takes highest precedence and is not combined with\n                    // other instances of the same multi provider.\n                    final.unshift({ ...provider, multi: false });\n                }\n            }\n            else {\n                final.unshift(provider);\n            }\n        });\n        return final;\n    }\n    hasProviderOverrides(providers) {\n        return this.getProviderOverrides(providers).length > 0;\n    }\n    patchDefWithProviderOverrides(declaration, field) {\n        const def = declaration[field];\n        if (def && def.providersResolver) {\n            this.maybeStoreNgDef(field, declaration);\n            const resolver = def.providersResolver;\n            const processProvidersFn = (providers) => this.getOverriddenProviders(providers);\n            this.storeFieldOfDefOnType(declaration, field, 'providersResolver');\n            def.providersResolver = (ngDef) => resolver(ngDef, processProvidersFn);\n        }\n    }\n}\nfunction initResolvers() {\n    return {\n        module: new NgModuleResolver(),\n        component: new ComponentResolver(),\n        directive: new DirectiveResolver(),\n        pipe: new PipeResolver(),\n    };\n}\nfunction isStandaloneComponent(value) {\n    const def = getComponentDef(value);\n    return !!def?.standalone;\n}\nfunction getComponentDef(value) {\n    return value.ɵcmp ?? null;\n}\nfunction hasNgModuleDef(value) {\n    return value.hasOwnProperty('ɵmod');\n}\nfunction isNgModule(value) {\n    return hasNgModuleDef(value);\n}\nfunction maybeUnwrapFn(maybeFn) {\n    return maybeFn instanceof Function ? maybeFn() : maybeFn;\n}\nfunction flatten(values) {\n    const out = [];\n    values.forEach((value) => {\n        if (Array.isArray(value)) {\n            out.push(...flatten(value));\n        }\n        else {\n            out.push(value);\n        }\n    });\n    return out;\n}\nfunction identityFn(value) {\n    return value;\n}\nfunction flattenProviders(providers, mapFn = identityFn) {\n    const out = [];\n    for (let provider of providers) {\n        if (_isEnvironmentProviders(provider)) {\n            provider = provider.ɵproviders;\n        }\n        if (Array.isArray(provider)) {\n            out.push(...flattenProviders(provider, mapFn));\n        }\n        else {\n            out.push(mapFn(provider));\n        }\n    }\n    return out;\n}\nfunction getProviderField(provider, field) {\n    return provider && typeof provider === 'object' && provider[field];\n}\nfunction getProviderToken(provider) {\n    return getProviderField(provider, 'provide') || provider;\n}\nfunction isModuleWithProviders(value) {\n    return value.hasOwnProperty('ngModule');\n}\nfunction forEachRight(values, fn) {\n    for (let idx = values.length - 1; idx >= 0; idx--) {\n        fn(values[idx], idx);\n    }\n}\nfunction invalidTypeError(name, expectedType) {\n    return new Error(`${name} class doesn't have @${expectedType} decorator or is missing metadata.`);\n}\nclass R3TestCompiler {\n    testBed;\n    constructor(testBed) {\n        this.testBed = testBed;\n    }\n    compileModuleSync(moduleType) {\n        this.testBed._compileNgModuleSync(moduleType);\n        return new _NgModuleFactory(moduleType);\n    }\n    async compileModuleAsync(moduleType) {\n        await this.testBed._compileNgModuleAsync(moduleType);\n        return new _NgModuleFactory(moduleType);\n    }\n    compileModuleAndAllComponentsSync(moduleType) {\n        const ngModuleFactory = this.compileModuleSync(moduleType);\n        const componentFactories = this.testBed._getComponentFactories(moduleType);\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    }\n    async compileModuleAndAllComponentsAsync(moduleType) {\n        const ngModuleFactory = await this.compileModuleAsync(moduleType);\n        const componentFactories = this.testBed._getComponentFactories(moduleType);\n        return new ModuleWithComponentFactories(ngModuleFactory, componentFactories);\n    }\n    clearCache() { }\n    clearCacheFor(type) { }\n    getModuleId(moduleType) {\n        const meta = this.testBed._getModuleResolver().resolve(moduleType);\n        return (meta && meta.id) || undefined;\n    }\n}\n\n// The formatter and CI disagree on how this import statement should be formatted. Both try to keep\n// it on one line, too, which has gotten very hard to read & manage. So disable the formatter for\n// this statement only.\nlet _nextRootElementId = 0;\n/**\n * Returns a singleton of the `TestBed` class.\n *\n * @publicApi\n */\nfunction getTestBed() {\n    return TestBedImpl.INSTANCE;\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * TestBed is the primary api for writing unit tests for Angular applications and libraries.\n */\nclass TestBedImpl {\n    static _INSTANCE = null;\n    static get INSTANCE() {\n        return (TestBedImpl._INSTANCE = TestBedImpl._INSTANCE || new TestBedImpl());\n    }\n    /**\n     * Teardown options that have been configured at the environment level.\n     * Used as a fallback if no instance-level options have been provided.\n     */\n    static _environmentTeardownOptions;\n    /**\n     * \"Error on unknown elements\" option that has been configured at the environment level.\n     * Used as a fallback if no instance-level option has been provided.\n     */\n    static _environmentErrorOnUnknownElementsOption;\n    /**\n     * \"Error on unknown properties\" option that has been configured at the environment level.\n     * Used as a fallback if no instance-level option has been provided.\n     */\n    static _environmentErrorOnUnknownPropertiesOption;\n    /**\n     * Teardown options that have been configured at the `TestBed` instance level.\n     * These options take precedence over the environment-level ones.\n     */\n    _instanceTeardownOptions;\n    /**\n     * Defer block behavior option that specifies whether defer blocks will be triggered manually\n     * or set to play through.\n     */\n    _instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n    /**\n     * \"Error on unknown elements\" option that has been configured at the `TestBed` instance level.\n     * This option takes precedence over the environment-level one.\n     */\n    _instanceErrorOnUnknownElementsOption;\n    /**\n     * \"Error on unknown properties\" option that has been configured at the `TestBed` instance level.\n     * This option takes precedence over the environment-level one.\n     */\n    _instanceErrorOnUnknownPropertiesOption;\n    /**\n     * Stores the previous \"Error on unknown elements\" option value,\n     * allowing to restore it in the reset testing module logic.\n     */\n    _previousErrorOnUnknownElementsOption;\n    /**\n     * Stores the previous \"Error on unknown properties\" option value,\n     * allowing to restore it in the reset testing module logic.\n     */\n    _previousErrorOnUnknownPropertiesOption;\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    static initTestEnvironment(ngModule, platform, options) {\n        const testBed = TestBedImpl.INSTANCE;\n        testBed.initTestEnvironment(ngModule, platform, options);\n        return testBed;\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    static resetTestEnvironment() {\n        TestBedImpl.INSTANCE.resetTestEnvironment();\n    }\n    static configureCompiler(config) {\n        return TestBedImpl.INSTANCE.configureCompiler(config);\n    }\n    /**\n     * Allows overriding default providers, directives, pipes, modules of the test injector,\n     * which are defined in test_injector.js\n     */\n    static configureTestingModule(moduleDef) {\n        return TestBedImpl.INSTANCE.configureTestingModule(moduleDef);\n    }\n    /**\n     * Compile components with a `templateUrl` for the test's NgModule.\n     * It is necessary to call this function\n     * as fetching urls is asynchronous.\n     */\n    static compileComponents() {\n        return TestBedImpl.INSTANCE.compileComponents();\n    }\n    static overrideModule(ngModule, override) {\n        return TestBedImpl.INSTANCE.overrideModule(ngModule, override);\n    }\n    static overrideComponent(component, override) {\n        return TestBedImpl.INSTANCE.overrideComponent(component, override);\n    }\n    static overrideDirective(directive, override) {\n        return TestBedImpl.INSTANCE.overrideDirective(directive, override);\n    }\n    static overridePipe(pipe, override) {\n        return TestBedImpl.INSTANCE.overridePipe(pipe, override);\n    }\n    static overrideTemplate(component, template) {\n        return TestBedImpl.INSTANCE.overrideTemplate(component, template);\n    }\n    /**\n     * Overrides the template of the given component, compiling the template\n     * in the context of the TestingModule.\n     *\n     * Note: This works for JIT and AOTed components as well.\n     */\n    static overrideTemplateUsingTestingModule(component, template) {\n        return TestBedImpl.INSTANCE.overrideTemplateUsingTestingModule(component, template);\n    }\n    static overrideProvider(token, provider) {\n        return TestBedImpl.INSTANCE.overrideProvider(token, provider);\n    }\n    static inject(token, notFoundValue, flags) {\n        return TestBedImpl.INSTANCE.inject(token, notFoundValue, _convertToBitFlags(flags));\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    static get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        return TestBedImpl.INSTANCE.inject(token, notFoundValue, flags);\n    }\n    /**\n     * Runs the given function in the `EnvironmentInjector` context of `TestBed`.\n     *\n     * @see {@link EnvironmentInjector#runInContext}\n     */\n    static runInInjectionContext(fn) {\n        return TestBedImpl.INSTANCE.runInInjectionContext(fn);\n    }\n    static createComponent(component) {\n        return TestBedImpl.INSTANCE.createComponent(component);\n    }\n    static resetTestingModule() {\n        return TestBedImpl.INSTANCE.resetTestingModule();\n    }\n    static execute(tokens, fn, context) {\n        return TestBedImpl.INSTANCE.execute(tokens, fn, context);\n    }\n    static get platform() {\n        return TestBedImpl.INSTANCE.platform;\n    }\n    static get ngModule() {\n        return TestBedImpl.INSTANCE.ngModule;\n    }\n    static flushEffects() {\n        return TestBedImpl.INSTANCE.flushEffects();\n    }\n    // Properties\n    platform = null;\n    ngModule = null;\n    _compiler = null;\n    _testModuleRef = null;\n    _activeFixtures = [];\n    /**\n     * Internal-only flag to indicate whether a module\n     * scoping queue has been checked and flushed already.\n     * @nodoc\n     */\n    globalCompilationChecked = false;\n    /**\n     * Initialize the environment for testing with a compiler factory, a PlatformRef, and an\n     * angular module. These are common to every test in the suite.\n     *\n     * This may only be called once, to set up the common providers for the current test\n     * suite on the current platform. If you absolutely need to change the providers,\n     * first use `resetTestEnvironment`.\n     *\n     * Test modules and platforms for individual platforms are available from\n     * '@angular/<platform_name>/testing'.\n     *\n     * @publicApi\n     */\n    initTestEnvironment(ngModule, platform, options) {\n        if (this.platform || this.ngModule) {\n            throw new Error('Cannot set base providers because it has already been called');\n        }\n        TestBedImpl._environmentTeardownOptions = options?.teardown;\n        TestBedImpl._environmentErrorOnUnknownElementsOption = options?.errorOnUnknownElements;\n        TestBedImpl._environmentErrorOnUnknownPropertiesOption = options?.errorOnUnknownProperties;\n        this.platform = platform;\n        this.ngModule = ngModule;\n        this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n        // TestBed does not have an API which can reliably detect the start of a test, and thus could be\n        // used to track the state of the NgModule registry and reset it correctly. Instead, when we\n        // know we're in a testing scenario, we disable the check for duplicate NgModule registration\n        // completely.\n        _setAllowDuplicateNgModuleIdsForTest(true);\n    }\n    /**\n     * Reset the providers for the test injector.\n     *\n     * @publicApi\n     */\n    resetTestEnvironment() {\n        this.resetTestingModule();\n        this._compiler = null;\n        this.platform = null;\n        this.ngModule = null;\n        TestBedImpl._environmentTeardownOptions = undefined;\n        _setAllowDuplicateNgModuleIdsForTest(false);\n    }\n    resetTestingModule() {\n        this.checkGlobalCompilationFinished();\n        _resetCompiledComponents();\n        if (this._compiler !== null) {\n            this.compiler.restoreOriginalState();\n        }\n        this._compiler = new TestBedCompiler(this.platform, this.ngModule);\n        // Restore the previous value of the \"error on unknown elements\" option\n        _setUnknownElementStrictMode(this._previousErrorOnUnknownElementsOption ?? THROW_ON_UNKNOWN_ELEMENTS_DEFAULT);\n        // Restore the previous value of the \"error on unknown properties\" option\n        _setUnknownPropertyStrictMode(this._previousErrorOnUnknownPropertiesOption ?? THROW_ON_UNKNOWN_PROPERTIES_DEFAULT);\n        // We have to chain a couple of try/finally blocks, because each step can\n        // throw errors and we don't want it to interrupt the next step and we also\n        // want an error to be thrown at the end.\n        try {\n            this.destroyActiveFixtures();\n        }\n        finally {\n            try {\n                if (this.shouldTearDownTestingModule()) {\n                    this.tearDownTestingModule();\n                }\n            }\n            finally {\n                this._testModuleRef = null;\n                this._instanceTeardownOptions = undefined;\n                this._instanceErrorOnUnknownElementsOption = undefined;\n                this._instanceErrorOnUnknownPropertiesOption = undefined;\n                this._instanceDeferBlockBehavior = DEFER_BLOCK_DEFAULT_BEHAVIOR;\n            }\n        }\n        return this;\n    }\n    configureCompiler(config) {\n        if (config.useJit != null) {\n            throw new Error('JIT compiler is not configurable via TestBed APIs.');\n        }\n        if (config.providers !== undefined) {\n            this.compiler.setCompilerProviders(config.providers);\n        }\n        return this;\n    }\n    configureTestingModule(moduleDef) {\n        this.assertNotInstantiated('TestBed.configureTestingModule', 'configure the test module');\n        // Trigger module scoping queue flush before executing other TestBed operations in a test.\n        // This is needed for the first test invocation to ensure that globally declared modules have\n        // their components scoped properly. See the `checkGlobalCompilationFinished` function\n        // description for additional info.\n        this.checkGlobalCompilationFinished();\n        // Always re-assign the options, even if they're undefined.\n        // This ensures that we don't carry them between tests.\n        this._instanceTeardownOptions = moduleDef.teardown;\n        this._instanceErrorOnUnknownElementsOption = moduleDef.errorOnUnknownElements;\n        this._instanceErrorOnUnknownPropertiesOption = moduleDef.errorOnUnknownProperties;\n        this._instanceDeferBlockBehavior = moduleDef.deferBlockBehavior ?? DEFER_BLOCK_DEFAULT_BEHAVIOR;\n        // Store the current value of the strict mode option,\n        // so we can restore it later\n        this._previousErrorOnUnknownElementsOption = _getUnknownElementStrictMode();\n        _setUnknownElementStrictMode(this.shouldThrowErrorOnUnknownElements());\n        this._previousErrorOnUnknownPropertiesOption = _getUnknownPropertyStrictMode();\n        _setUnknownPropertyStrictMode(this.shouldThrowErrorOnUnknownProperties());\n        this.compiler.configureTestingModule(moduleDef);\n        return this;\n    }\n    compileComponents() {\n        return this.compiler.compileComponents();\n    }\n    inject(token, notFoundValue, flags) {\n        if (token === TestBed) {\n            return this;\n        }\n        const UNDEFINED = {};\n        const result = this.testModuleRef.injector.get(token, UNDEFINED, _convertToBitFlags(flags));\n        return result === UNDEFINED\n            ? this.compiler.injector.get(token, notFoundValue, flags)\n            : result;\n    }\n    /** @deprecated from v9.0.0 use TestBed.inject */\n    get(token, notFoundValue = Injector.THROW_IF_NOT_FOUND, flags = InjectFlags.Default) {\n        return this.inject(token, notFoundValue, flags);\n    }\n    runInInjectionContext(fn) {\n        return runInInjectionContext(this.inject(EnvironmentInjector), fn);\n    }\n    execute(tokens, fn, context) {\n        const params = tokens.map((t) => this.inject(t));\n        return fn.apply(context, params);\n    }\n    overrideModule(ngModule, override) {\n        this.assertNotInstantiated('overrideModule', 'override module metadata');\n        this.compiler.overrideModule(ngModule, override);\n        return this;\n    }\n    overrideComponent(component, override) {\n        this.assertNotInstantiated('overrideComponent', 'override component metadata');\n        this.compiler.overrideComponent(component, override);\n        return this;\n    }\n    overrideTemplateUsingTestingModule(component, template) {\n        this.assertNotInstantiated('TestBed.overrideTemplateUsingTestingModule', 'Cannot override template when the test module has already been instantiated');\n        this.compiler.overrideTemplateUsingTestingModule(component, template);\n        return this;\n    }\n    overrideDirective(directive, override) {\n        this.assertNotInstantiated('overrideDirective', 'override directive metadata');\n        this.compiler.overrideDirective(directive, override);\n        return this;\n    }\n    overridePipe(pipe, override) {\n        this.assertNotInstantiated('overridePipe', 'override pipe metadata');\n        this.compiler.overridePipe(pipe, override);\n        return this;\n    }\n    /**\n     * Overwrites all providers for the given token with the given provider definition.\n     */\n    overrideProvider(token, provider) {\n        this.assertNotInstantiated('overrideProvider', 'override provider');\n        this.compiler.overrideProvider(token, provider);\n        return this;\n    }\n    overrideTemplate(component, template) {\n        return this.overrideComponent(component, { set: { template, templateUrl: null } });\n    }\n    createComponent(type) {\n        const testComponentRenderer = this.inject(TestComponentRenderer);\n        const rootElId = `root${_nextRootElementId++}`;\n        testComponentRenderer.insertRootElement(rootElId);\n        if (_getAsyncClassMetadataFn(type)) {\n            throw new Error(`Component '${type.name}' has unresolved metadata. ` +\n                `Please call \\`await TestBed.compileComponents()\\` before running this test.`);\n        }\n        const componentDef = type.ɵcmp;\n        if (!componentDef) {\n            throw new Error(`It looks like '${_stringify(type)}' has not been compiled.`);\n        }\n        const componentFactory = new _Render3ComponentFactory(componentDef);\n        const initComponent = () => {\n            const componentRef = componentFactory.create(Injector.NULL, [], `#${rootElId}`, this.testModuleRef);\n            return this.runInInjectionContext(() => new ComponentFixture(componentRef));\n        };\n        const noNgZone = this.inject(ComponentFixtureNoNgZone, false);\n        const ngZone = noNgZone ? null : this.inject(NgZone, null);\n        const fixture = ngZone ? ngZone.run(initComponent) : initComponent();\n        this._activeFixtures.push(fixture);\n        return fixture;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get compiler() {\n        if (this._compiler === null) {\n            throw new Error(`Need to call TestBed.initTestEnvironment() first`);\n        }\n        return this._compiler;\n    }\n    /**\n     * @internal strip this from published d.ts files due to\n     * https://github.com/microsoft/TypeScript/issues/36216\n     */\n    get testModuleRef() {\n        if (this._testModuleRef === null) {\n            this._testModuleRef = this.compiler.finalize();\n        }\n        return this._testModuleRef;\n    }\n    assertNotInstantiated(methodName, methodDescription) {\n        if (this._testModuleRef !== null) {\n            throw new Error(`Cannot ${methodDescription} when the test module has already been instantiated. ` +\n                `Make sure you are not using \\`inject\\` before \\`${methodName}\\`.`);\n        }\n    }\n    /**\n     * Check whether the module scoping queue should be flushed, and flush it if needed.\n     *\n     * When the TestBed is reset, it clears the JIT module compilation queue, cancelling any\n     * in-progress module compilation. This creates a potential hazard - the very first time the\n     * TestBed is initialized (or if it's reset without being initialized), there may be pending\n     * compilations of modules declared in global scope. These compilations should be finished.\n     *\n     * To ensure that globally declared modules have their components scoped properly, this function\n     * is called whenever TestBed is initialized or reset. The _first_ time that this happens, prior\n     * to any other operations, the scoping queue is flushed.\n     */\n    checkGlobalCompilationFinished() {\n        // Checking _testNgModuleRef is null should not be necessary, but is left in as an additional\n        // guard that compilations queued in tests (after instantiation) are never flushed accidentally.\n        if (!this.globalCompilationChecked && this._testModuleRef === null) {\n            _flushModuleScopingQueueAsMuchAsPossible();\n        }\n        this.globalCompilationChecked = true;\n    }\n    destroyActiveFixtures() {\n        let errorCount = 0;\n        this._activeFixtures.forEach((fixture) => {\n            try {\n                fixture.destroy();\n            }\n            catch (e) {\n                errorCount++;\n                console.error('Error during cleanup of component', {\n                    component: fixture.componentInstance,\n                    stacktrace: e,\n                });\n            }\n        });\n        this._activeFixtures = [];\n        if (errorCount > 0 && this.shouldRethrowTeardownErrors()) {\n            throw Error(`${errorCount} ${errorCount === 1 ? 'component' : 'components'} ` +\n                `threw errors during cleanup`);\n        }\n    }\n    shouldRethrowTeardownErrors() {\n        const instanceOptions = this._instanceTeardownOptions;\n        const environmentOptions = TestBedImpl._environmentTeardownOptions;\n        // If the new teardown behavior hasn't been configured, preserve the old behavior.\n        if (!instanceOptions && !environmentOptions) {\n            return TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT;\n        }\n        // Otherwise use the configured behavior or default to rethrowing.\n        return (instanceOptions?.rethrowErrors ??\n            environmentOptions?.rethrowErrors ??\n            this.shouldTearDownTestingModule());\n    }\n    shouldThrowErrorOnUnknownElements() {\n        // Check if a configuration has been provided to throw when an unknown element is found\n        return (this._instanceErrorOnUnknownElementsOption ??\n            TestBedImpl._environmentErrorOnUnknownElementsOption ??\n            THROW_ON_UNKNOWN_ELEMENTS_DEFAULT);\n    }\n    shouldThrowErrorOnUnknownProperties() {\n        // Check if a configuration has been provided to throw when an unknown property is found\n        return (this._instanceErrorOnUnknownPropertiesOption ??\n            TestBedImpl._environmentErrorOnUnknownPropertiesOption ??\n            THROW_ON_UNKNOWN_PROPERTIES_DEFAULT);\n    }\n    shouldTearDownTestingModule() {\n        return (this._instanceTeardownOptions?.destroyAfterEach ??\n            TestBedImpl._environmentTeardownOptions?.destroyAfterEach ??\n            TEARDOWN_TESTING_MODULE_ON_DESTROY_DEFAULT);\n    }\n    getDeferBlockBehavior() {\n        return this._instanceDeferBlockBehavior;\n    }\n    tearDownTestingModule() {\n        // If the module ref has already been destroyed, we won't be able to get a test renderer.\n        if (this._testModuleRef === null) {\n            return;\n        }\n        // Resolve the renderer ahead of time, because we want to remove the root elements as the very\n        // last step, but the injector will be destroyed as a part of the module ref destruction.\n        const testRenderer = this.inject(TestComponentRenderer);\n        try {\n            this._testModuleRef.destroy();\n        }\n        catch (e) {\n            if (this.shouldRethrowTeardownErrors()) {\n                throw e;\n            }\n            else {\n                console.error('Error during cleanup of a testing module', {\n                    component: this._testModuleRef.instance,\n                    stacktrace: e,\n                });\n            }\n        }\n        finally {\n            testRenderer.removeAllRootElements?.();\n        }\n    }\n    /**\n     * Execute any pending effects.\n     *\n     * @developerPreview\n     */\n    flushEffects() {\n        this.inject(_MicrotaskEffectScheduler).flush();\n        this.inject(_EffectScheduler).flush();\n    }\n}\n/**\n * @description\n * Configures and initializes environment for unit testing and provides methods for\n * creating components and services in unit tests.\n *\n * `TestBed` is the primary api for writing unit tests for Angular applications and libraries.\n *\n * @publicApi\n */\nconst TestBed = TestBedImpl;\n/**\n * Allows injecting dependencies in `beforeEach()` and `it()`. Note: this function\n * (imported from the `@angular/core/testing` package) can **only** be used to inject dependencies\n * in tests. To inject dependencies in your application code, use the [`inject`](api/core/inject)\n * function from the `@angular/core` package instead.\n *\n * Example:\n *\n * ```ts\n * beforeEach(inject([Dependency, AClass], (dep, object) => {\n *   // some code that uses `dep` and `object`\n *   // ...\n * }));\n *\n * it('...', inject([AClass], (object) => {\n *   object.doSomething();\n *   expect(...);\n * })\n * ```\n *\n * @publicApi\n */\nfunction inject(tokens, fn) {\n    const testBed = TestBedImpl.INSTANCE;\n    // Not using an arrow function to preserve context passed from call site\n    return function () {\n        return testBed.execute(tokens, fn, this);\n    };\n}\n/**\n * @publicApi\n */\nclass InjectSetupWrapper {\n    _moduleDef;\n    constructor(_moduleDef) {\n        this._moduleDef = _moduleDef;\n    }\n    _addModule() {\n        const moduleDef = this._moduleDef();\n        if (moduleDef) {\n            TestBedImpl.configureTestingModule(moduleDef);\n        }\n    }\n    inject(tokens, fn) {\n        const self = this;\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            self._addModule();\n            return inject(tokens, fn).call(this);\n        };\n    }\n}\nfunction withModule(moduleDef, fn) {\n    if (fn) {\n        // Not using an arrow function to preserve context passed from call site\n        return function () {\n            const testBed = TestBedImpl.INSTANCE;\n            if (moduleDef) {\n                testBed.configureTestingModule(moduleDef);\n            }\n            return fn.apply(this);\n        };\n    }\n    return new InjectSetupWrapper(() => moduleDef);\n}\n\n/**\n * Public Test Library for unit testing Angular applications. Assumes that you are running\n * with Jasmine, Mocha, or a similar framework which exports a beforeEach function and\n * allows tests to be asynchronous by either returning a promise or using a 'done' parameter.\n */\n// Reset the test providers and the fake async zone before each test.\n// We keep a guard because somehow this file can make it into a bundle and be executed\n// beforeEach is only defined when executing the tests\nglobalThis.beforeEach?.(getCleanupHook(false));\n// We provide both a `beforeEach` and `afterEach`, because the updated behavior for\n// tearing down the module is supposed to run after the test so that we can associate\n// teardown errors with the correct test.\n// We keep a guard because somehow this file can make it into a bundle and be executed\n// afterEach is only defined when executing the tests\nglobalThis.afterEach?.(getCleanupHook(true));\nfunction getCleanupHook(expectedTeardownValue) {\n    return () => {\n        const testBed = TestBedImpl.INSTANCE;\n        if (testBed.shouldTearDownTestingModule() === expectedTeardownValue) {\n            testBed.resetTestingModule();\n            resetFakeAsyncZoneIfExists();\n        }\n    };\n}\n/**\n * This API should be removed. But doing so seems to break `google3` and so it requires a bit of\n * investigation.\n *\n * A work around is to mark it as `@codeGenApi` for now and investigate later.\n *\n * @codeGenApi\n */\n// TODO(iminar): Remove this code in a safe way.\nconst __core_private_testing_placeholder__ = '';\n\n/**\n * Fake implementation of user agent history and navigation behavior. This is a\n * high-fidelity implementation of browser behavior that attempts to emulate\n * things like traversal delay.\n */\nclass FakeNavigation {\n    window;\n    /**\n     * The fake implementation of an entries array. Only same-document entries\n     * allowed.\n     */\n    entriesArr = [];\n    /**\n     * The current active entry index into `entriesArr`.\n     */\n    currentEntryIndex = 0;\n    /**\n     * The current navigate event.\n     * @internal\n     */\n    navigateEvent = null;\n    /**\n     * A Map of pending traversals, so that traversals to the same entry can be\n     * re-used.\n     */\n    traversalQueue = new Map();\n    /**\n     * A Promise that resolves when the previous traversals have finished. Used to\n     * simulate the cross-process communication necessary for traversals.\n     */\n    nextTraversal = Promise.resolve();\n    /**\n     * A prospective current active entry index, which includes unresolved\n     * traversals. Used by `go` to determine where navigations are intended to go.\n     */\n    prospectiveEntryIndex = 0;\n    /**\n     * A test-only option to make traversals synchronous, rather than emulate\n     * cross-process communication.\n     */\n    synchronousTraversals = false;\n    /** Whether to allow a call to setInitialEntryForTesting. */\n    canSetInitialEntry = true;\n    /**\n     * `EventTarget` to dispatch events.\n     * @internal\n     */\n    eventTarget;\n    /** The next unique id for created entries. Replace recreates this id. */\n    nextId = 0;\n    /** The next unique key for created entries. Replace inherits this id. */\n    nextKey = 0;\n    /** Whether this fake is disposed. */\n    disposed = false;\n    /** Equivalent to `navigation.currentEntry`. */\n    get currentEntry() {\n        return this.entriesArr[this.currentEntryIndex];\n    }\n    get canGoBack() {\n        return this.currentEntryIndex > 0;\n    }\n    get canGoForward() {\n        return this.currentEntryIndex < this.entriesArr.length - 1;\n    }\n    constructor(window, startURL) {\n        this.window = window;\n        this.eventTarget = this.window.document.createElement('div');\n        // First entry.\n        this.setInitialEntryForTesting(startURL);\n    }\n    /**\n     * Sets the initial entry.\n     */\n    setInitialEntryForTesting(url, options = { historyState: null }) {\n        if (!this.canSetInitialEntry) {\n            throw new Error('setInitialEntryForTesting can only be called before any ' + 'navigation has occurred');\n        }\n        const currentInitialEntry = this.entriesArr[0];\n        this.entriesArr[0] = new FakeNavigationHistoryEntry(this.window.document.createElement('div'), new URL(url).toString(), {\n            index: 0,\n            key: currentInitialEntry?.key ?? String(this.nextKey++),\n            id: currentInitialEntry?.id ?? String(this.nextId++),\n            sameDocument: true,\n            historyState: options?.historyState,\n            state: options.state,\n        });\n    }\n    /** Returns whether the initial entry is still eligible to be set. */\n    canSetInitialEntryForTesting() {\n        return this.canSetInitialEntry;\n    }\n    /**\n     * Sets whether to emulate traversals as synchronous rather than\n     * asynchronous.\n     */\n    setSynchronousTraversalsForTesting(synchronousTraversals) {\n        this.synchronousTraversals = synchronousTraversals;\n    }\n    /** Equivalent to `navigation.entries()`. */\n    entries() {\n        return this.entriesArr.slice();\n    }\n    /** Equivalent to `navigation.navigate()`. */\n    navigate(url, options) {\n        const fromUrl = new URL(this.currentEntry.url);\n        const toUrl = new URL(url, this.currentEntry.url);\n        let navigationType;\n        if (!options?.history || options.history === 'auto') {\n            // Auto defaults to push, but if the URLs are the same, is a replace.\n            if (fromUrl.toString() === toUrl.toString()) {\n                navigationType = 'replace';\n            }\n            else {\n                navigationType = 'push';\n            }\n        }\n        else {\n            navigationType = options.history;\n        }\n        const hashChange = isHashChange(fromUrl, toUrl);\n        const destination = new FakeNavigationDestination({\n            url: toUrl.toString(),\n            state: options?.state,\n            sameDocument: hashChange,\n            historyState: null,\n        });\n        const result = new InternalNavigationResult(this);\n        this.userAgentNavigate(destination, result, {\n            navigationType,\n            cancelable: true,\n            canIntercept: true,\n            // Always false for navigate().\n            userInitiated: false,\n            hashChange,\n            info: options?.info,\n        });\n        return {\n            committed: result.committed,\n            finished: result.finished,\n        };\n    }\n    /** Equivalent to `history.pushState()`. */\n    pushState(data, title, url) {\n        this.pushOrReplaceState('push', data, title, url);\n    }\n    /** Equivalent to `history.replaceState()`. */\n    replaceState(data, title, url) {\n        this.pushOrReplaceState('replace', data, title, url);\n    }\n    pushOrReplaceState(navigationType, data, _title, url) {\n        const fromUrl = new URL(this.currentEntry.url);\n        const toUrl = url ? new URL(url, this.currentEntry.url) : fromUrl;\n        const hashChange = isHashChange(fromUrl, toUrl);\n        const destination = new FakeNavigationDestination({\n            url: toUrl.toString(),\n            sameDocument: true,\n            historyState: data,\n        });\n        const result = new InternalNavigationResult(this);\n        this.userAgentNavigate(destination, result, {\n            navigationType,\n            cancelable: true,\n            canIntercept: true,\n            // Always false for pushState() or replaceState().\n            userInitiated: false,\n            hashChange,\n        });\n    }\n    /** Equivalent to `navigation.traverseTo()`. */\n    traverseTo(key, options) {\n        const fromUrl = new URL(this.currentEntry.url);\n        const entry = this.findEntry(key);\n        if (!entry) {\n            const domException = new DOMException('Invalid key', 'InvalidStateError');\n            const committed = Promise.reject(domException);\n            const finished = Promise.reject(domException);\n            committed.catch(() => { });\n            finished.catch(() => { });\n            return {\n                committed,\n                finished,\n            };\n        }\n        if (entry === this.currentEntry) {\n            return {\n                committed: Promise.resolve(this.currentEntry),\n                finished: Promise.resolve(this.currentEntry),\n            };\n        }\n        if (this.traversalQueue.has(entry.key)) {\n            const existingResult = this.traversalQueue.get(entry.key);\n            return {\n                committed: existingResult.committed,\n                finished: existingResult.finished,\n            };\n        }\n        const hashChange = isHashChange(fromUrl, new URL(entry.url, this.currentEntry.url));\n        const destination = new FakeNavigationDestination({\n            url: entry.url,\n            state: entry.getState(),\n            historyState: entry.getHistoryState(),\n            key: entry.key,\n            id: entry.id,\n            index: entry.index,\n            sameDocument: entry.sameDocument,\n        });\n        this.prospectiveEntryIndex = entry.index;\n        const result = new InternalNavigationResult(this);\n        this.traversalQueue.set(entry.key, result);\n        this.runTraversal(() => {\n            this.traversalQueue.delete(entry.key);\n            const event = this.userAgentNavigate(destination, result, {\n                navigationType: 'traverse',\n                cancelable: true,\n                canIntercept: true,\n                // Always false for traverseTo().\n                userInitiated: false,\n                hashChange,\n                info: options?.info,\n            });\n            // Note this does not pay attention at all to the commit status of the event (and thus, does not support deferred commit for traversals)\n            this.userAgentTraverse(event);\n        });\n        return {\n            committed: result.committed,\n            finished: result.finished,\n        };\n    }\n    /** Equivalent to `navigation.back()`. */\n    back(options) {\n        if (this.currentEntryIndex === 0) {\n            const domException = new DOMException('Cannot go back', 'InvalidStateError');\n            const committed = Promise.reject(domException);\n            const finished = Promise.reject(domException);\n            committed.catch(() => { });\n            finished.catch(() => { });\n            return {\n                committed,\n                finished,\n            };\n        }\n        const entry = this.entriesArr[this.currentEntryIndex - 1];\n        return this.traverseTo(entry.key, options);\n    }\n    /** Equivalent to `navigation.forward()`. */\n    forward(options) {\n        if (this.currentEntryIndex === this.entriesArr.length - 1) {\n            const domException = new DOMException('Cannot go forward', 'InvalidStateError');\n            const committed = Promise.reject(domException);\n            const finished = Promise.reject(domException);\n            committed.catch(() => { });\n            finished.catch(() => { });\n            return {\n                committed,\n                finished,\n            };\n        }\n        const entry = this.entriesArr[this.currentEntryIndex + 1];\n        return this.traverseTo(entry.key, options);\n    }\n    /**\n     * Equivalent to `history.go()`.\n     * Note that this method does not actually work precisely to how Chrome\n     * does, instead choosing a simpler model with less unexpected behavior.\n     * Chrome has a few edge case optimizations, for instance with repeated\n     * `back(); forward()` chains it collapses certain traversals.\n     */\n    go(direction) {\n        const targetIndex = this.prospectiveEntryIndex + direction;\n        if (targetIndex >= this.entriesArr.length || targetIndex < 0) {\n            return;\n        }\n        this.prospectiveEntryIndex = targetIndex;\n        this.runTraversal(() => {\n            // Check again that destination is in the entries array.\n            if (targetIndex >= this.entriesArr.length || targetIndex < 0) {\n                return;\n            }\n            const fromUrl = new URL(this.currentEntry.url);\n            const entry = this.entriesArr[targetIndex];\n            const hashChange = isHashChange(fromUrl, new URL(entry.url, this.currentEntry.url));\n            const destination = new FakeNavigationDestination({\n                url: entry.url,\n                state: entry.getState(),\n                historyState: entry.getHistoryState(),\n                key: entry.key,\n                id: entry.id,\n                index: entry.index,\n                sameDocument: entry.sameDocument,\n            });\n            const result = new InternalNavigationResult(this);\n            const event = this.userAgentNavigate(destination, result, {\n                navigationType: 'traverse',\n                cancelable: true,\n                canIntercept: true,\n                // Always false for go().\n                userInitiated: false,\n                hashChange,\n            });\n            // Note this does not pay attention at all to the commit status of the event (and thus, does not support deferred commit for traversals)\n            this.userAgentTraverse(event);\n        });\n    }\n    /** Runs a traversal synchronously or asynchronously */\n    runTraversal(traversal) {\n        if (this.synchronousTraversals) {\n            traversal();\n            return;\n        }\n        // Each traversal occupies a single timeout resolution.\n        // This means that Promises added to commit and finish should resolve\n        // before the next traversal.\n        this.nextTraversal = this.nextTraversal.then(() => {\n            return new Promise((resolve) => {\n                setTimeout(() => {\n                    resolve();\n                    traversal();\n                });\n            });\n        });\n    }\n    /** Equivalent to `navigation.addEventListener()`. */\n    addEventListener(type, callback, options) {\n        this.eventTarget.addEventListener(type, callback, options);\n    }\n    /** Equivalent to `navigation.removeEventListener()`. */\n    removeEventListener(type, callback, options) {\n        this.eventTarget.removeEventListener(type, callback, options);\n    }\n    /** Equivalent to `navigation.dispatchEvent()` */\n    dispatchEvent(event) {\n        return this.eventTarget.dispatchEvent(event);\n    }\n    /** Cleans up resources. */\n    dispose() {\n        // Recreate eventTarget to release current listeners.\n        // `document.createElement` because NodeJS `EventTarget` is incompatible with Domino's `Event`.\n        this.eventTarget = this.window.document.createElement('div');\n        this.disposed = true;\n    }\n    /** Returns whether this fake is disposed. */\n    isDisposed() {\n        return this.disposed;\n    }\n    /** Implementation for all navigations and traversals. */\n    userAgentNavigate(destination, result, options) {\n        // The first navigation should disallow any future calls to set the initial\n        // entry.\n        this.canSetInitialEntry = false;\n        if (this.navigateEvent) {\n            this.navigateEvent.cancel(new DOMException('Navigation was aborted', 'AbortError'));\n            this.navigateEvent = null;\n        }\n        return dispatchNavigateEvent({\n            navigationType: options.navigationType,\n            cancelable: options.cancelable,\n            canIntercept: options.canIntercept,\n            userInitiated: options.userInitiated,\n            hashChange: options.hashChange,\n            signal: result.signal,\n            destination,\n            info: options.info,\n            sameDocument: destination.sameDocument,\n            result,\n        });\n    }\n    /**\n     * Implementation to commit a navigation.\n     * https://whatpr.org/html/10919/nav-history-apis.html#navigateevent-commit\n     * @internal\n     */\n    commitNavigateEvent(navigateEvent) {\n        navigateEvent.interceptionState = 'committed';\n        const from = this.currentEntry;\n        if (!from) {\n            throw new Error('cannot commit navigation when current entry is null');\n        }\n        if (!navigateEvent.sameDocument) {\n            const error = new Error('Cannot navigate to a non-same-document URL.');\n            navigateEvent.cancel(error);\n            throw error;\n        }\n        // \"If navigationType is \"push\" or \"replace\", then run the URL and history update steps given document and event's destination's URL, with serialiedData set to event's classic history API state and historyHandling set to navigationType.\"\n        if (navigateEvent.navigationType === 'push' || navigateEvent.navigationType === 'replace') {\n            this.urlAndHistoryUpdateSteps(navigateEvent);\n        }\n        else if (navigateEvent.navigationType === 'reload') {\n            this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent);\n        }\n        else ;\n    }\n    /**\n     * Implementation for a push or replace navigation.\n     * https://whatpr.org/html/10919/browsing-the-web.html#url-and-history-update-steps\n     * https://whatpr.org/html/10919/nav-history-apis.html#update-the-navigation-api-entries-for-a-same-document-navigation\n     */\n    urlAndHistoryUpdateSteps(navigateEvent) {\n        this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent);\n    }\n    /**\n     * Implementation for a traverse navigation.\n     *\n     * https://whatpr.org/html/10919/browsing-the-web.html#apply-the-traverse-history-step\n     * ...\n     * > Let updateDocument be an algorithm step which performs update document for history step application given targetEntry's document, targetEntry, changingNavigableContinuation's update-only, scriptHistoryLength, scriptHistoryIndex, navigationType, entriesForNavigationAPI, and previousEntry.\n     * > If targetEntry's document is equal to displayedDocument, then perform updateDocument.\n     * https://whatpr.org/html/10919/browsing-the-web.html#update-document-for-history-step-application\n     * which then goes to https://whatpr.org/html/10919/nav-history-apis.html#update-the-navigation-api-entries-for-a-same-document-navigation\n     */\n    userAgentTraverse(navigateEvent) {\n        this.updateNavigationEntriesForSameDocumentNavigation(navigateEvent);\n        // Happens as part of \"updating the document\" steps https://whatpr.org/html/10919/browsing-the-web.html#updating-the-document\n        const popStateEvent = createPopStateEvent({\n            state: navigateEvent.destination.getHistoryState(),\n        });\n        this.window.dispatchEvent(popStateEvent);\n        // TODO(atscott): If oldURL's fragment is not equal to entry's URL's fragment, then queue a global task to fire an event named hashchange\n    }\n    /** https://whatpr.org/html/10919/nav-history-apis.html#update-the-navigation-api-entries-for-a-same-document-navigation */\n    updateNavigationEntriesForSameDocumentNavigation({ destination, navigationType, result, }) {\n        const oldCurrentNHE = this.currentEntry;\n        const disposedNHEs = [];\n        if (navigationType === 'traverse') {\n            this.currentEntryIndex = destination.index;\n            if (this.currentEntryIndex === -1) {\n                throw new Error('unexpected current entry index');\n            }\n        }\n        else if (navigationType === 'push') {\n            this.currentEntryIndex++;\n            this.prospectiveEntryIndex = this.currentEntryIndex; // prospectiveEntryIndex isn't in the spec but is an implementation detail\n            disposedNHEs.push(...this.entriesArr.splice(this.currentEntryIndex));\n        }\n        else if (navigationType === 'replace') {\n            disposedNHEs.push(oldCurrentNHE);\n        }\n        if (navigationType === 'push' || navigationType === 'replace') {\n            const index = this.currentEntryIndex;\n            const key = navigationType === 'push' ? String(this.nextKey++) : this.currentEntry.key;\n            const newNHE = new FakeNavigationHistoryEntry(this.window.document.createElement('div'), destination.url, {\n                id: String(this.nextId++),\n                key,\n                index,\n                sameDocument: true,\n                state: destination.getState(),\n                historyState: destination.getHistoryState(),\n            });\n            this.entriesArr[this.currentEntryIndex] = newNHE;\n        }\n        result.committedResolve(this.currentEntry);\n        const currentEntryChangeEvent = createFakeNavigationCurrentEntryChangeEvent({\n            from: oldCurrentNHE,\n            navigationType: navigationType,\n        });\n        this.eventTarget.dispatchEvent(currentEntryChangeEvent);\n        for (const disposedNHE of disposedNHEs) {\n            disposedNHE.dispose();\n        }\n    }\n    /** Utility method for finding entries with the given `key`. */\n    findEntry(key) {\n        for (const entry of this.entriesArr) {\n            if (entry.key === key)\n                return entry;\n        }\n        return undefined;\n    }\n    set onnavigate(\n    // tslint:disable-next-line:no-any\n    _handler) {\n        throw new Error('unimplemented');\n    }\n    // tslint:disable-next-line:no-any\n    get onnavigate() {\n        throw new Error('unimplemented');\n    }\n    set oncurrententrychange(_handler) {\n        throw new Error('unimplemented');\n    }\n    get oncurrententrychange() {\n        throw new Error('unimplemented');\n    }\n    set onnavigatesuccess(\n    // tslint:disable-next-line:no-any\n    _handler) {\n        throw new Error('unimplemented');\n    }\n    // tslint:disable-next-line:no-any\n    get onnavigatesuccess() {\n        throw new Error('unimplemented');\n    }\n    set onnavigateerror(\n    // tslint:disable-next-line:no-any\n    _handler) {\n        throw new Error('unimplemented');\n    }\n    // tslint:disable-next-line:no-any\n    get onnavigateerror() {\n        throw new Error('unimplemented');\n    }\n    _transition = null;\n    /** @internal */\n    set transition(t) {\n        this._transition = t;\n    }\n    get transition() {\n        return this._transition;\n    }\n    updateCurrentEntry(_options) {\n        throw new Error('unimplemented');\n    }\n    reload(_options) {\n        throw new Error('unimplemented');\n    }\n}\n/**\n * Fake equivalent of `NavigationHistoryEntry`.\n */\nclass FakeNavigationHistoryEntry {\n    eventTarget;\n    url;\n    sameDocument;\n    id;\n    key;\n    index;\n    state;\n    historyState;\n    // tslint:disable-next-line:no-any\n    ondispose = null;\n    constructor(eventTarget, url, { id, key, index, sameDocument, state, historyState, }) {\n        this.eventTarget = eventTarget;\n        this.url = url;\n        this.id = id;\n        this.key = key;\n        this.index = index;\n        this.sameDocument = sameDocument;\n        this.state = state;\n        this.historyState = historyState;\n    }\n    getState() {\n        // Budget copy.\n        return this.state ? JSON.parse(JSON.stringify(this.state)) : this.state;\n    }\n    getHistoryState() {\n        // Budget copy.\n        return this.historyState\n            ? JSON.parse(JSON.stringify(this.historyState))\n            : this.historyState;\n    }\n    addEventListener(type, callback, options) {\n        this.eventTarget.addEventListener(type, callback, options);\n    }\n    removeEventListener(type, callback, options) {\n        this.eventTarget.removeEventListener(type, callback, options);\n    }\n    dispatchEvent(event) {\n        return this.eventTarget.dispatchEvent(event);\n    }\n    /** internal */\n    dispose() {\n        const disposeEvent = new Event('disposed');\n        this.dispatchEvent(disposeEvent);\n        // release current listeners\n        this.eventTarget = null;\n    }\n}\n/**\n * Create a fake equivalent of `NavigateEvent`. This is not a class because ES5\n * transpiled JavaScript cannot extend native Event.\n *\n * https://html.spec.whatwg.org/multipage/nav-history-apis.html#navigate-event-firing\n */\nfunction dispatchNavigateEvent({ cancelable, canIntercept, userInitiated, hashChange, navigationType, signal, destination, info, sameDocument, result, }) {\n    const { navigation } = result;\n    const event = new Event('navigate', { bubbles: false, cancelable });\n    event.focusResetBehavior = null;\n    event.scrollBehavior = null;\n    event.interceptionState = 'none';\n    event.canIntercept = canIntercept;\n    event.userInitiated = userInitiated;\n    event.hashChange = hashChange;\n    event.navigationType = navigationType;\n    event.signal = signal;\n    event.destination = destination;\n    event.info = info;\n    event.downloadRequest = null;\n    event.formData = null;\n    event.result = result;\n    event.sameDocument = sameDocument;\n    event.commitOption = 'immediate';\n    let handlersFinished = [Promise.resolve()];\n    let dispatchedNavigateEvent = false;\n    event.intercept = function (options) {\n        if (!this.canIntercept) {\n            throw new DOMException(`Cannot intercept when canIntercept is 'false'`, 'SecurityError');\n        }\n        this.interceptionState = 'intercepted';\n        event.sameDocument = true;\n        const handler = options?.handler;\n        if (handler) {\n            handlersFinished.push(handler());\n        }\n        // override old options with new ones. UA _may_ report a console warning if new options differ from previous\n        event.commitOption = options?.commit ?? event.commitOption;\n        event.scrollBehavior = options?.scroll ?? event.scrollBehavior;\n        event.focusResetBehavior = options?.focusReset ?? event.focusResetBehavior;\n    };\n    event.scroll = function () {\n        if (event.interceptionState !== 'committed') {\n            throw new DOMException(`Failed to execute 'scroll' on 'NavigateEvent': scroll() must be ` +\n                `called after commit() and interception options must specify manual scroll.`, 'InvalidStateError');\n        }\n        processScrollBehavior(event);\n    };\n    event.commit = function (internal = false) {\n        if (!internal && this.interceptionState !== 'intercepted') {\n            throw new DOMException(`Failed to execute 'commit' on 'NavigateEvent': intercept() must be ` +\n                `called before commit() and commit() cannot be already called.`, 'InvalidStateError');\n        }\n        if (!internal && event.commitOption !== 'after-transition') {\n            throw new DOMException(`Failed to execute 'commit' on 'NavigateEvent': commit() may not be ` +\n                `called if commit behavior is not \"after-transition\",.`, 'InvalidStateError');\n        }\n        if (!dispatchedNavigateEvent) {\n            throw new DOMException(`Failed to execute 'commit' on 'NavigateEvent': commit() may not be ` +\n                `called during event dispatch.`, 'InvalidStateError');\n        }\n        this.interceptionState = 'committed';\n        result.navigation.commitNavigateEvent(event);\n    };\n    // Internal only.\n    event.cancel = function (reason) {\n        result.committedReject(reason);\n        result.finishedReject(reason);\n    };\n    function dispatch() {\n        navigation.navigateEvent = event;\n        navigation.eventTarget.dispatchEvent(event);\n        dispatchedNavigateEvent = true;\n        if (event.interceptionState !== 'none') {\n            navigation.transition = new InternalNavigationTransition(navigation.currentEntry, navigationType);\n            if (event.commitOption !== 'after-transition') {\n                event.commit(/** internal */ true);\n            }\n        }\n        else {\n            // In the spec, this isn't really part of the navigate API. Instead, the navigate event firing returns \"true\" to indicate\n            // navigation steps should \"continue\" (https://whatpr.org/html/10919/browsing-the-web.html#beginning-navigation)\n            event.commit(/** internal */ true);\n        }\n        Promise.all(handlersFinished).then(() => {\n            // Follows steps outlined under \"Wait for all of promisesList, with the following success steps:\"\n            // in the spec https://html.spec.whatwg.org/multipage/nav-history-apis.html#navigate-event-firing.\n            if (result.signal.aborted) {\n                return;\n            }\n            if (event !== navigation.navigateEvent) {\n                throw new Error(\"Navigation's ongoing event not equal to resolved event\");\n            }\n            navigation.navigateEvent = null;\n            if (event.interceptionState === 'intercepted') {\n                navigation.commitNavigateEvent(event);\n            }\n            finishNavigationEvent(event, true);\n            const navigatesuccessEvent = new Event('navigatesuccess', { bubbles: false, cancelable });\n            navigation.eventTarget.dispatchEvent(navigatesuccessEvent);\n            result.finishedResolve();\n            if (navigation.transition !== null) {\n                navigation.transition.finishedResolve();\n            }\n            navigation.transition = null;\n        }, (reason) => {\n            if (result.signal.aborted) {\n                return;\n            }\n            if (event !== navigation.navigateEvent) {\n                throw new Error(\"Navigation's ongoing event not equal to resolved event\");\n            }\n            navigation.navigateEvent = null;\n            event.interceptionState = 'rejected'; // TODO(atscott): this is not in the spec https://github.com/whatwg/html/issues/11087\n            finishNavigationEvent(event, false);\n            const navigateerrorEvent = new Event('navigateerror', { bubbles: false, cancelable });\n            navigation.eventTarget.dispatchEvent(navigateerrorEvent);\n            result.finishedReject(reason);\n            if (navigation.transition !== null) {\n                navigation.transition.finishedResolve();\n            }\n            navigation.transition = null;\n        });\n    }\n    dispatch();\n    return event;\n}\n/** https://whatpr.org/html/10919/nav-history-apis.html#navigateevent-finish */\nfunction finishNavigationEvent(event, didFulfill) {\n    if (event.interceptionState === 'intercepted' || event.interceptionState === 'finished') {\n        throw new Error('Attempting to finish navigation event that was incomplete or already finished');\n    }\n    if (event.interceptionState === 'none') {\n        return;\n    }\n    if (didFulfill) {\n        // TODO(atscott): https://github.com/whatwg/html/issues/11087 focus reset is not guarded by didFulfill in the spec\n        potentiallyResetFocus(event);\n        potentiallyResetScroll(event);\n    }\n    event.interceptionState = 'finished';\n}\n/** https://whatpr.org/html/10919/nav-history-apis.html#potentially-reset-the-focus */\nfunction potentiallyResetFocus(event) {\n    if (event.interceptionState !== 'committed' && event.interceptionState !== 'scrolled') {\n        throw new Error('cannot reset focus if navigation event is not committed or scrolled');\n    }\n    // TODO(atscott): The rest of the steps\n}\nfunction potentiallyResetScroll(event) {\n    if (event.interceptionState !== 'committed' && event.interceptionState !== 'scrolled') {\n        throw new Error('cannot reset scroll if navigation event is not committed or scrolled');\n    }\n    if (event.interceptionState === 'scrolled' || event.scrollBehavior === 'manual') {\n        return;\n    }\n    processScrollBehavior(event);\n}\n/* https://whatpr.org/html/10919/nav-history-apis.html#process-scroll-behavior */\nfunction processScrollBehavior(event) {\n    if (event.interceptionState !== 'committed') {\n        throw new Error('invalid event interception state when processing scroll behavior');\n    }\n    event.interceptionState = 'scrolled';\n    // TODO(atscott): the rest of the steps\n}\n/**\n * Create a fake equivalent of `NavigationCurrentEntryChange`. This does not use\n * a class because ES5 transpiled JavaScript cannot extend native Event.\n */\nfunction createFakeNavigationCurrentEntryChangeEvent({ from, navigationType, }) {\n    const event = new Event('currententrychange', {\n        bubbles: false,\n        cancelable: false,\n    });\n    event.from = from;\n    event.navigationType = navigationType;\n    return event;\n}\n/**\n * Create a fake equivalent of `PopStateEvent`. This does not use a class\n * because ES5 transpiled JavaScript cannot extend native Event.\n */\nfunction createPopStateEvent({ state }) {\n    const event = new Event('popstate', {\n        bubbles: false,\n        cancelable: false,\n    });\n    event.state = state;\n    return event;\n}\n/**\n * Fake equivalent of `NavigationDestination`.\n */\nclass FakeNavigationDestination {\n    url;\n    sameDocument;\n    key;\n    id;\n    index;\n    state;\n    historyState;\n    constructor({ url, sameDocument, historyState, state, key = null, id = null, index = -1, }) {\n        this.url = url;\n        this.sameDocument = sameDocument;\n        this.state = state;\n        this.historyState = historyState;\n        this.key = key;\n        this.id = id;\n        this.index = index;\n    }\n    getState() {\n        return this.state;\n    }\n    getHistoryState() {\n        return this.historyState;\n    }\n}\n/** Utility function to determine whether two UrlLike have the same hash. */\nfunction isHashChange(from, to) {\n    return (to.hash !== from.hash &&\n        to.hostname === from.hostname &&\n        to.pathname === from.pathname &&\n        to.search === from.search);\n}\nclass InternalNavigationTransition {\n    from;\n    navigationType;\n    finished;\n    finishedResolve;\n    finishedReject;\n    constructor(from, navigationType) {\n        this.from = from;\n        this.navigationType = navigationType;\n        this.finished = new Promise((resolve, reject) => {\n            this.finishedReject = reject;\n            this.finishedResolve = resolve;\n        });\n    }\n}\n/**\n * Internal utility class for representing the result of a navigation.\n * Generally equivalent to the \"apiMethodTracker\" in the spec.\n */\nclass InternalNavigationResult {\n    navigation;\n    committedTo = null;\n    committedResolve;\n    committedReject;\n    finishedResolve;\n    finishedReject;\n    committed;\n    finished;\n    get signal() {\n        return this.abortController.signal;\n    }\n    abortController = new AbortController();\n    constructor(navigation) {\n        this.navigation = navigation;\n        this.committed = new Promise((resolve, reject) => {\n            this.committedResolve = (entry) => {\n                this.committedTo = entry;\n                resolve(entry);\n            };\n            this.committedReject = reject;\n        });\n        this.finished = new Promise(async (resolve, reject) => {\n            this.finishedResolve = () => {\n                if (this.committedTo === null) {\n                    throw new Error('NavigateEvent should have been committed before resolving finished promise.');\n                }\n                resolve(this.committedTo);\n            };\n            this.finishedReject = (reason) => {\n                reject(reason);\n                this.abortController.abort(reason);\n            };\n        });\n        // All rejections are handled.\n        this.committed.catch(() => { });\n        this.finished.catch(() => { });\n    }\n}\n\nexport { ComponentFixture, ComponentFixtureAutoDetect, ComponentFixtureNoNgZone, DeferBlockFixture, InjectSetupWrapper, TestBed, TestComponentRenderer, __core_private_testing_placeholder__, discardPeriodicTasks, fakeAsync, flush, flushMicrotasks, getTestBed, inject, resetFakeAsyncZone, tick, waitForAsync, withModule, FakeNavigation as ɵFakeNavigation, MetadataOverrider as ɵMetadataOverrider };\n"],"mappings":";AAAA;AACA;AACA;AACA;AACA;;AAEA,OAAO,KAAKA,EAAE,MAAM,eAAe;AACnC,SAASC,gBAAgB,IAAIC,gBAAgB,EAAEC,uBAAuB,IAAIC,uBAAuB,EAAEC,sBAAsB,IAAIC,sBAAsB,EAAEC,wBAAwB,IAAIC,wBAAwB,EAAEC,eAAe,IAAIC,eAAe,EAAEC,cAAc,EAAEC,mBAAmB,IAAIC,mBAAmB,EAAEC,MAAM,IAAIC,QAAQ,EAAEC,MAAM,EAAEC,YAAY,EAAEC,UAAU,EAAEC,WAAW,IAAIC,WAAW,EAAEC,cAAc,EAAEC,qBAAqB,IAAIC,qBAAqB,EAAEC,iBAAiB,IAAIC,iBAAiB,EAAEC,yBAAyB,IAAIC,yBAAyB,EAAEC,gBAAgB,IAAIC,gBAAgB,EAAEC,yBAAyB,IAAIC,yBAAyB,EAAEC,YAAY,EAAEC,gBAAgB,EAAEC,UAAU,IAAIC,UAAU,EAAEC,IAAI,EAAEC,SAAS,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,uBAAuB,IAAIC,uBAAuB,EAAEC,iCAAiC,IAAIC,iCAAiC,EAAEC,YAAY,IAAIC,YAAY,EAAEC,iBAAiB,IAAIC,iBAAiB,EAAEC,iBAAiB,EAAEC,gCAAgC,IAAIC,gCAAgC,EAAEC,wBAAwB,IAAIC,wBAAwB,EAAEC,0BAA0B,IAAIC,0BAA0B,EAAEC,mBAAmB,IAAIC,mBAAmB,EAAEC,qBAAqB,EAAEC,SAAS,EAAEC,kBAAkB,IAAIC,kBAAkB,EAAEC,YAAY,IAAIC,YAAY,EAAEC,wBAAwB,IAAIC,wBAAwB,EAAEC,YAAY,IAAIC,YAAY,EAAEC,iBAAiB,IAAIC,iBAAiB,EAAEC,WAAW,IAAIC,WAAW,EAAEC,iBAAiB,IAAIC,iBAAiB,EAAEC,YAAY,IAAIC,YAAY,EAAEC,YAAY,IAAIC,YAAY,EAAEC,WAAW,IAAIC,WAAW,EAAEC,2BAA2B,IAAIC,2BAA2B,EAAEC,WAAW,IAAIC,WAAW,EAAEC,oBAAoB,IAAIC,oBAAoB,EAAEC,yCAAyC,IAAIC,yCAAyC,EAAEC,gCAAgC,IAAIC,gCAAgC,EAAEC,mCAAmC,IAAIC,mCAAmC,EAAEC,6BAA6B,IAAIC,6BAA6B,EAAEC,QAAQ,EAAEC,mBAAmB,IAAIC,mBAAmB,EAAEC,mCAAmC,IAAIC,mCAAmC,EAAEC,gBAAgB,EAAEC,QAAQ,EAAEC,oBAAoB,IAAIC,oBAAoB,EAAEC,sCAAsC,IAAIC,sCAAsC,EAAEC,gBAAgB,IAAIC,gBAAgB,EAAEC,4BAA4B,EAAEC,uBAAuB,IAAIC,uBAAuB,EAAEC,kBAAkB,IAAIC,kBAAkB,EAAEC,WAAW,EAAEC,oCAAoC,IAAIC,oCAAoC,EAAEC,wBAAwB,IAAIC,wBAAwB,EAAEC,4BAA4B,IAAIC,4BAA4B,EAAEC,6BAA6B,IAAIC,6BAA6B,EAAEC,4BAA4B,IAAIC,4BAA4B,EAAEC,6BAA6B,IAAIC,6BAA6B,EAAEC,qBAAqB,EAAEC,mBAAmB,EAAEC,wCAAwC,IAAIC,wCAAwC,QAAQ,eAAe;AACx6F,SAASnH,mBAAmB,IAAIoH,kBAAkB,EAAE/H,gBAAgB,IAAIgI,eAAe,QAAQ,eAAe;AAC9G,SAASC,YAAY,QAAQ,MAAM;AACnC,SAASC,cAAc,QAAQ,mBAAmB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,YAAYA,CAACC,EAAE,EAAE;EACtB,MAAMC,KAAK,GAAG,OAAOC,IAAI,KAAK,WAAW,GAAGA,IAAI,GAAG,IAAI;EACvD,IAAI,CAACD,KAAK,EAAE;IACR,OAAO,YAAY;MACf,OAAOE,OAAO,CAACC,MAAM,CAAC,4EAA4E,GAC9F,yDAAyD,CAAC;IAClE,CAAC;EACL;EACA,MAAMC,SAAS,GAAGJ,KAAK,IAAIA,KAAK,CAACA,KAAK,CAACK,UAAU,CAAC,WAAW,CAAC,CAAC;EAC/D,IAAI,OAAOD,SAAS,KAAK,UAAU,EAAE;IACjC,OAAOA,SAAS,CAACL,EAAE,CAAC;EACxB;EACA,OAAO,YAAY;IACf,OAAOG,OAAO,CAACC,MAAM,CAAC,gFAAgF,GAClG,iEAAiE,CAAC;EAC1E,CAAC;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAMG,iBAAiB,CAAC;EACpBC,KAAK;EACLC,gBAAgB;EAChB;EACAC,WAAWA,CAACF,KAAK,EAAEC,gBAAgB,EAAE;IACjC,IAAI,CAACD,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACC,gBAAgB,GAAGA,gBAAgB;EAC5C;EACA;AACJ;AACA;AACA;EACUE,MAAMA,CAACC,KAAK,EAAE;IAAA,IAAAC,KAAA;IAAA,OAAAC,iBAAA;MAChB,IAAI,CAACC,gBAAgB,CAACH,KAAK,EAAEC,KAAI,CAACL,KAAK,CAAC,EAAE;QACtC,MAAMQ,aAAa,GAAGC,8BAA8B,CAACL,KAAK,CAAC;QAC3D,MAAM,IAAIM,KAAK,CAAC,6CAA6CF,aAAa,YAAY,GAClF,qBAAqBA,aAAa,CAACG,WAAW,CAAC,CAAC,+BAA+B,CAAC;MACxF;MACA,IAAIP,KAAK,KAAK/I,gBAAgB,CAACuJ,QAAQ,EAAE;QACrC,MAAMrJ,uBAAuB,CAAC8I,KAAI,CAACL,KAAK,CAACa,QAAQ,EAAER,KAAI,CAACL,KAAK,CAACc,KAAK,EAAET,KAAI,CAACL,KAAK,CAACe,KAAK,CAAC;MAC1F;MACA;MACA;MACA,MAAMC,mBAAmB,GAAG,IAAI;MAChCvJ,sBAAsB,CAAC2I,KAAK,EAAEC,KAAI,CAACL,KAAK,CAACe,KAAK,EAAEV,KAAI,CAACL,KAAK,CAACiB,UAAU,EAAED,mBAAmB,CAAC;MAC3FX,KAAI,CAACJ,gBAAgB,CAACiB,aAAa,CAAC,CAAC;IAAC;EAC1C;EACA;AACJ;AACA;AACA;EACIC,cAAcA,CAAA,EAAG;IACb,MAAMC,WAAW,GAAG,EAAE;IACtB;IACA;IACA;IACA,MAAMC,kBAAkB,GAAG,EAAE;IAC7B,IAAI,IAAI,CAACrB,KAAK,CAACiB,UAAU,CAACK,MAAM,IAAI3J,wBAAwB,EAAE;MAC1D,MAAMmJ,KAAK,GAAG,IAAI,CAACd,KAAK,CAACiB,UAAU,CAACtJ,wBAAwB,CAAC;MAC7DE,eAAe,CAACiJ,KAAK,EAAEM,WAAW,CAAC;MACnC,KAAK,MAAMpB,KAAK,IAAIoB,WAAW,EAAE;QAC7BC,kBAAkB,CAACE,IAAI,CAAC,IAAIxB,iBAAiB,CAACC,KAAK,EAAE,IAAI,CAACC,gBAAgB,CAAC,CAAC;MAChF;IACJ;IACA,OAAON,OAAO,CAAC6B,OAAO,CAACH,kBAAkB,CAAC;EAC9C;AACJ;AACA,SAASd,gBAAgBA,CAACH,KAAK,EAAEJ,KAAK,EAAE;EACpC,QAAQI,KAAK;IACT,KAAK/I,gBAAgB,CAACoK,WAAW;MAC7B,OAAOzB,KAAK,CAACa,QAAQ,CAACa,oBAAoB,KAAK,IAAI;IACvD,KAAKrK,gBAAgB,CAACsK,OAAO;MACzB,OAAO3B,KAAK,CAACa,QAAQ,CAACe,gBAAgB,KAAK,IAAI;IACnD,KAAKvK,gBAAgB,CAACqJ,KAAK;MACvB,OAAOV,KAAK,CAACa,QAAQ,CAACgB,cAAc,KAAK,IAAI;IACjD,KAAKxK,gBAAgB,CAACuJ,QAAQ;MAC1B,OAAO,IAAI;IACf;MACI,OAAO,KAAK;EACpB;AACJ;AACA,SAASH,8BAA8BA,CAACL,KAAK,EAAE;EAC3C,QAAQA,KAAK;IACT,KAAK/I,gBAAgB,CAACoK,WAAW;MAC7B,OAAO,aAAa;IACxB,KAAKpK,gBAAgB,CAACsK,OAAO;MACzB,OAAO,SAAS;IACpB,KAAKtK,gBAAgB,CAACqJ,KAAK;MACvB,OAAO,OAAO;IAClB;MACI,OAAO,MAAM;EACrB;AACJ;;AAEA;AACA,MAAMoB,0CAA0C,GAAG,IAAI;AACvD;AACA,MAAMC,iCAAiC,GAAG,KAAK;AAC/C;AACA,MAAMC,mCAAmC,GAAG,KAAK;AACjD;AACA,MAAMC,4BAA4B,GAAGjK,mBAAmB,CAACkK,WAAW;AACpE;AACA;AACA;AACA;AACA;AACA,MAAMC,qBAAqB,CAAC;EACxBC,iBAAiBA,CAACC,aAAa,EAAE,CAAE;EACnCC,qBAAqBA,CAAA,EAAG,CAAE;AAC9B;AACA;AACA;AACA;AACA,MAAMC,0BAA0B,GAAG,IAAIzK,cAAc,CAAC,4BAA4B,CAAC;AACnF;AACA;AACA;AACA,MAAM0K,wBAAwB,GAAG,IAAI1K,cAAc,CAAC,0BAA0B,CAAC;AAE/E,MAAM2K,kCAAkC,GAAG,IAAI;AAC/C,MAAMC,8BAA8B,CAAC;EACjCC,IAAI,GAAGzK,QAAQ,CAACC,MAAM,CAAC;EACvByK,gBAAgB,GAAG1K,QAAQ,CAACE,YAAY,CAAC;EACzCyK,yBAAyB,GAAG,IAAIC,GAAG,CAAC,CAAC;EACrCC,WAAWA,CAACC,CAAC,EAAE;IACX,IAAI;MACA,IAAI,CAACL,IAAI,CAACM,iBAAiB,CAAC,MAAM,IAAI,CAACL,gBAAgB,CAACG,WAAW,CAACC,CAAC,CAAC,CAAC;IAC3E,CAAC,CACD,OAAOE,SAAS,EAAE;MACdF,CAAC,GAAGE,SAAS;IACjB;IACA;IACA;IACA;IACA,IAAI,IAAI,CAACL,yBAAyB,CAACM,IAAI,GAAG,CAAC,EAAE;MACzC,KAAK,MAAM3D,EAAE,IAAI,IAAI,CAACqD,yBAAyB,CAACO,MAAM,CAAC,CAAC,EAAE;QACtD5D,EAAE,CAACwD,CAAC,CAAC;MACT;MACA,IAAI,CAACH,yBAAyB,CAACQ,KAAK,CAAC,CAAC;IAC1C,CAAC,MACI;MACD,MAAML,CAAC;IACX;EACJ;EACA,OAAOM,IAAI,GAAG,SAASC,sCAAsCA,CAACC,iBAAiB,EAAE;IAAE,OAAO,KAAKA,iBAAiB,IAAId,8BAA8B,EAAE,CAAC;EAAE,CAAC;EACxJ,OAAOe,KAAK,GAAG,aAActM,EAAE,CAACuM,kBAAkB,CAAC;IAAEC,KAAK,EAAEjB,8BAA8B;IAAEkB,OAAO,EAAElB,8BAA8B,CAACY;EAAK,CAAC,CAAC;AAC/I;AACA,CAAC,MAAM;EAAE,CAAC,OAAOO,SAAS,KAAK,WAAW,IAAIA,SAAS,KAAK1M,EAAE,CAAC2M,iBAAiB,CAACpB,8BAA8B,EAAE,CAAC;IAC1GqB,IAAI,EAAE1L;EACV,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC;AAAE,CAAC,EAAE,CAAC;;AAEzB;AACA;AACA;AACA;AACA;AACA,MAAM2L,gBAAgB,CAAC;EACnBC,YAAY;EACZ;AACJ;AACA;EACIC,YAAY;EACZ;AACJ;AACA;EACIC,iBAAiB;EACjB;AACJ;AACA;EACIC,aAAa;EACb;AACJ;AACA;EACIC,UAAU;EACV;AACJ;AACA;EACIC,iBAAiB;EACjBC,SAAS;EACTC,YAAY,GAAG,KAAK;EACpB;EACAC,kBAAkB,GAAGvM,QAAQ,CAACsK,wBAAwB,EAAE;IAAEkC,QAAQ,EAAE;EAAK,CAAC,CAAC;EAC3E;EACAC,OAAO,GAAG,IAAI,CAACF,kBAAkB,GAAG,IAAIlM,WAAW,CAAC,CAAC,GAAGL,QAAQ,CAACC,MAAM,CAAC;EACxE;EACA;EACA;EACA;EACA;EACA;EACA;EACAyM,OAAO,GAAG1M,QAAQ,CAACM,cAAc,CAAC;EAClCqM,WAAW,GAAG,IAAI,CAACD,OAAO;EAC1BE,YAAY,GAAG5M,QAAQ,CAACQ,qBAAqB,CAAC;EAC9CqM,eAAe,GAAG7M,QAAQ,CAACwK,8BAA8B,CAAC;EAC1DsC,eAAe,GAAG9M,QAAQ,CAACU,iBAAiB,CAAC;EAC7CqM,SAAS,GAAG/M,QAAQ,CAACY,yBAAyB,CAAC;EAC/CoM,mBAAmB,GAAGhN,QAAQ,CAACc,gBAAgB,CAAC;EAChDmM,wBAAwB,GAAGjN,QAAQ,CAACgB,yBAAyB,CAAC;EAC9DkM,iBAAiB,GAAG,IAAI,CAACJ,eAAe,GAAG,IAAI,GAAG,KAAK;EACvDK,UAAU,GAAGnN,QAAQ,CAACqK,0BAA0B,EAAE;IAAEmC,QAAQ,EAAE;EAAK,CAAC,CAAC,IAAI,IAAI,CAACU,iBAAiB;EAC/FE,aAAa,GAAG,IAAIjG,YAAY,CAAC,CAAC;EAClC;EACAkG,MAAM,GAAG,IAAI,CAACd,kBAAkB,GAAG,IAAI,GAAG,IAAI,CAACE,OAAO;EACtD;EACAzE,WAAWA,CAAC+D,YAAY,EAAE;IACtB,IAAI,CAACA,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACK,iBAAiB,GAAGL,YAAY,CAACK,iBAAiB;IACvD,IAAI,CAACD,UAAU,GAAGJ,YAAY,CAACuB,QAAQ;IACvC,IAAI,CAACtB,YAAY,GAAG/K,YAAY,CAAC,IAAI,CAACkL,UAAU,CAACD,aAAa,CAAC;IAC/D,IAAI,CAACD,iBAAiB,GAAGF,YAAY,CAACwB,QAAQ;IAC9C,IAAI,CAACrB,aAAa,GAAG,IAAI,CAACC,UAAU,CAACD,aAAa;IAClD,IAAI,CAACH,YAAY,GAAGA,YAAY;IAChC,IAAI,IAAI,CAACoB,UAAU,EAAE;MACjB,IAAI,CAACR,WAAW,CAACa,iBAAiB,CAACC,GAAG,CAAC,IAAI,CAAC1B,YAAY,CAAC2B,QAAQ,CAAC;MAClE,IAAI,CAACX,SAAS,EAAEY,MAAM,CAAC,CAAC,CAAC,sCAAsC,CAAC;MAChE,IAAI,CAACZ,SAAS,EAAEY,MAAM,CAAC,CAAC,CAAC,mDAAmD,CAAC;IACjF;IACA,IAAI,CAAC5B,YAAY,CAAC2B,QAAQ,CAACE,SAAS,CAAC,MAAM;MACvC,IAAI,CAACjB,WAAW,CAACa,iBAAiB,CAACK,MAAM,CAAC,IAAI,CAAC9B,YAAY,CAAC2B,QAAQ,CAAC;IACzE,CAAC,CAAC;IACF;IACA;IACA,IAAI,CAACjB,OAAO,CAAC1B,iBAAiB,CAAC,MAAM;MACjC,IAAI,CAACqC,aAAa,CAACK,GAAG,CAAC,IAAI,CAAChB,OAAO,CAACqB,OAAO,CAACC,SAAS,CAAC;QAClDC,IAAI,EAAGC,KAAK,IAAK;UACb,MAAMA,KAAK;QACf;MACJ,CAAC,CAAC,CAAC;IACP,CAAC,CAAC;EACN;EACA;AACJ;AACA;EACIjF,aAAaA,CAACkF,cAAc,GAAG,IAAI,EAAE;IACjC,IAAI,CAACjB,wBAAwB,CAACkB,KAAK,CAAC,CAAC;IACrC,MAAMC,sBAAsB,GAAG,IAAI,CAACrC,YAAY,CAACK,iBAAiB,CAAC8B,cAAc;IACjF,IAAI;MACA,IAAI,CAACA,cAAc,EAAE;QACjB,IAAI,CAACnC,YAAY,CAACK,iBAAiB,CAAC8B,cAAc,GAAG,MAAM,CAAE,CAAC;MAClE;MACA,IAAI,IAAI,CAACpB,eAAe,EAAE;QACtB,IAAI;UACA,IAAI,CAACH,WAAW,CAACa,iBAAiB,CAACC,GAAG,CAAC,IAAI,CAAC1B,YAAY,CAAC2B,QAAQ,CAAC;UAClE,IAAI,CAAChB,OAAO,CAAC2B,IAAI,CAAC,CAAC;QACvB,CAAC,SACO;UACJ,IAAI,CAAC,IAAI,CAAClB,UAAU,EAAE;YAClB,IAAI,CAACR,WAAW,CAACa,iBAAiB,CAACK,MAAM,CAAC,IAAI,CAAC9B,YAAY,CAAC2B,QAAQ,CAAC;UACzE;QACJ;MACJ,CAAC,MACI;QACD;QACA;QACA,IAAI,CAACjB,OAAO,CAAC6B,GAAG,CAAC,MAAM;UACnB;UACA,IAAI,CAACtB,mBAAmB,CAACmB,KAAK,CAAC,CAAC;UAChC,IAAI,CAAC/B,iBAAiB,CAACpD,aAAa,CAAC,CAAC;UACtC,IAAI,CAACkF,cAAc,CAAC,CAAC;QACzB,CAAC,CAAC;MACN;IACJ,CAAC,SACO;MACJ,IAAI,CAACnC,YAAY,CAACK,iBAAiB,CAAC8B,cAAc,GAAGE,sBAAsB;IAC/E;IACA,IAAI,CAACnB,wBAAwB,CAACkB,KAAK,CAAC,CAAC;EACzC;EACA;AACJ;AACA;EACID,cAAcA,CAAA,EAAG;IACb,IAAI,CAAC9B,iBAAiB,CAAC8B,cAAc,CAAC,CAAC;EAC3C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIK,iBAAiBA,CAACpB,UAAU,GAAG,IAAI,EAAE;IACjC,IAAI,IAAI,CAACZ,kBAAkB,IAAI,CAAC,IAAI,CAACO,eAAe,EAAE;MAClD,MAAM,IAAItE,KAAK,CAAC,qEAAqE,CAAC;IAC1F;IACA,IAAI2E,UAAU,KAAK,IAAI,CAACA,UAAU,EAAE;MAChC,IAAIA,UAAU,EAAE;QACZ,IAAI,CAACR,WAAW,CAACa,iBAAiB,CAACC,GAAG,CAAC,IAAI,CAAC1B,YAAY,CAAC2B,QAAQ,CAAC;MACtE,CAAC,MACI;QACD,IAAI,CAACf,WAAW,CAACa,iBAAiB,CAACK,MAAM,CAAC,IAAI,CAAC9B,YAAY,CAAC2B,QAAQ,CAAC;MACzE;IACJ;IACA,IAAI,CAACP,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACnE,aAAa,CAAC,CAAC;EACxB;EACA;AACJ;AACA;AACA;EACIwF,QAAQA,CAAA,EAAG;IACP,OAAO,CAAC,IAAI,CAAC5B,YAAY,CAAC6B,eAAe,CAACC,KAAK;EACnD;EACA;AACJ;AACA;AACA;AACA;AACA;EACIC,UAAUA,CAAA,EAAG;IACT,IAAI,IAAI,CAACH,QAAQ,CAAC,CAAC,EAAE;MACjB,OAAO/G,OAAO,CAAC6B,OAAO,CAAC,KAAK,CAAC;IACjC;IACA,OAAO,IAAI7B,OAAO,CAAC,CAAC6B,OAAO,EAAE5B,MAAM,KAAK;MACpC,IAAI,CAACmF,eAAe,CAAClC,yBAAyB,CAAC8C,GAAG,CAAC/F,MAAM,CAAC;MAC1D,IAAI,CAACgF,OAAO,CAACiC,UAAU,CAAC,CAAC,CAACC,IAAI,CAAC,MAAM;QACjC,IAAI,CAAC/B,eAAe,CAAClC,yBAAyB,CAACkD,MAAM,CAACnG,MAAM,CAAC;QAC7D4B,OAAO,CAAC,IAAI,CAAC;MACjB,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EACA;AACJ;AACA;EACIL,cAAcA,CAAA,EAAG;IACb,MAAMC,WAAW,GAAG,EAAE;IACtB,MAAMN,KAAK,GAAG,IAAI,CAACmD,YAAY,CAAC2B,QAAQ,CAAC,QAAQ,CAAC;IAClD/N,eAAe,CAACiJ,KAAK,EAAEM,WAAW,CAAC;IACnC,MAAMC,kBAAkB,GAAG,EAAE;IAC7B,KAAK,MAAMrB,KAAK,IAAIoB,WAAW,EAAE;MAC7BC,kBAAkB,CAACE,IAAI,CAAC,IAAIxB,iBAAiB,CAACC,KAAK,EAAE,IAAI,CAAC,CAAC;IAC/D;IACA,OAAOL,OAAO,CAAC6B,OAAO,CAACH,kBAAkB,CAAC;EAC9C;EACA0F,YAAYA,CAAA,EAAG;IACX,IAAI,IAAI,CAACxC,SAAS,KAAKyC,SAAS,EAAE;MAC9B,IAAI,CAACzC,SAAS,GAAG,IAAI,CAACN,YAAY,CAACgD,QAAQ,CAACC,GAAG,CAAC9N,gBAAgB,EAAE,IAAI,CAAC;IAC3E;IACA,OAAO,IAAI,CAACmL,SAAS;EACzB;EACA;AACJ;AACA;EACI4C,iBAAiBA,CAAA,EAAG;IAChB,MAAMC,QAAQ,GAAG,IAAI,CAACL,YAAY,CAAC,CAAC;IACpC,IAAIK,QAAQ,IAAIA,QAAQ,CAACD,iBAAiB,EAAE;MACxC,OAAOC,QAAQ,CAACD,iBAAiB,CAAC,CAAC;IACvC;IACA,OAAO,IAAI,CAACN,UAAU,CAAC,CAAC;EAC5B;EACA;AACJ;AACA;EACIQ,OAAOA,CAAA,EAAG;IACN,IAAI,CAAC/B,aAAa,CAACgC,WAAW,CAAC,CAAC;IAChC,IAAI,CAACzC,WAAW,CAACa,iBAAiB,CAACK,MAAM,CAAC,IAAI,CAAC9B,YAAY,CAAC2B,QAAQ,CAAC;IACrE,IAAI,CAAC,IAAI,CAACpB,YAAY,EAAE;MACpB,IAAI,CAACP,YAAY,CAACoD,OAAO,CAAC,CAAC;MAC3B,IAAI,CAAC7C,YAAY,GAAG,IAAI;IAC5B;EACJ;AACJ;AAEA,MAAM/E,KAAK,GAAG,OAAOC,IAAI,KAAK,WAAW,GAAGA,IAAI,GAAG,IAAI;AACvD,MAAM6H,mBAAmB,GAAG9H,KAAK,IAAIA,KAAK,CAACA,KAAK,CAACK,UAAU,CAAC,eAAe,CAAC,CAAC;AAC7E,MAAM0H,wCAAwC,GAAG;AACjD,wEAAwE;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,kBAAkBA,CAAA,EAAG;EAC1B,IAAIF,mBAAmB,EAAE;IACrB,OAAOA,mBAAmB,CAACE,kBAAkB,CAAC,CAAC;EACnD;EACA,MAAM,IAAI/G,KAAK,CAAC8G,wCAAwC,CAAC;AAC7D;AACA,SAASE,0BAA0BA,CAAA,EAAG;EAClC,IAAIH,mBAAmB,EAAE;IACrBA,mBAAmB,CAACE,kBAAkB,CAAC,CAAC;EAC5C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASE,SAASA,CAACnI,EAAE,EAAEoI,OAAO,EAAE;EAC5B,IAAIL,mBAAmB,EAAE;IACrB,OAAOA,mBAAmB,CAACI,SAAS,CAACnI,EAAE,EAAEoI,OAAO,CAAC;EACrD;EACA,MAAM,IAAIlH,KAAK,CAAC8G,wCAAwC,CAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASjB,IAAIA,CAACsB,MAAM,GAAG,CAAC,EAAEC,WAAW,GAAG;EACpCC,iCAAiC,EAAE;AACvC,CAAC,EAAE;EACC,IAAIR,mBAAmB,EAAE;IACrB,OAAOA,mBAAmB,CAAChB,IAAI,CAACsB,MAAM,EAAEC,WAAW,CAAC;EACxD;EACA,MAAM,IAAIpH,KAAK,CAAC8G,wCAAwC,CAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASnB,KAAKA,CAAC2B,QAAQ,EAAE;EACrB,IAAIT,mBAAmB,EAAE;IACrB,OAAOA,mBAAmB,CAAClB,KAAK,CAAC2B,QAAQ,CAAC;EAC9C;EACA,MAAM,IAAItH,KAAK,CAAC8G,wCAAwC,CAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,SAASS,oBAAoBA,CAAA,EAAG;EAC5B,IAAIV,mBAAmB,EAAE;IACrB,OAAOA,mBAAmB,CAACU,oBAAoB,CAAC,CAAC;EACrD;EACA,MAAM,IAAIvH,KAAK,CAAC8G,wCAAwC,CAAC;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA,SAASU,eAAeA,CAAA,EAAG;EACvB,IAAIX,mBAAmB,EAAE;IACrB,OAAOA,mBAAmB,CAACW,eAAe,CAAC,CAAC;EAChD;EACA,MAAM,IAAIxH,KAAK,CAAC8G,wCAAwC,CAAC;AAC7D;AAEA,IAAIW,gBAAgB,GAAG,CAAC;AACxB,MAAMC,iBAAiB,CAAC;EACpBC,WAAW,GAAG,IAAIC,GAAG,CAAC,CAAC;EACvB;AACJ;AACA;AACA;EACIC,gBAAgBA,CAACC,aAAa,EAAEC,WAAW,EAAEC,QAAQ,EAAE;IACnD,MAAMC,KAAK,GAAG,CAAC,CAAC;IAChB,IAAIF,WAAW,EAAE;MACbG,WAAW,CAACH,WAAW,CAAC,CAACI,OAAO,CAAEC,IAAI,IAAMH,KAAK,CAACG,IAAI,CAAC,GAAGL,WAAW,CAACK,IAAI,CAAE,CAAC;IACjF;IACA,IAAIJ,QAAQ,CAACK,GAAG,EAAE;MACd,IAAIL,QAAQ,CAACM,MAAM,IAAIN,QAAQ,CAAC/C,GAAG,EAAE;QACjC,MAAM,IAAIjF,KAAK,CAAC,6BAA6BpH,UAAU,CAACkP,aAAa,CAAC,oBAAoB,CAAC;MAC/F;MACAS,WAAW,CAACN,KAAK,EAAED,QAAQ,CAACK,GAAG,CAAC;IACpC;IACA,IAAIL,QAAQ,CAACM,MAAM,EAAE;MACjBE,cAAc,CAACP,KAAK,EAAED,QAAQ,CAACM,MAAM,EAAE,IAAI,CAACX,WAAW,CAAC;IAC5D;IACA,IAAIK,QAAQ,CAAC/C,GAAG,EAAE;MACdwD,WAAW,CAACR,KAAK,EAAED,QAAQ,CAAC/C,GAAG,CAAC;IACpC;IACA,OAAO,IAAI6C,aAAa,CAACG,KAAK,CAAC;EACnC;AACJ;AACA,SAASO,cAAcA,CAACE,QAAQ,EAAEJ,MAAM,EAAEK,UAAU,EAAE;EAClD,MAAMC,aAAa,GAAG,IAAIxG,GAAG,CAAC,CAAC;EAC/B,KAAK,MAAMgG,IAAI,IAAIE,MAAM,EAAE;IACvB,MAAMO,WAAW,GAAGP,MAAM,CAACF,IAAI,CAAC;IAChC,IAAIU,KAAK,CAACC,OAAO,CAACF,WAAW,CAAC,EAAE;MAC5BA,WAAW,CAACV,OAAO,CAAEjC,KAAK,IAAK;QAC3B0C,aAAa,CAAC3D,GAAG,CAAC+D,YAAY,CAACZ,IAAI,EAAElC,KAAK,EAAEyC,UAAU,CAAC,CAAC;MAC5D,CAAC,CAAC;IACN,CAAC,MACI;MACDC,aAAa,CAAC3D,GAAG,CAAC+D,YAAY,CAACZ,IAAI,EAAES,WAAW,EAAEF,UAAU,CAAC,CAAC;IAClE;EACJ;EACA,KAAK,MAAMP,IAAI,IAAIM,QAAQ,EAAE;IACzB,MAAMO,SAAS,GAAGP,QAAQ,CAACN,IAAI,CAAC;IAChC,IAAIU,KAAK,CAACC,OAAO,CAACE,SAAS,CAAC,EAAE;MAC1BP,QAAQ,CAACN,IAAI,CAAC,GAAGa,SAAS,CAACC,MAAM,CAAEhD,KAAK,IAAK,CAAC0C,aAAa,CAACO,GAAG,CAACH,YAAY,CAACZ,IAAI,EAAElC,KAAK,EAAEyC,UAAU,CAAC,CAAC,CAAC;IAC3G,CAAC,MACI;MACD,IAAIC,aAAa,CAACO,GAAG,CAACH,YAAY,CAACZ,IAAI,EAAEa,SAAS,EAAEN,UAAU,CAAC,CAAC,EAAE;QAC9DD,QAAQ,CAACN,IAAI,CAAC,GAAG9B,SAAS;MAC9B;IACJ;EACJ;AACJ;AACA,SAASmC,WAAWA,CAACC,QAAQ,EAAEzD,GAAG,EAAE;EAChC,KAAK,MAAMmD,IAAI,IAAInD,GAAG,EAAE;IACpB,MAAMmE,QAAQ,GAAGnE,GAAG,CAACmD,IAAI,CAAC;IAC1B,MAAMa,SAAS,GAAGP,QAAQ,CAACN,IAAI,CAAC;IAChC,IAAIa,SAAS,IAAI,IAAI,IAAIH,KAAK,CAACC,OAAO,CAACE,SAAS,CAAC,EAAE;MAC/CP,QAAQ,CAACN,IAAI,CAAC,GAAGa,SAAS,CAACI,MAAM,CAACD,QAAQ,CAAC;IAC/C,CAAC,MACI;MACDV,QAAQ,CAACN,IAAI,CAAC,GAAGgB,QAAQ;IAC7B;EACJ;AACJ;AACA,SAASb,WAAWA,CAACG,QAAQ,EAAEL,GAAG,EAAE;EAChC,KAAK,MAAMD,IAAI,IAAIC,GAAG,EAAE;IACpBK,QAAQ,CAACN,IAAI,CAAC,GAAGC,GAAG,CAACD,IAAI,CAAC;EAC9B;AACJ;AACA,SAASY,YAAYA,CAACM,QAAQ,EAAEL,SAAS,EAAEN,UAAU,EAAE;EACnD,IAAIY,YAAY,GAAG,CAAC;EACpB,MAAMC,SAAS,GAAG,IAAI5B,GAAG,CAAC,CAAC;EAC3B,MAAM6B,QAAQ,GAAGA,CAACC,GAAG,EAAExD,KAAK,KAAK;IAC7B,IAAIA,KAAK,KAAK,IAAI,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC7C,IAAIsD,SAAS,CAACL,GAAG,CAACjD,KAAK,CAAC,EAAE;QACtB,OAAOsD,SAAS,CAAChD,GAAG,CAACN,KAAK,CAAC;MAC/B;MACA;MACA;MACAsD,SAAS,CAACnB,GAAG,CAACnC,KAAK,EAAE,QAAQqD,YAAY,EAAE,EAAE,CAAC;MAC9C;MACA,OAAOrD,KAAK;IAChB,CAAC,MACI,IAAI,OAAOA,KAAK,KAAK,UAAU,EAAE;MAClCA,KAAK,GAAGyD,mBAAmB,CAACzD,KAAK,EAAEyC,UAAU,CAAC;IAClD;IACA,OAAOzC,KAAK;EAChB,CAAC;EACD,OAAO,GAAGoD,QAAQ,IAAIM,IAAI,CAACC,SAAS,CAACZ,SAAS,EAAEQ,QAAQ,CAAC,EAAE;AAC/D;AACA,SAASE,mBAAmBA,CAACG,GAAG,EAAEnB,UAAU,EAAE;EAC1C,IAAIoB,EAAE,GAAGpB,UAAU,CAACnC,GAAG,CAACsD,GAAG,CAAC;EAC5B,IAAI,CAACC,EAAE,EAAE;IACLA,EAAE,GAAG,GAAGnR,UAAU,CAACkR,GAAG,CAAC,GAAGrC,gBAAgB,EAAE,EAAE;IAC9CkB,UAAU,CAACN,GAAG,CAACyB,GAAG,EAAEC,EAAE,CAAC;EAC3B;EACA,OAAOA,EAAE;AACb;AACA,SAAS7B,WAAWA,CAAC8B,GAAG,EAAE;EACtB,MAAM/B,KAAK,GAAG,EAAE;EAChB;EACAgC,MAAM,CAACC,IAAI,CAACF,GAAG,CAAC,CAAC7B,OAAO,CAAEC,IAAI,IAAK;IAC/B,IAAI,CAACA,IAAI,CAAC+B,UAAU,CAAC,GAAG,CAAC,EAAE;MACvBlC,KAAK,CAACpH,IAAI,CAACuH,IAAI,CAAC;IACpB;EACJ,CAAC,CAAC;EACF;EACA,IAAIgC,KAAK,GAAGJ,GAAG;EACf,OAAQI,KAAK,GAAGH,MAAM,CAACI,cAAc,CAACD,KAAK,CAAC,EAAG;IAC3CH,MAAM,CAACC,IAAI,CAACE,KAAK,CAAC,CAACjC,OAAO,CAAEmC,SAAS,IAAK;MACtC,MAAMC,IAAI,GAAGN,MAAM,CAACO,wBAAwB,CAACJ,KAAK,EAAEE,SAAS,CAAC;MAC9D,IAAI,CAACA,SAAS,CAACH,UAAU,CAAC,GAAG,CAAC,IAAII,IAAI,IAAI,KAAK,IAAIA,IAAI,EAAE;QACrDtC,KAAK,CAACpH,IAAI,CAACyJ,SAAS,CAAC;MACzB;IACJ,CAAC,CAAC;EACN;EACA,OAAOrC,KAAK;AAChB;AAEA,MAAMwC,UAAU,GAAG,IAAIvR,uBAAuB,CAAC,CAAC;AAChD;AACA;AACA;AACA,MAAMwR,gBAAgB,CAAC;EACnBC,SAAS,GAAG,IAAI/C,GAAG,CAAC,CAAC;EACrBgD,QAAQ,GAAG,IAAIhD,GAAG,CAAC,CAAC;EACpBiD,WAAWA,CAACxH,IAAI,EAAE2E,QAAQ,EAAE;IACxB,MAAM2C,SAAS,GAAG,IAAI,CAACA,SAAS,CAACnE,GAAG,CAACnD,IAAI,CAAC,IAAI,EAAE;IAChDsH,SAAS,CAAC9J,IAAI,CAACmH,QAAQ,CAAC;IACxB,IAAI,CAAC2C,SAAS,CAACtC,GAAG,CAAChF,IAAI,EAAEsH,SAAS,CAAC;IACnC,IAAI,CAACC,QAAQ,CAACvF,MAAM,CAAChC,IAAI,CAAC;EAC9B;EACAyH,YAAYA,CAACH,SAAS,EAAE;IACpB,IAAI,CAACA,SAAS,CAAChI,KAAK,CAAC,CAAC;IACtBgI,SAAS,CAACxC,OAAO,CAAC,CAAC,CAAC9E,IAAI,EAAE2E,QAAQ,CAAC,KAAK;MACpC,IAAI,CAAC6C,WAAW,CAACxH,IAAI,EAAE2E,QAAQ,CAAC;IACpC,CAAC,CAAC;EACN;EACA+C,aAAaA,CAAC1H,IAAI,EAAE;IAChB,MAAM2H,WAAW,GAAGP,UAAU,CAACO,WAAW,CAAC3H,IAAI,CAAC;IAChD;IACA;IACA;IACA;IACA;IACA,KAAK,IAAI4H,CAAC,GAAGD,WAAW,CAACpK,MAAM,GAAG,CAAC,EAAEqK,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC9C,MAAMC,UAAU,GAAGF,WAAW,CAACC,CAAC,CAAC;MACjC,MAAME,WAAW,GAAGD,UAAU,YAAYpS,SAAS,IAC/CoS,UAAU,YAAYnS,SAAS,IAC/BmS,UAAU,YAAYrS,IAAI,IAC1BqS,UAAU,YAAYlS,QAAQ;MAClC,IAAImS,WAAW,EAAE;QACb,OAAOD,UAAU,YAAY,IAAI,CAAC7H,IAAI,GAAG6H,UAAU,GAAG,IAAI;MAC9D;IACJ;IACA,OAAO,IAAI;EACf;EACApK,OAAOA,CAACuC,IAAI,EAAE;IACV,IAAIuH,QAAQ,GAAG,IAAI,CAACA,QAAQ,CAACpE,GAAG,CAACnD,IAAI,CAAC,IAAI,IAAI;IAC9C,IAAI,CAACuH,QAAQ,EAAE;MACXA,QAAQ,GAAG,IAAI,CAACG,aAAa,CAAC1H,IAAI,CAAC;MACnC,IAAIuH,QAAQ,EAAE;QACV,MAAMD,SAAS,GAAG,IAAI,CAACA,SAAS,CAACnE,GAAG,CAACnD,IAAI,CAAC;QAC1C,IAAIsH,SAAS,EAAE;UACX,MAAMS,SAAS,GAAG,IAAI1D,iBAAiB,CAAC,CAAC;UACzCiD,SAAS,CAACxC,OAAO,CAAEH,QAAQ,IAAK;YAC5B4C,QAAQ,GAAGQ,SAAS,CAACvD,gBAAgB,CAAC,IAAI,CAACxE,IAAI,EAAEuH,QAAQ,EAAE5C,QAAQ,CAAC;UACxE,CAAC,CAAC;QACN;MACJ;MACA,IAAI,CAAC4C,QAAQ,CAACvC,GAAG,CAAChF,IAAI,EAAEuH,QAAQ,CAAC;IACrC;IACA,OAAOA,QAAQ;EACnB;AACJ;AACA,MAAMS,iBAAiB,SAASX,gBAAgB,CAAC;EAC7C,IAAIrH,IAAIA,CAAA,EAAG;IACP,OAAOvK,SAAS;EACpB;AACJ;AACA,MAAMwS,iBAAiB,SAASZ,gBAAgB,CAAC;EAC7C,IAAIrH,IAAIA,CAAA,EAAG;IACP,OAAOtK,SAAS;EACpB;AACJ;AACA,MAAMwS,YAAY,SAASb,gBAAgB,CAAC;EACxC,IAAIrH,IAAIA,CAAA,EAAG;IACP,OAAOxK,IAAI;EACf;AACJ;AACA,MAAM2S,gBAAgB,SAASd,gBAAgB,CAAC;EAC5C,IAAIrH,IAAIA,CAAA,EAAG;IACP,OAAOrK,QAAQ;EACnB;AACJ;AAEA,IAAIyS,qBAAqB;AACzB,CAAC,UAAUA,qBAAqB,EAAE;EAC9BA,qBAAqB,CAACA,qBAAqB,CAAC,aAAa,CAAC,GAAG,CAAC,CAAC,GAAG,aAAa;EAC/EA,qBAAqB,CAACA,qBAAqB,CAAC,mBAAmB,CAAC,GAAG,CAAC,CAAC,GAAG,mBAAmB;AAC/F,CAAC,EAAEA,qBAAqB,KAAKA,qBAAqB,GAAG,CAAC,CAAC,CAAC,CAAC;AACzD,SAASC,uBAAuBA,CAACxF,KAAK,EAAE;EACpC,OAAQA,KAAK,KAAKuF,qBAAqB,CAACE,WAAW,IAAIzF,KAAK,KAAKuF,qBAAqB,CAACG,iBAAiB;AAC5G;AACA,SAASC,4BAA4BA,CAACC,KAAK,EAAEC,QAAQ,EAAEjH,QAAQ,EAAE;EAC7DgH,KAAK,CAAC3D,OAAO,CAAE9E,IAAI,IAAK;IACpB,IAAI,CAACxJ,wBAAwB,CAACwJ,IAAI,CAAC,EAAE;MACjC,MAAM2I,SAAS,GAAGD,QAAQ,CAACjL,OAAO,CAACuC,IAAI,CAAC;MACxC,IAAI2I,SAAS,KAAKA,SAAS,CAACC,UAAU,IAAI,IAAI,IAAID,SAAS,CAACC,UAAU,CAAC,EAAE;QACrE,MAAM,IAAIjM,KAAK,CAAChD,sCAAsC,CAACqG,IAAI,EAAEyB,QAAQ,CAAC,CAAC;MAC3E;IACJ;EACJ,CAAC,CAAC;AACN;AACA,MAAMoH,eAAe,CAAC;EAClBC,QAAQ;EACRC,qBAAqB;EACrBC,gCAAgC,GAAG,IAAI;EACvC;EACAC,YAAY,GAAG,EAAE;EACjBC,OAAO,GAAG,EAAE;EACZC,SAAS,GAAG,EAAE;EACdC,OAAO,GAAG,EAAE;EACZ;EACAC,iBAAiB,GAAG,IAAItK,GAAG,CAAC,CAAC;EAC7BuK,iBAAiB,GAAG,IAAIvK,GAAG,CAAC,CAAC;EAC7BwK,YAAY,GAAG,IAAIxK,GAAG,CAAC,CAAC;EACxB;EACA;EACAyK,2BAA2B,GAAG,IAAIzK,GAAG,CAAC,CAAC;EACvC;EACA0K,cAAc,GAAG,IAAI1K,GAAG,CAAC,CAAC;EAC1B2K,cAAc,GAAG,IAAI3K,GAAG,CAAC,CAAC;EAC1B;EACA4K,iBAAiB,GAAG,IAAI5K,GAAG,CAAC,CAAC;EAC7B;EACA;EACA6K,uBAAuB,GAAG,IAAIrF,GAAG,CAAC,CAAC;EACnCsF,SAAS,GAAGC,aAAa,CAAC,CAAC;EAC3B;EACA;EACA;EACA;EACA;EACA;EACA;EACAC,sBAAsB,GAAG,IAAIxF,GAAG,CAAC,CAAC;EAClC;EACA;EACA;EACA;EACA;EACAyF,aAAa,GAAG,IAAIzF,GAAG,CAAC,CAAC;EACzB;EACA;EACA0F,aAAa,GAAG,EAAE;EAClBC,SAAS,GAAG,IAAI;EAChBC,iBAAiB,GAAG,IAAI;EACxBC,iBAAiB,GAAG,EAAE;EACtBC,qBAAqB,GAAG,EAAE;EAC1B;EACA;EACAC,yBAAyB,GAAG,IAAI/F,GAAG,CAAC,CAAC;EACrCgG,wBAAwB,GAAG,IAAIhG,GAAG,CAAC,CAAC;EACpCiG,6BAA6B,GAAG,IAAIzL,GAAG,CAAC,CAAC;EACzC0L,cAAc;EACdC,aAAa,GAAG,IAAI;EACpBC,kBAAkB,GAAGzM,4BAA4B;EACjD0M,4BAA4B,GAAGlM,kCAAkC;EACjEvC,WAAWA,CAAC2M,QAAQ,EAAEC,qBAAqB,EAAE;IACzC,IAAI,CAACD,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACC,qBAAqB,GAAGA,qBAAqB;IAClD,MAAM8B,iBAAiB,CAAC;IAExB,IAAI,CAACJ,cAAc,GAAGI,iBAAiB;EAC3C;EACAC,oBAAoBA,CAAC3B,SAAS,EAAE;IAC5B,IAAI,CAACgB,iBAAiB,GAAGhB,SAAS;IAClC,IAAI,CAACe,SAAS,GAAG,IAAI;EACzB;EACAa,sBAAsBA,CAACC,SAAS,EAAE;IAC9B;IACA,IAAIA,SAAS,CAAC/B,YAAY,KAAKhG,SAAS,EAAE;MACtC;MACAuF,4BAA4B,CAACwC,SAAS,CAAC/B,YAAY,EAAE,IAAI,CAACY,SAAS,CAAClB,SAAS,EAAE,uCAAuC,CAAC;MACvH,IAAI,CAACsC,cAAc,CAACD,SAAS,CAAC/B,YAAY,EAAEb,qBAAqB,CAACE,WAAW,CAAC;MAC9E,IAAI,CAACW,YAAY,CAACzL,IAAI,CAAC,GAAGwN,SAAS,CAAC/B,YAAY,CAAC;IACrD;IACA;IACA,IAAI+B,SAAS,CAAC9B,OAAO,KAAKjG,SAAS,EAAE;MACjC,IAAI,CAACiI,0BAA0B,CAACF,SAAS,CAAC9B,OAAO,CAAC;MAClD,IAAI,CAACA,OAAO,CAAC1L,IAAI,CAAC,GAAGwN,SAAS,CAAC9B,OAAO,CAAC;IAC3C;IACA,IAAI8B,SAAS,CAAC7B,SAAS,KAAKlG,SAAS,EAAE;MACnC,IAAI,CAACkG,SAAS,CAAC3L,IAAI,CAAC,GAAGwN,SAAS,CAAC7B,SAAS,CAAC;IAC/C;IACA,IAAI6B,SAAS,CAAC5B,OAAO,KAAKnG,SAAS,EAAE;MACjC,IAAI,CAACmG,OAAO,CAAC5L,IAAI,CAAC,GAAGwN,SAAS,CAAC5B,OAAO,CAAC;IAC3C;IACA,IAAI,CAACuB,kBAAkB,GAAGK,SAAS,CAACL,kBAAkB,IAAIzM,4BAA4B;IACtF,IAAI,CAAC0M,4BAA4B,GAC7BI,SAAS,CAACG,wBAAwB,IAAIzM,kCAAkC;EAChF;EACA0M,cAAcA,CAACC,QAAQ,EAAE1G,QAAQ,EAAE;IAC/B,IAAI5O,iCAAiC,EAAE;MACnCE,YAAY,CAACqV,kBAAkB,CAACD,QAAQ,CAAC;IAC7C;IACA,IAAI,CAAC1B,iBAAiB,CAAC/H,GAAG,CAACyJ,QAAQ,CAAC;IACpC;IACA,IAAI,CAACxB,SAAS,CAAC0B,MAAM,CAAC/D,WAAW,CAAC6D,QAAQ,EAAE1G,QAAQ,CAAC;IACrD,MAAMU,QAAQ,GAAG,IAAI,CAACwE,SAAS,CAAC0B,MAAM,CAAC9N,OAAO,CAAC4N,QAAQ,CAAC;IACxD,IAAIhG,QAAQ,KAAK,IAAI,EAAE;MACnB,MAAMmG,gBAAgB,CAACH,QAAQ,CAACI,IAAI,EAAE,UAAU,CAAC;IACrD;IACA,IAAI,CAACC,iBAAiB,CAACL,QAAQ,EAAEhG,QAAQ,CAAC;IAC1C;IACA;IACA;IACA,IAAI,CAAC6F,0BAA0B,CAAC,CAACG,QAAQ,CAAC,CAAC;EAC/C;EACAM,iBAAiBA,CAAChD,SAAS,EAAEhE,QAAQ,EAAE;IACnC,IAAI,CAACiH,+BAA+B,CAACjD,SAAS,EAAEhE,QAAQ,CAAC;IACzD,IAAI,CAACkF,SAAS,CAAClB,SAAS,CAACnB,WAAW,CAACmB,SAAS,EAAEhE,QAAQ,CAAC;IACzD,IAAI,CAAC0E,iBAAiB,CAACzH,GAAG,CAAC+G,SAAS,CAAC;IACrC;IACA;IACA,IAAI,CAACkD,uCAAuC,CAAClD,SAAS,CAAC;EAC3D;EACAmD,iBAAiBA,CAACC,SAAS,EAAEpH,QAAQ,EAAE;IACnC,IAAI,CAACiH,+BAA+B,CAACG,SAAS,EAAEpH,QAAQ,CAAC;IACzD,IAAI,CAACkF,SAAS,CAACkC,SAAS,CAACvE,WAAW,CAACuE,SAAS,EAAEpH,QAAQ,CAAC;IACzD,IAAI,CAAC2E,iBAAiB,CAAC1H,GAAG,CAACmK,SAAS,CAAC;EACzC;EACAC,YAAYA,CAACC,IAAI,EAAEtH,QAAQ,EAAE;IACzB,IAAI,CAACiH,+BAA+B,CAACK,IAAI,EAAEtH,QAAQ,CAAC;IACpD,IAAI,CAACkF,SAAS,CAACoC,IAAI,CAACzE,WAAW,CAACyE,IAAI,EAAEtH,QAAQ,CAAC;IAC/C,IAAI,CAAC4E,YAAY,CAAC3H,GAAG,CAACqK,IAAI,CAAC;EAC/B;EACAL,+BAA+BA,CAAC5L,IAAI,EAAE2E,QAAQ,EAAE;IAC5C,IAAIA,QAAQ,CAAC/C,GAAG,EAAEsK,cAAc,CAAC,YAAY,CAAC,IAC1CvH,QAAQ,CAACK,GAAG,EAAEkH,cAAc,CAAC,YAAY,CAAC,IAC1CvH,QAAQ,CAACM,MAAM,EAAEiH,cAAc,CAAC,YAAY,CAAC,EAAE;MAC/C,MAAM,IAAIvP,KAAK,CAAC,uBAAuBqD,IAAI,CAACyL,IAAI,sCAAsC,GAClF,0EAA0E,CAAC;IACnF;EACJ;EACAU,gBAAgBA,CAACvM,KAAK,EAAEwM,QAAQ,EAAE;IAC9B,IAAIC,WAAW;IACf,IAAID,QAAQ,CAACE,UAAU,KAAKrJ,SAAS,EAAE;MACnCoJ,WAAW,GAAG;QACVE,OAAO,EAAE3M,KAAK;QACd0M,UAAU,EAAEF,QAAQ,CAACE,UAAU;QAC/BE,IAAI,EAAEJ,QAAQ,CAACI,IAAI,IAAI,EAAE;QACzBC,KAAK,EAAEL,QAAQ,CAACK;MACpB,CAAC;IACL,CAAC,MACI,IAAIL,QAAQ,CAACM,QAAQ,KAAKzJ,SAAS,EAAE;MACtCoJ,WAAW,GAAG;QAAEE,OAAO,EAAE3M,KAAK;QAAE8M,QAAQ,EAAEN,QAAQ,CAACM,QAAQ;QAAED,KAAK,EAAEL,QAAQ,CAACK;MAAM,CAAC;IACxF,CAAC,MACI;MACDJ,WAAW,GAAG;QAAEE,OAAO,EAAE3M;MAAM,CAAC;IACpC;IACA,MAAM+M,aAAa,GAAG,OAAO/M,KAAK,KAAK,QAAQ,GAAGzJ,iBAAiB,CAACyJ,KAAK,CAAC,GAAG,IAAI;IACjF,MAAMgN,UAAU,GAAGD,aAAa,KAAK,IAAI,GAAG,IAAI,GAAGvW,iBAAiB,CAACuW,aAAa,CAACC,UAAU,CAAC;IAC9F,MAAMC,eAAe,GAAGD,UAAU,KAAK,MAAM,GAAG,IAAI,CAACvC,qBAAqB,GAAG,IAAI,CAACD,iBAAiB;IACnGyC,eAAe,CAACrP,IAAI,CAAC6O,WAAW,CAAC;IACjC;IACA,IAAI,CAAC9B,wBAAwB,CAACvF,GAAG,CAACpF,KAAK,EAAEyM,WAAW,CAAC;IACrD,IAAIM,aAAa,KAAK,IAAI,IAAIC,UAAU,KAAK,IAAI,IAAI,OAAOA,UAAU,KAAK,QAAQ,EAAE;MACjF,MAAME,iBAAiB,GAAG,IAAI,CAACxC,yBAAyB,CAACnH,GAAG,CAACyJ,UAAU,CAAC;MACxE,IAAIE,iBAAiB,KAAK7J,SAAS,EAAE;QACjC6J,iBAAiB,CAACtP,IAAI,CAAC6O,WAAW,CAAC;MACvC,CAAC,MACI;QACD,IAAI,CAAC/B,yBAAyB,CAACtF,GAAG,CAAC4H,UAAU,EAAE,CAACP,WAAW,CAAC,CAAC;MACjE;IACJ;EACJ;EACAU,kCAAkCA,CAAC/M,IAAI,EAAEgN,QAAQ,EAAE;IAC/C,MAAMC,GAAG,GAAGjN,IAAI,CAAC1I,YAAY,CAAC;IAC9B,MAAM4V,YAAY,GAAGA,CAAA,KAAM;MACvB,MAAM7H,QAAQ,GAAG,IAAI,CAACwE,SAAS,CAAClB,SAAS,CAAClL,OAAO,CAACuC,IAAI,CAAC;MACvD,OAAO,CAAC,CAACqF,QAAQ,CAAC8H,QAAQ,IAAI,CAAC,CAAC9H,QAAQ,CAAC+H,SAAS,EAAE7P,MAAM;IAC9D,CAAC;IACD,MAAM8P,iBAAiB,GAAG,CAAC,CAACJ,GAAG,IAAI,CAAC3W,gCAAgC,CAAC0J,IAAI,CAAC,IAAIkN,YAAY,CAAC,CAAC;IAC5F;IACA;IACA;IACA;IACA;IACA;IACA;IACA,MAAMvI,QAAQ,GAAG0I,iBAAiB,GAC5B;MAAEL,QAAQ;MAAEM,MAAM,EAAE,EAAE;MAAEF,SAAS,EAAE,EAAE;MAAED,QAAQ,EAAElK;IAAU,CAAC,GAC5D;MAAE+J;IAAS,CAAC;IAClB,IAAI,CAACrB,iBAAiB,CAAC3L,IAAI,EAAE;MAAEgF,GAAG,EAAEL;IAAS,CAAC,CAAC;IAC/C,IAAI0I,iBAAiB,IAAIJ,GAAG,CAACK,MAAM,IAAIL,GAAG,CAACK,MAAM,CAAC/P,MAAM,GAAG,CAAC,EAAE;MAC1D,IAAI,CAACqM,uBAAuB,CAAC5E,GAAG,CAAChF,IAAI,EAAEiN,GAAG,CAACK,MAAM,CAAC;IACtD;IACA;IACA,IAAI,CAACvD,sBAAsB,CAAC/E,GAAG,CAAChF,IAAI,EAAEoI,qBAAqB,CAACG,iBAAiB,CAAC;EAClF;EACMgF,yCAAyCA,CAAA,EAAG;IAAA,IAAAC,MAAA;IAAA,OAAAjR,iBAAA;MAC9C,IAAIiR,MAAI,CAAChE,2BAA2B,CAACpK,IAAI,KAAK,CAAC,EAC3C;MACJ,MAAMqO,QAAQ,GAAG,EAAE;MACnB,KAAK,MAAM9E,SAAS,IAAI6E,MAAI,CAAChE,2BAA2B,EAAE;QACtD,MAAMkE,eAAe,GAAGlX,wBAAwB,CAACmS,SAAS,CAAC;QAC3D,IAAI+E,eAAe,EAAE;UACjBD,QAAQ,CAACjQ,IAAI,CAACkQ,eAAe,CAAC,CAAC,CAAC;QACpC;MACJ;MACAF,MAAI,CAAChE,2BAA2B,CAAClK,KAAK,CAAC,CAAC;MACxC,MAAMqO,YAAY,SAAS/R,OAAO,CAACgS,GAAG,CAACH,QAAQ,CAAC;MAChD,MAAMI,gBAAgB,GAAGF,YAAY,CAACG,IAAI,CAAC,CAAC,CAAC;MAC7CN,MAAI,CAACtC,0BAA0B,CAAC2C,gBAAgB,CAAC;MACjD;MACA;MACA,KAAK,MAAMlF,SAAS,IAAIkF,gBAAgB,EAAE;QACtCL,MAAI,CAACO,6BAA6B,CAACpF,SAAS,CAAC;MACjD;IAAC;EACL;EACMqF,iBAAiBA,CAAA,EAAG;IAAA,IAAAC,MAAA;IAAA,OAAA1R,iBAAA;MACtB0R,MAAI,CAACC,6BAA6B,CAAC,CAAC;MACpC;MACA;MACA;MACA,MAAMD,MAAI,CAACV,yCAAyC,CAAC,CAAC;MACtD;MACA;MACA;MACA;MACA/E,4BAA4B,CAACyF,MAAI,CAAChF,YAAY,EAAEgF,MAAI,CAACpE,SAAS,CAAClB,SAAS,EAAE,uCAAuC,CAAC;MAClH;MACA,IAAIwF,mBAAmB,GAAGF,MAAI,CAACG,gBAAgB,CAAC,CAAC;MACjD;MACA,IAAID,mBAAmB,EAAE;QACrB,IAAIE,cAAc;QAClB,IAAI3F,QAAQ,GAAI4F,GAAG,IAAK;UACpB,IAAI,CAACD,cAAc,EAAE;YACjBA,cAAc,GAAGJ,MAAI,CAAC/K,QAAQ,CAACC,GAAG,CAAC5H,cAAc,CAAC;UACtD;UACA,OAAOK,OAAO,CAAC6B,OAAO,CAAC4Q,cAAc,CAAClL,GAAG,CAACmL,GAAG,CAAC,CAAC;QACnD,CAAC;QACD,MAAM5X,0BAA0B,CAACgS,QAAQ,CAAC;MAC9C;IAAC;EACL;EACA6F,QAAQA,CAAA,EAAG;IACP;IACA,IAAI,CAACH,gBAAgB,CAAC,CAAC;IACvB;IACA,IAAI,CAACI,iBAAiB,CAAC,CAAC;IACxB,IAAI,CAACC,qBAAqB,CAAC,CAAC;IAC5B,IAAI,CAACC,sBAAsB,CAAC,CAAC;IAC7B;IACA;IACA,IAAI,CAACC,iCAAiC,CAAC,CAAC;IACxC;IACA;IACA,IAAI,CAAC5E,sBAAsB,CAACzK,KAAK,CAAC,CAAC;IACnC,MAAMsP,cAAc,GAAG,IAAI,CAAC9F,QAAQ,CAAC5F,QAAQ;IAC7C,IAAI,CAACwH,aAAa,GAAG,IAAI9T,mBAAmB,CAAC,IAAI,CAAC6T,cAAc,EAAEmE,cAAc,EAAE,EAAE,CAAC;IACrF;IACA;IACA,IAAI,CAAClE,aAAa,CAACxH,QAAQ,CAACC,GAAG,CAACtM,qBAAqB,CAAC,CAACgY,eAAe,CAAC,CAAC;IACxE;IACA;IACA;IACA,MAAMC,QAAQ,GAAG,IAAI,CAACpE,aAAa,CAACxH,QAAQ,CAACC,GAAG,CAACrM,SAAS,EAAEE,kBAAkB,CAAC;IAC/EE,YAAY,CAAC4X,QAAQ,CAAC;IACtB,OAAO,IAAI,CAACpE,aAAa;EAC7B;EACA;AACJ;AACA;EACIqE,oBAAoBA,CAACC,UAAU,EAAE;IAC7B,IAAI,CAAC9D,0BAA0B,CAAC,CAAC8D,UAAU,CAAC,CAAC;IAC7C,IAAI,CAACZ,gBAAgB,CAAC,CAAC;IACvB,IAAI,CAACM,sBAAsB,CAAC,CAAC;IAC7B,IAAI,CAACX,6BAA6B,CAACiB,UAAU,CAAC;IAC9C,IAAI,CAACP,qBAAqB,CAAC,CAAC;EAChC;EACA;AACJ;AACA;EACUQ,qBAAqBA,CAACD,UAAU,EAAE;IAAA,IAAAE,MAAA;IAAA,OAAA3S,iBAAA;MACpC2S,MAAI,CAAChE,0BAA0B,CAAC,CAAC8D,UAAU,CAAC,CAAC;MAC7C,MAAME,MAAI,CAAClB,iBAAiB,CAAC,CAAC;MAC9BkB,MAAI,CAACR,sBAAsB,CAAC,CAAC;MAC7BQ,MAAI,CAACnB,6BAA6B,CAACiB,UAAU,CAAC;MAC9CE,MAAI,CAACT,qBAAqB,CAAC,CAAC;IAAC;EACjC;EACA;AACJ;AACA;EACIU,kBAAkBA,CAAA,EAAG;IACjB,OAAO,IAAI,CAACtF,SAAS,CAAC0B,MAAM;EAChC;EACA;AACJ;AACA;EACI6D,sBAAsBA,CAACJ,UAAU,EAAE;IAC/B,OAAOK,aAAa,CAACL,UAAU,CAACM,IAAI,CAACrG,YAAY,CAAC,CAACsG,MAAM,CAAC,CAACC,SAAS,EAAEC,WAAW,KAAK;MAClF,MAAMC,YAAY,GAAGD,WAAW,CAACE,IAAI;MACrCD,YAAY,IAAIF,SAAS,CAAChS,IAAI,CAAC,IAAIpG,wBAAwB,CAACsY,YAAY,EAAE,IAAI,CAAChF,aAAa,CAAC,CAAC;MAC9F,OAAO8E,SAAS;IACpB,CAAC,EAAE,EAAE,CAAC;EACV;EACApB,gBAAgBA,CAAA,EAAG;IACf;IACA,IAAID,mBAAmB,GAAG,KAAK;IAC/B,IAAI,CAAC9E,iBAAiB,CAACvE,OAAO,CAAE2K,WAAW,IAAK;MAC5C,IAAIjZ,wBAAwB,CAACiZ,WAAW,CAAC,EAAE;QACvC,MAAM,IAAI9S,KAAK,CAAC,cAAc8S,WAAW,CAAChE,IAAI,6BAA6B,GACvE,6EAA6E,CAAC;MACtF;MACA0C,mBAAmB,GAAGA,mBAAmB,IAAI7X,gCAAgC,CAACmZ,WAAW,CAAC;MAC1F,MAAMpK,QAAQ,GAAG,IAAI,CAACwE,SAAS,CAAClB,SAAS,CAAClL,OAAO,CAACgS,WAAW,CAAC;MAC9D,IAAIpK,QAAQ,KAAK,IAAI,EAAE;QACnB,MAAMmG,gBAAgB,CAACiE,WAAW,CAAChE,IAAI,EAAE,WAAW,CAAC;MACzD;MACA,IAAI,CAACmE,eAAe,CAACtY,YAAY,EAAEmY,WAAW,CAAC;MAC/C,IAAI1Z,iCAAiC,EAAE;QACnCE,YAAY,CAACqV,kBAAkB,CAACmE,WAAW,CAAC;MAChD;MACAjY,iBAAiB,CAACiY,WAAW,EAAEpK,QAAQ,CAAC;IAC5C,CAAC,CAAC;IACF,IAAI,CAACgE,iBAAiB,CAAC/J,KAAK,CAAC,CAAC;IAC9B,IAAI,CAACgK,iBAAiB,CAACxE,OAAO,CAAE2K,WAAW,IAAK;MAC5C,MAAMpK,QAAQ,GAAG,IAAI,CAACwE,SAAS,CAACkC,SAAS,CAACtO,OAAO,CAACgS,WAAW,CAAC;MAC9D,IAAIpK,QAAQ,KAAK,IAAI,EAAE;QACnB,MAAMmG,gBAAgB,CAACiE,WAAW,CAAChE,IAAI,EAAE,WAAW,CAAC;MACzD;MACA,IAAI,CAACmE,eAAe,CAAClY,WAAW,EAAE+X,WAAW,CAAC;MAC9C7X,iBAAiB,CAAC6X,WAAW,EAAEpK,QAAQ,CAAC;IAC5C,CAAC,CAAC;IACF,IAAI,CAACiE,iBAAiB,CAAChK,KAAK,CAAC,CAAC;IAC9B,IAAI,CAACiK,YAAY,CAACzE,OAAO,CAAE2K,WAAW,IAAK;MACvC,MAAMpK,QAAQ,GAAG,IAAI,CAACwE,SAAS,CAACoC,IAAI,CAACxO,OAAO,CAACgS,WAAW,CAAC;MACzD,IAAIpK,QAAQ,KAAK,IAAI,EAAE;QACnB,MAAMmG,gBAAgB,CAACiE,WAAW,CAAChE,IAAI,EAAE,MAAM,CAAC;MACpD;MACA,IAAI,CAACmE,eAAe,CAAC9X,YAAY,EAAE2X,WAAW,CAAC;MAC/CzX,YAAY,CAACyX,WAAW,EAAEpK,QAAQ,CAAC;IACvC,CAAC,CAAC;IACF,IAAI,CAACkE,YAAY,CAACjK,KAAK,CAAC,CAAC;IACzB,OAAO6O,mBAAmB;EAC9B;EACAM,qBAAqBA,CAAA,EAAG;IACpB,IAAI,IAAI,CAAC9E,iBAAiB,CAACvK,IAAI,GAAG,CAAC,EAAE;MACjC;MACA;MACA;MACA,MAAMyQ,gBAAgB,GAAG,IAAI,CAACpF,cAAc,CAACvS,WAAW,CAAC;MACzD,MAAM4X,eAAe,GAAG,IAAI,CAACC,iCAAiC,CAACF,gBAAgB,CAAC3G,OAAO,CAAC;MACxF,IAAI4G,eAAe,CAAC1Q,IAAI,GAAG,CAAC,EAAE;QAC1B0Q,eAAe,CAAChL,OAAO,CAAEkK,UAAU,IAAK;UACpC,IAAI,CAACjZ,iCAAiC,EAAE;YACpC,IAAI,CAACia,qBAAqB,CAAChB,UAAU,EAAE9W,WAAW,EAAE,yBAAyB,CAAC;YAC9E8W,UAAU,CAAC9W,WAAW,CAAC,CAAC+X,uBAAuB,GAAG,IAAI;UAC1D,CAAC,MACI;YACDha,YAAY,CAACqV,kBAAkB,CAAC0D,UAAU,CAAC;UAC/C;QACJ,CAAC,CAAC;MACN;IACJ;IACA,MAAMkB,aAAa,GAAG,IAAI3L,GAAG,CAAC,CAAC;IAC/B,MAAM4L,gBAAgB,GAAInB,UAAU,IAAK;MACrC,IAAI,CAACkB,aAAa,CAACpK,GAAG,CAACkJ,UAAU,CAAC,EAAE;QAChC,MAAMoB,eAAe,GAAG/H,uBAAuB,CAAC2G,UAAU,CAAC;QAC3D,MAAMqB,QAAQ,GAAGD,eAAe,GAAG,IAAI,CAAC3F,cAAc,GAAGuE,UAAU;QACnEkB,aAAa,CAAClL,GAAG,CAACgK,UAAU,EAAEvV,oBAAoB,CAAC4W,QAAQ,CAAC,CAAC;MACjE;MACA,OAAOH,aAAa,CAAC/M,GAAG,CAAC6L,UAAU,CAAC;IACxC,CAAC;IACD,IAAI,CAACjF,sBAAsB,CAACjF,OAAO,CAAC,CAACkK,UAAU,EAAEsB,aAAa,KAAK;MAC/D,IAAItB,UAAU,KAAK,IAAI,EAAE;QACrB,MAAMuB,WAAW,GAAGJ,gBAAgB,CAACnB,UAAU,CAAC;QAChD,IAAI,CAACgB,qBAAqB,CAACM,aAAa,EAAEhZ,YAAY,EAAE,eAAe,CAAC;QACxE,IAAI,CAAC0Y,qBAAqB,CAACM,aAAa,EAAEhZ,YAAY,EAAE,UAAU,CAAC;QACnEc,2BAA2B,CAACoY,eAAe,CAACF,aAAa,CAAC,EAAEC,WAAW,CAAC;MAC5E;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAI,CAACP,qBAAqB,CAACM,aAAa,EAAEhZ,YAAY,EAAE,OAAO,CAAC;IACpE,CAAC,CAAC;IACF,IAAI,CAACyS,sBAAsB,CAACzK,KAAK,CAAC,CAAC;EACvC;EACAoP,sBAAsBA,CAAA,EAAG;IACrB,MAAM+B,mBAAmB,GAAIC,KAAK,IAAM1Q,IAAI,IAAK;MAC7C,MAAM0I,QAAQ,GAAGgI,KAAK,KAAKpZ,YAAY,GAAG,IAAI,CAACuS,SAAS,CAAClB,SAAS,GAAG,IAAI,CAACkB,SAAS,CAACkC,SAAS;MAC7F,MAAM1G,QAAQ,GAAGqD,QAAQ,CAACjL,OAAO,CAACuC,IAAI,CAAC;MACvC,IAAI,IAAI,CAAC2Q,oBAAoB,CAACtL,QAAQ,CAAC8D,SAAS,CAAC,EAAE;QAC/C,IAAI,CAACyH,6BAA6B,CAAC5Q,IAAI,EAAE0Q,KAAK,CAAC;MACnD;IACJ,CAAC;IACD,IAAI,CAACjH,cAAc,CAAC3E,OAAO,CAAC2L,mBAAmB,CAACnZ,YAAY,CAAC,CAAC;IAC9D,IAAI,CAACoS,cAAc,CAAC5E,OAAO,CAAC2L,mBAAmB,CAAC/Y,WAAW,CAAC,CAAC;IAC7D,IAAI,CAAC+R,cAAc,CAACnK,KAAK,CAAC,CAAC;IAC3B,IAAI,CAACoK,cAAc,CAACpK,KAAK,CAAC,CAAC;EAC/B;EACA;AACJ;AACA;AACA;EACIyO,6BAA6BA,CAAC/N,IAAI,EAAE;IAChC,MAAM6Q,QAAQ,GAAGC,qBAAqB,CAAC9Q,IAAI,CAAC,IAAI+Q,UAAU,CAAC/Q,IAAI,CAAC;IAChE;IACA;IACA;IACA;IACA,IAAI,CAAC6Q,QAAQ,IAAI,IAAI,CAACrG,6BAA6B,CAAC1E,GAAG,CAAC9F,IAAI,CAAC,EAAE;MAC3D;IACJ;IACA,IAAI,CAACwK,6BAA6B,CAAC5I,GAAG,CAAC5B,IAAI,CAAC;IAC5C;IACA;IACA;IACA;IACA;IACA,MAAMgR,WAAW,GAAGhR,IAAI,CAAC1H,WAAW,CAAC;IACrC;IACA,IAAI,IAAI,CAACiS,wBAAwB,CAACnL,IAAI,KAAK,CAAC,EACxC;IACJ,IAAI0R,qBAAqB,CAAC9Q,IAAI,CAAC,EAAE;MAC7B;MACA,MAAMiN,GAAG,GAAGuD,eAAe,CAACxQ,IAAI,CAAC;MACjC,MAAMiR,YAAY,GAAG5B,aAAa,CAACpC,GAAG,CAACgE,YAAY,IAAI,EAAE,CAAC;MAC1D,KAAK,MAAMC,UAAU,IAAID,YAAY,EAAE;QACnC,IAAI,CAAClD,6BAA6B,CAACmD,UAAU,CAAC;MAClD;IACJ,CAAC,MACI;MACD,MAAM/H,SAAS,GAAG,CACd,GAAG6H,WAAW,CAAC7H,SAAS,EACxB,IAAI,IAAI,CAACmB,yBAAyB,CAACnH,GAAG,CAACnD,IAAI,CAAC,IAAI,EAAE,CAAC,CACtD;MACD,IAAI,IAAI,CAAC2Q,oBAAoB,CAACxH,SAAS,CAAC,EAAE;QACtC,IAAI,CAACyG,eAAe,CAACtX,WAAW,EAAE0H,IAAI,CAAC;QACvC,IAAI,CAACgQ,qBAAqB,CAAChQ,IAAI,EAAE1H,WAAW,EAAE,WAAW,CAAC;QAC1D0Y,WAAW,CAAC7H,SAAS,GAAG,IAAI,CAACgI,sBAAsB,CAAChI,SAAS,CAAC;MAClE;MACA;MACA,MAAM6B,SAAS,GAAGhL,IAAI,CAAC9H,WAAW,CAAC;MACnC,MAAMgR,OAAO,GAAGmG,aAAa,CAACrE,SAAS,CAAC9B,OAAO,CAAC;MAChD,KAAK,MAAMkI,cAAc,IAAIlI,OAAO,EAAE;QAClC,IAAI,CAAC6E,6BAA6B,CAACqD,cAAc,CAAC;MACtD;MACA;MACA;MACA,KAAK,MAAMA,cAAc,IAAIC,OAAO,CAACL,WAAW,CAAC9H,OAAO,CAAC,EAAE;QACvD,IAAIoI,qBAAqB,CAACF,cAAc,CAAC,EAAE;UACvC,IAAI,CAACnH,aAAa,CAACzM,IAAI,CAAC;YACpB+T,MAAM,EAAEH,cAAc;YACtBI,SAAS,EAAE,WAAW;YACtBC,aAAa,EAAEL,cAAc,CAACjI;UAClC,CAAC,CAAC;UACFiI,cAAc,CAACjI,SAAS,GAAG,IAAI,CAACgI,sBAAsB,CAACC,cAAc,CAACjI,SAAS,CAAC;QACpF;MACJ;IACJ;EACJ;EACAwF,iCAAiCA,CAAA,EAAG;IAChC,IAAI,CAAC/E,uBAAuB,CAAC9E,OAAO,CAAC,CAACwI,MAAM,EAAEtN,IAAI,KAAMA,IAAI,CAAC1I,YAAY,CAAC,CAACgW,MAAM,GAAGA,MAAO,CAAC;IAC5F,IAAI,CAAC1D,uBAAuB,CAACtK,KAAK,CAAC,CAAC;EACxC;EACA2L,cAAcA,CAACyG,GAAG,EAAE1C,UAAU,EAAE;IAC5B,KAAK,MAAMnM,KAAK,IAAI6O,GAAG,EAAE;MACrB,IAAIjM,KAAK,CAACC,OAAO,CAAC7C,KAAK,CAAC,EAAE;QACtB,IAAI,CAACoI,cAAc,CAACpI,KAAK,EAAEmM,UAAU,CAAC;MAC1C,CAAC,MACI;QACD,IAAI,CAAC2C,SAAS,CAAC9O,KAAK,EAAEmM,UAAU,CAAC;MACrC;IACJ;EACJ;EACAtD,iBAAiBA,CAACL,QAAQ,EAAEhG,QAAQ,EAAE;IAClC;IACA,IAAI,CAACuK,eAAe,CAAC1X,WAAW,EAAEmT,QAAQ,CAAC;IAC3C,IAAI,CAACuE,eAAe,CAACtX,WAAW,EAAE+S,QAAQ,CAAC;IAC3C7S,oBAAoB,CAAC6S,QAAQ,EAAEhG,QAAQ,CAAC;EAC5C;EACAwG,uCAAuCA,CAAC7L,IAAI,EAAE;IAC1C,MAAM0N,eAAe,GAAGlX,wBAAwB,CAACwJ,IAAI,CAAC;IACtD,IAAI0N,eAAe,EAAE;MACjB,IAAI,CAAClE,2BAA2B,CAAC5H,GAAG,CAAC5B,IAAI,CAAC;IAC9C;EACJ;EACA2R,SAASA,CAAC3R,IAAI,EAAEgP,UAAU,EAAE;IACxB;IACA;IACA,IAAI,CAACnD,uCAAuC,CAAC7L,IAAI,CAAC;IAClD,MAAM2I,SAAS,GAAG,IAAI,CAACkB,SAAS,CAAClB,SAAS,CAAClL,OAAO,CAACuC,IAAI,CAAC;IACxD,IAAI2I,SAAS,EAAE;MACX;MACA;MACA;MACA,IAAIrS,gCAAgC,CAAC0J,IAAI,CAAC,IAAI,CAACA,IAAI,CAACkM,cAAc,CAAC5U,YAAY,CAAC,EAAE;QAC9E,IAAI,CAAC+R,iBAAiB,CAACzH,GAAG,CAAC5B,IAAI,CAAC;MACpC;MACA,IAAI,CAACyJ,cAAc,CAAC7H,GAAG,CAAC5B,IAAI,CAAC;MAC7B;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAI,CAAC,IAAI,CAAC+J,sBAAsB,CAACjE,GAAG,CAAC9F,IAAI,CAAC,IACtC,IAAI,CAAC+J,sBAAsB,CAAC5G,GAAG,CAACnD,IAAI,CAAC,KAAKoI,qBAAqB,CAACE,WAAW,EAAE;QAC7E,IAAI,CAACyB,sBAAsB,CAAC/E,GAAG,CAAChF,IAAI,EAAEgP,UAAU,CAAC;MACrD;MACA;IACJ;IACA,MAAMjD,SAAS,GAAG,IAAI,CAAClC,SAAS,CAACkC,SAAS,CAACtO,OAAO,CAACuC,IAAI,CAAC;IACxD,IAAI+L,SAAS,EAAE;MACX,IAAI,CAAC/L,IAAI,CAACkM,cAAc,CAACxU,WAAW,CAAC,EAAE;QACnC,IAAI,CAAC4R,iBAAiB,CAAC1H,GAAG,CAAC5B,IAAI,CAAC;MACpC;MACA,IAAI,CAAC0J,cAAc,CAAC9H,GAAG,CAAC5B,IAAI,CAAC;MAC7B;IACJ;IACA,MAAMiM,IAAI,GAAG,IAAI,CAACpC,SAAS,CAACoC,IAAI,CAACxO,OAAO,CAACuC,IAAI,CAAC;IAC9C,IAAIiM,IAAI,IAAI,CAACjM,IAAI,CAACkM,cAAc,CAACpU,YAAY,CAAC,EAAE;MAC5C,IAAI,CAACyR,YAAY,CAAC3H,GAAG,CAAC5B,IAAI,CAAC;MAC3B;IACJ;EACJ;EACAkL,0BAA0BA,CAACwG,GAAG,EAAE;IAC5B;IACA;IACA;IACA;IACA,MAAME,aAAa,GAAG,IAAI7S,GAAG,CAAC,CAAC;IAC/B,MAAM8S,+BAA+B,GAAIH,GAAG,IAAK;MAC7C,KAAK,MAAM7O,KAAK,IAAI6O,GAAG,EAAE;QACrB,IAAIjM,KAAK,CAACC,OAAO,CAAC7C,KAAK,CAAC,EAAE;UACtBgP,+BAA+B,CAAChP,KAAK,CAAC;QAC1C,CAAC,MACI,IAAIiP,cAAc,CAACjP,KAAK,CAAC,EAAE;UAC5B,MAAMoK,GAAG,GAAGpK,KAAK,CAACyM,IAAI;UACtB,IAAIsC,aAAa,CAAC9L,GAAG,CAACmH,GAAG,CAAC,EAAE;YACxB;UACJ;UACA2E,aAAa,CAAChQ,GAAG,CAACqL,GAAG,CAAC;UACtB;UACA;UACA,IAAI,CAAChC,cAAc,CAACoE,aAAa,CAACpC,GAAG,CAAChE,YAAY,CAAC,EAAEpG,KAAK,CAAC;UAC3DgP,+BAA+B,CAACxC,aAAa,CAACpC,GAAG,CAAC/D,OAAO,CAAC,CAAC;UAC3D2I,+BAA+B,CAACxC,aAAa,CAACpC,GAAG,CAAC8E,OAAO,CAAC,CAAC;QAC/D,CAAC,MACI,IAAIT,qBAAqB,CAACzO,KAAK,CAAC,EAAE;UACnCgP,+BAA+B,CAAC,CAAChP,KAAK,CAACwI,QAAQ,CAAC,CAAC;QACrD,CAAC,MACI,IAAIyF,qBAAqB,CAACjO,KAAK,CAAC,EAAE;UACnC,IAAI,CAAC8O,SAAS,CAAC9O,KAAK,EAAE,IAAI,CAAC;UAC3B,MAAMoK,GAAG,GAAGuD,eAAe,CAAC3N,KAAK,CAAC;UAClC,IAAI+O,aAAa,CAAC9L,GAAG,CAACmH,GAAG,CAAC,EAAE;YACxB;UACJ;UACA2E,aAAa,CAAChQ,GAAG,CAACqL,GAAG,CAAC;UACtB,MAAMgE,YAAY,GAAG5B,aAAa,CAACpC,GAAG,CAACgE,YAAY,IAAI,EAAE,CAAC;UAC1DA,YAAY,CAACnM,OAAO,CAAEoM,UAAU,IAAK;YACjC;YACA;YACA;YACA;YACA,IAAIJ,qBAAqB,CAACI,UAAU,CAAC,IAAIY,cAAc,CAACZ,UAAU,CAAC,EAAE;cACjEW,+BAA+B,CAAC,CAACX,UAAU,CAAC,CAAC;YACjD,CAAC,MACI;cACD,IAAI,CAACS,SAAS,CAACT,UAAU,EAAE,IAAI,CAAC;YACpC;UACJ,CAAC,CAAC;QACN;MACJ;IACJ,CAAC;IACDW,+BAA+B,CAACH,GAAG,CAAC;EACxC;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA3B,iCAAiCA,CAAC2B,GAAG,EAAE;IACnC,MAAMM,WAAW,GAAG,IAAIjT,GAAG,CAAC,CAAC;IAC7B,MAAM+Q,eAAe,GAAG,IAAI/Q,GAAG,CAAC,CAAC;IACjC,MAAMkT,wBAAwB,GAAGA,CAACP,GAAG,EAAEQ,IAAI,KAAK;MAC5C,KAAK,MAAMrP,KAAK,IAAI6O,GAAG,EAAE;QACrB,IAAIjM,KAAK,CAACC,OAAO,CAAC7C,KAAK,CAAC,EAAE;UACtB;UACA;UACAoP,wBAAwB,CAACpP,KAAK,EAAEqP,IAAI,CAAC;QACzC,CAAC,MACI,IAAIJ,cAAc,CAACjP,KAAK,CAAC,EAAE;UAC5B,IAAImP,WAAW,CAAClM,GAAG,CAACjD,KAAK,CAAC,EAAE;YACxB;YACA;YACA;YACA,IAAIiN,eAAe,CAAChK,GAAG,CAACjD,KAAK,CAAC,EAAE;cAC5BqP,IAAI,CAACpN,OAAO,CAAEqN,IAAI,IAAKrC,eAAe,CAAClO,GAAG,CAACuQ,IAAI,CAAC,CAAC;YACrD;YACA;UACJ;UACAH,WAAW,CAACpQ,GAAG,CAACiB,KAAK,CAAC;UACtB,IAAI,IAAI,CAAC8G,iBAAiB,CAAC7D,GAAG,CAACjD,KAAK,CAAC,EAAE;YACnCqP,IAAI,CAACpN,OAAO,CAAEqN,IAAI,IAAKrC,eAAe,CAAClO,GAAG,CAACuQ,IAAI,CAAC,CAAC;UACrD;UACA;UACA,MAAMnH,SAAS,GAAGnI,KAAK,CAAC3K,WAAW,CAAC;UACpC+Z,wBAAwB,CAAC5C,aAAa,CAACrE,SAAS,CAAC9B,OAAO,CAAC,EAAEgJ,IAAI,CAAClM,MAAM,CAACnD,KAAK,CAAC,CAAC;QAClF;MACJ;IACJ,CAAC;IACDoP,wBAAwB,CAACP,GAAG,EAAE,EAAE,CAAC;IACjC,OAAO5B,eAAe;EAC1B;EACA;AACJ;AACA;AACA;AACA;AACA;EACIF,eAAeA,CAAC7K,IAAI,EAAE/E,IAAI,EAAE;IACxB,IAAI,CAAC,IAAI,CAACgK,aAAa,CAAClE,GAAG,CAAC9F,IAAI,CAAC,EAAE;MAC/B,IAAI,CAACgK,aAAa,CAAChF,GAAG,CAAChF,IAAI,EAAE,IAAIuE,GAAG,CAAC,CAAC,CAAC;IAC3C;IACA,MAAM6N,WAAW,GAAG,IAAI,CAACpI,aAAa,CAAC7G,GAAG,CAACnD,IAAI,CAAC;IAChD,IAAI,CAACoS,WAAW,CAACtM,GAAG,CAACf,IAAI,CAAC,EAAE;MACxB,MAAMsN,UAAU,GAAGzL,MAAM,CAACO,wBAAwB,CAACnH,IAAI,EAAE+E,IAAI,CAAC;MAC9DqN,WAAW,CAACpN,GAAG,CAACD,IAAI,EAAEsN,UAAU,CAAC;IACrC;EACJ;EACArC,qBAAqBA,CAAChQ,IAAI,EAAEsS,QAAQ,EAAEd,SAAS,EAAE;IAC7C,MAAMvE,GAAG,GAAGjN,IAAI,CAACsS,QAAQ,CAAC;IAC1B,MAAMb,aAAa,GAAGxE,GAAG,CAACuE,SAAS,CAAC;IACpC,IAAI,CAACvH,aAAa,CAACzM,IAAI,CAAC;MAAE+T,MAAM,EAAEtE,GAAG;MAAEuE,SAAS;MAAEC;IAAc,CAAC,CAAC;EACtE;EACA;AACJ;AACA;AACA;AACA;EACIvD,6BAA6BA,CAAA,EAAG;IAC5B,IAAI,IAAI,CAAClF,gCAAgC,KAAK,IAAI,EAAE;MAChD,IAAI,CAACA,gCAAgC,GAAG,IAAIzE,GAAG,CAAC,CAAC;IACrD;IACA7L,yCAAyC,CAAC,CAAC,CAACoM,OAAO,CAAC,CAACjC,KAAK,EAAEwD,GAAG,KAAK,IAAI,CAAC2C,gCAAgC,CAAChE,GAAG,CAACqB,GAAG,EAAExD,KAAK,CAAC,CAAC;EAC9H;EACA;AACJ;AACA;AACA;AACA;EACI0P,+BAA+BA,CAAA,EAAG;IAC9B,IAAI,IAAI,CAACvJ,gCAAgC,KAAK,IAAI,EAAE;MAChDpQ,gCAAgC,CAAC,IAAI,CAACoQ,gCAAgC,CAAC;MACvE,IAAI,CAACA,gCAAgC,GAAG,IAAI;IAChD;EACJ;EACAwJ,oBAAoBA,CAAA,EAAG;IACnB;IACA;IACAC,YAAY,CAAC,IAAI,CAACxI,aAAa,EAAGyI,EAAE,IAAK;MACrCA,EAAE,CAACnB,MAAM,CAACmB,EAAE,CAAClB,SAAS,CAAC,GAAGkB,EAAE,CAACjB,aAAa;IAC9C,CAAC,CAAC;IACF;IACA,IAAI,CAACzH,aAAa,CAAClF,OAAO,CAAC,CAAC6N,IAAI,EAAE3S,IAAI,KAAK;MACvC,IAAIjK,iCAAiC,EAAE;QACnCE,YAAY,CAACqV,kBAAkB,CAACtL,IAAI,CAAC;MACzC;MACA2S,IAAI,CAAC7N,OAAO,CAAC,CAAC8N,UAAU,EAAE7N,IAAI,KAAK;QAC/B,IAAI,CAAC6N,UAAU,EAAE;UACb;UACA;UACA;UACA;UACA;UACA;UACA,OAAO5S,IAAI,CAAC+E,IAAI,CAAC;QACrB,CAAC,MACI;UACD6B,MAAM,CAACiM,cAAc,CAAC7S,IAAI,EAAE+E,IAAI,EAAE6N,UAAU,CAAC;QACjD;MACJ,CAAC,CAAC;IACN,CAAC,CAAC;IACF,IAAI,CAAC5I,aAAa,CAAC1K,KAAK,CAAC,CAAC;IAC1B,IAAI,CAACkL,6BAA6B,CAAClL,KAAK,CAAC,CAAC;IAC1C,IAAI,CAACiT,+BAA+B,CAAC,CAAC;IACtC;IACArb,YAAY,CAACF,kBAAkB,CAAC;EACpC;EACAwX,iBAAiBA,CAAA,EAAG;IAChB,MAAMsE,eAAe,CAAC;IAEtBta,oBAAoB,CAACsa,eAAe,EAAE;MAClC3J,SAAS,EAAE,CACP,GAAG,IAAI,CAACkB,qBAAqB,EAC7BvR,mCAAmC,CAAC,CAAC,CAAC,CAAC,EACvC6F,8BAA8B,EAC9B;QAAE4N,OAAO,EAAExX,yBAAyB;QAAEge,WAAW,EAAE/Z;MAA8B,CAAC;IAE1F,CAAC,CAAC;IACF,MAAMmQ,SAAS,GAAG,CACd;MAAEoD,OAAO,EAAEtT,QAAQ;MAAEqT,UAAU,EAAEA,CAAA,KAAM,IAAI0G,cAAc,CAAC,IAAI;IAAE,CAAC,EACjE;MAAEzG,OAAO,EAAEpT,mBAAmB;MAAEuT,QAAQ,EAAE;QAAEuG,QAAQ,EAAE,IAAI,CAACtI;MAAmB;IAAE,CAAC,EACjF;MACI4B,OAAO,EAAElT,mCAAmC;MAC5CiT,UAAU,EAAEA,CAAA,KAAM;QACd,IAAI,IAAI,CAAC1B,4BAA4B,EAAE;UACnC,MAAMsI,OAAO,GAAG/e,QAAQ,CAACwK,8BAA8B,CAAC;UACxD,OAAQM,CAAC,IAAK;YACViU,OAAO,CAAClU,WAAW,CAACC,CAAC,CAAC;UAC1B,CAAC;QACL,CAAC,MACI;UACD,MAAMJ,gBAAgB,GAAG1K,QAAQ,CAACE,YAAY,CAAC;UAC/C,MAAMmN,MAAM,GAAGrN,QAAQ,CAACC,MAAM,CAAC;UAC/B,OAAQ6K,CAAC,IAAKuC,MAAM,CAACtC,iBAAiB,CAAC,MAAML,gBAAgB,CAACG,WAAW,CAACC,CAAC,CAAC,CAAC;QACjF;MACJ;IACJ,CAAC,EACD,GAAG,IAAI,CAACkK,SAAS,EACjB,GAAG,IAAI,CAACiB,iBAAiB,CAC5B;IACD,MAAMlB,OAAO,GAAG,CAAC4J,eAAe,EAAE,IAAI,CAAC/J,qBAAqB,EAAE,IAAI,CAACG,OAAO,IAAI,EAAE,CAAC;IACjF1Q,oBAAoB,CAAC,IAAI,CAACiS,cAAc,EAAE;MACtCxB,YAAY,EAAE,IAAI,CAACA,YAAY;MAC/BC,OAAO;MACPE,OAAO,EAAE,IAAI,CAACA,OAAO;MACrBD;IACJ,CAAC,EACD,sCAAuC,IAAI,CAAC;IAC5C,IAAI,CAAC4E,6BAA6B,CAAC,IAAI,CAACtD,cAAc,CAAC;EAC3D;EACA,IAAIvH,QAAQA,CAAA,EAAG;IACX,IAAI,IAAI,CAACgH,SAAS,KAAK,IAAI,EAAE;MACzB,OAAO,IAAI,CAACA,SAAS;IACzB;IACA,MAAMf,SAAS,GAAG,EAAE;IACpB,MAAMgK,eAAe,GAAG,IAAI,CAACrK,QAAQ,CAAC5F,QAAQ,CAACC,GAAG,CAAC7J,gBAAgB,EAAE,EAAE,CAAC;IACxE6Z,eAAe,CAACrO,OAAO,CAAEsO,IAAI,IAAK;MAC9B,IAAIA,IAAI,CAACjK,SAAS,EAAE;QAChBA,SAAS,CAAC3L,IAAI,CAAC4V,IAAI,CAACjK,SAAS,CAAC;MAClC;IACJ,CAAC,CAAC;IACF,IAAI,IAAI,CAACgB,iBAAiB,KAAK,IAAI,EAAE;MACjChB,SAAS,CAAC3L,IAAI,CAAC,GAAG,IAAI,CAAC2M,iBAAiB,CAAC;IAC7C;IACA,IAAI,CAACD,SAAS,GAAG3Q,QAAQ,CAAC8Z,MAAM,CAAC;MAAElK,SAAS;MAAEmK,MAAM,EAAE,IAAI,CAACxK,QAAQ,CAAC5F;IAAS,CAAC,CAAC;IAC/E,OAAO,IAAI,CAACgH,SAAS;EACzB;EACA;EACAqJ,0BAA0BA,CAACnH,QAAQ,EAAE;IACjC,MAAMxM,KAAK,GAAG4T,gBAAgB,CAACpH,QAAQ,CAAC;IACxC,OAAO,IAAI,CAAC7B,wBAAwB,CAACpH,GAAG,CAACvD,KAAK,CAAC,IAAI,IAAI;EAC3D;EACA6T,oBAAoBA,CAACtK,SAAS,EAAE;IAC5B,IAAI,CAACA,SAAS,IAAI,CAACA,SAAS,CAAC5L,MAAM,IAAI,IAAI,CAACgN,wBAAwB,CAACnL,IAAI,KAAK,CAAC,EAC3E,OAAO,EAAE;IACb;IACA;IACA;IACA;IACA;IACA,OAAOiS,OAAO,CAACqC,gBAAgB,CAACvK,SAAS,EAAGiD,QAAQ,IAAK,IAAI,CAACmH,0BAA0B,CAACnH,QAAQ,CAAC,IAAI,EAAE,CAAC,CAAC;EAC9G;EACA+E,sBAAsBA,CAAChI,SAAS,EAAE;IAC9B,IAAI,CAACA,SAAS,IAAI,CAACA,SAAS,CAAC5L,MAAM,IAAI,IAAI,CAACgN,wBAAwB,CAACnL,IAAI,KAAK,CAAC,EAC3E,OAAO,EAAE;IACb,MAAMuU,kBAAkB,GAAGD,gBAAgB,CAACvK,SAAS,CAAC;IACtD,MAAM7B,SAAS,GAAG,IAAI,CAACmM,oBAAoB,CAACE,kBAAkB,CAAC;IAC/D,MAAMC,mBAAmB,GAAG,CAAC,GAAGD,kBAAkB,EAAE,GAAGrM,SAAS,CAAC;IACjE,MAAMuM,KAAK,GAAG,EAAE;IAChB,MAAMC,uBAAuB,GAAG,IAAI/U,GAAG,CAAC,CAAC;IACzC;IACA;IACA;IACA;IACA0T,YAAY,CAACmB,mBAAmB,EAAGxH,QAAQ,IAAK;MAC5C,MAAMxM,KAAK,GAAG4T,gBAAgB,CAACpH,QAAQ,CAAC;MACxC,IAAI,IAAI,CAAC7B,wBAAwB,CAACzE,GAAG,CAAClG,KAAK,CAAC,EAAE;QAC1C,IAAI,CAACkU,uBAAuB,CAAChO,GAAG,CAAClG,KAAK,CAAC,EAAE;UACrCkU,uBAAuB,CAAClS,GAAG,CAAChC,KAAK,CAAC;UAClC;UACA;UACA;UACAiU,KAAK,CAACE,OAAO,CAAC;YAAE,GAAG3H,QAAQ;YAAEK,KAAK,EAAE;UAAM,CAAC,CAAC;QAChD;MACJ,CAAC,MACI;QACDoH,KAAK,CAACE,OAAO,CAAC3H,QAAQ,CAAC;MAC3B;IACJ,CAAC,CAAC;IACF,OAAOyH,KAAK;EAChB;EACAlD,oBAAoBA,CAACxH,SAAS,EAAE;IAC5B,OAAO,IAAI,CAACsK,oBAAoB,CAACtK,SAAS,CAAC,CAAC5L,MAAM,GAAG,CAAC;EAC1D;EACAqT,6BAA6BA,CAACnB,WAAW,EAAEiB,KAAK,EAAE;IAC9C,MAAMzD,GAAG,GAAGwC,WAAW,CAACiB,KAAK,CAAC;IAC9B,IAAIzD,GAAG,IAAIA,GAAG,CAAC+G,iBAAiB,EAAE;MAC9B,IAAI,CAACpE,eAAe,CAACc,KAAK,EAAEjB,WAAW,CAAC;MACxC,MAAM/G,QAAQ,GAAGuE,GAAG,CAAC+G,iBAAiB;MACtC,MAAMC,kBAAkB,GAAI9K,SAAS,IAAK,IAAI,CAACgI,sBAAsB,CAAChI,SAAS,CAAC;MAChF,IAAI,CAAC6G,qBAAqB,CAACP,WAAW,EAAEiB,KAAK,EAAE,mBAAmB,CAAC;MACnEzD,GAAG,CAAC+G,iBAAiB,GAAIE,KAAK,IAAKxL,QAAQ,CAACwL,KAAK,EAAED,kBAAkB,CAAC;IAC1E;EACJ;AACJ;AACA,SAASnK,aAAaA,CAAA,EAAG;EACrB,OAAO;IACHyB,MAAM,EAAE,IAAIpD,gBAAgB,CAAC,CAAC;IAC9BQ,SAAS,EAAE,IAAIV,iBAAiB,CAAC,CAAC;IAClC8D,SAAS,EAAE,IAAI/D,iBAAiB,CAAC,CAAC;IAClCiE,IAAI,EAAE,IAAI/D,YAAY,CAAC;EAC3B,CAAC;AACL;AACA,SAAS4I,qBAAqBA,CAACjO,KAAK,EAAE;EAClC,MAAMoK,GAAG,GAAGuD,eAAe,CAAC3N,KAAK,CAAC;EAClC,OAAO,CAAC,CAACoK,GAAG,EAAErE,UAAU;AAC5B;AACA,SAAS4H,eAAeA,CAAC3N,KAAK,EAAE;EAC5B,OAAOA,KAAK,CAAC8M,IAAI,IAAI,IAAI;AAC7B;AACA,SAASmC,cAAcA,CAACjP,KAAK,EAAE;EAC3B,OAAOA,KAAK,CAACqJ,cAAc,CAAC,MAAM,CAAC;AACvC;AACA,SAAS6E,UAAUA,CAAClO,KAAK,EAAE;EACvB,OAAOiP,cAAc,CAACjP,KAAK,CAAC;AAChC;AACA,SAASwM,aAAaA,CAAC8E,OAAO,EAAE;EAC5B,OAAOA,OAAO,YAAYC,QAAQ,GAAGD,OAAO,CAAC,CAAC,GAAGA,OAAO;AAC5D;AACA,SAAS9C,OAAOA,CAAChS,MAAM,EAAE;EACrB,MAAMgV,GAAG,GAAG,EAAE;EACdhV,MAAM,CAACyF,OAAO,CAAEjC,KAAK,IAAK;IACtB,IAAI4C,KAAK,CAACC,OAAO,CAAC7C,KAAK,CAAC,EAAE;MACtBwR,GAAG,CAAC7W,IAAI,CAAC,GAAG6T,OAAO,CAACxO,KAAK,CAAC,CAAC;IAC/B,CAAC,MACI;MACDwR,GAAG,CAAC7W,IAAI,CAACqF,KAAK,CAAC;IACnB;EACJ,CAAC,CAAC;EACF,OAAOwR,GAAG;AACd;AACA,SAASC,UAAUA,CAACzR,KAAK,EAAE;EACvB,OAAOA,KAAK;AAChB;AACA,SAAS6Q,gBAAgBA,CAACvK,SAAS,EAAEoL,KAAK,GAAGD,UAAU,EAAE;EACrD,MAAMD,GAAG,GAAG,EAAE;EACd,KAAK,IAAIjI,QAAQ,IAAIjD,SAAS,EAAE;IAC5B,IAAInP,uBAAuB,CAACoS,QAAQ,CAAC,EAAE;MACnCA,QAAQ,GAAGA,QAAQ,CAACoI,UAAU;IAClC;IACA,IAAI/O,KAAK,CAACC,OAAO,CAAC0G,QAAQ,CAAC,EAAE;MACzBiI,GAAG,CAAC7W,IAAI,CAAC,GAAGkW,gBAAgB,CAACtH,QAAQ,EAAEmI,KAAK,CAAC,CAAC;IAClD,CAAC,MACI;MACDF,GAAG,CAAC7W,IAAI,CAAC+W,KAAK,CAACnI,QAAQ,CAAC,CAAC;IAC7B;EACJ;EACA,OAAOiI,GAAG;AACd;AACA,SAASI,gBAAgBA,CAACrI,QAAQ,EAAEsE,KAAK,EAAE;EACvC,OAAOtE,QAAQ,IAAI,OAAOA,QAAQ,KAAK,QAAQ,IAAIA,QAAQ,CAACsE,KAAK,CAAC;AACtE;AACA,SAAS8C,gBAAgBA,CAACpH,QAAQ,EAAE;EAChC,OAAOqI,gBAAgB,CAACrI,QAAQ,EAAE,SAAS,CAAC,IAAIA,QAAQ;AAC5D;AACA,SAASkF,qBAAqBA,CAACzO,KAAK,EAAE;EAClC,OAAOA,KAAK,CAACqJ,cAAc,CAAC,UAAU,CAAC;AAC3C;AACA,SAASuG,YAAYA,CAACpT,MAAM,EAAE5D,EAAE,EAAE;EAC9B,KAAK,IAAIiZ,GAAG,GAAGrV,MAAM,CAAC9B,MAAM,GAAG,CAAC,EAAEmX,GAAG,IAAI,CAAC,EAAEA,GAAG,EAAE,EAAE;IAC/CjZ,EAAE,CAAC4D,MAAM,CAACqV,GAAG,CAAC,EAAEA,GAAG,CAAC;EACxB;AACJ;AACA,SAASlJ,gBAAgBA,CAACC,IAAI,EAAEkJ,YAAY,EAAE;EAC1C,OAAO,IAAIhY,KAAK,CAAC,GAAG8O,IAAI,wBAAwBkJ,YAAY,oCAAoC,CAAC;AACrG;AACA,MAAM3B,cAAc,CAAC;EACjB4B,OAAO;EACPzY,WAAWA,CAACyY,OAAO,EAAE;IACjB,IAAI,CAACA,OAAO,GAAGA,OAAO;EAC1B;EACAC,iBAAiBA,CAAC7F,UAAU,EAAE;IAC1B,IAAI,CAAC4F,OAAO,CAAC7F,oBAAoB,CAACC,UAAU,CAAC;IAC7C,OAAO,IAAInV,gBAAgB,CAACmV,UAAU,CAAC;EAC3C;EACM8F,kBAAkBA,CAAC9F,UAAU,EAAE;IAAA,IAAA+F,MAAA;IAAA,OAAAxY,iBAAA;MACjC,MAAMwY,MAAI,CAACH,OAAO,CAAC3F,qBAAqB,CAACD,UAAU,CAAC;MACpD,OAAO,IAAInV,gBAAgB,CAACmV,UAAU,CAAC;IAAC;EAC5C;EACAgG,iCAAiCA,CAAChG,UAAU,EAAE;IAC1C,MAAMiG,eAAe,GAAG,IAAI,CAACJ,iBAAiB,CAAC7F,UAAU,CAAC;IAC1D,MAAMkG,kBAAkB,GAAG,IAAI,CAACN,OAAO,CAACxF,sBAAsB,CAACJ,UAAU,CAAC;IAC1E,OAAO,IAAIlV,4BAA4B,CAACmb,eAAe,EAAEC,kBAAkB,CAAC;EAChF;EACMC,kCAAkCA,CAACnG,UAAU,EAAE;IAAA,IAAAoG,MAAA;IAAA,OAAA7Y,iBAAA;MACjD,MAAM0Y,eAAe,SAASG,MAAI,CAACN,kBAAkB,CAAC9F,UAAU,CAAC;MACjE,MAAMkG,kBAAkB,GAAGE,MAAI,CAACR,OAAO,CAACxF,sBAAsB,CAACJ,UAAU,CAAC;MAC1E,OAAO,IAAIlV,4BAA4B,CAACmb,eAAe,EAAEC,kBAAkB,CAAC;IAAC;EACjF;EACAG,UAAUA,CAAA,EAAG,CAAE;EACfC,aAAaA,CAACtV,IAAI,EAAE,CAAE;EACtBuV,WAAWA,CAACvG,UAAU,EAAE;IACpB,MAAMwG,IAAI,GAAG,IAAI,CAACZ,OAAO,CAACzF,kBAAkB,CAAC,CAAC,CAAC1R,OAAO,CAACuR,UAAU,CAAC;IAClE,OAAQwG,IAAI,IAAIA,IAAI,CAAC9O,EAAE,IAAKzD,SAAS;EACzC;AACJ;;AAEA;AACA;AACA;AACA,IAAIwS,kBAAkB,GAAG,CAAC;AAC1B;AACA;AACA;AACA;AACA;AACA,SAASC,UAAUA,CAAA,EAAG;EAClB,OAAOC,WAAW,CAACC,QAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMD,WAAW,CAAC;EACd,OAAOE,SAAS,GAAG,IAAI;EACvB,WAAWD,QAAQA,CAAA,EAAG;IAClB,OAAQD,WAAW,CAACE,SAAS,GAAGF,WAAW,CAACE,SAAS,IAAI,IAAIF,WAAW,CAAC,CAAC;EAC9E;EACA;AACJ;AACA;AACA;EACI,OAAOG,2BAA2B;EAClC;AACJ;AACA;AACA;EACI,OAAOC,wCAAwC;EAC/C;AACJ;AACA;AACA;EACI,OAAOC,0CAA0C;EACjD;AACJ;AACA;AACA;EACIC,wBAAwB;EACxB;AACJ;AACA;AACA;EACIC,2BAA2B,GAAGhY,4BAA4B;EAC1D;AACJ;AACA;AACA;EACIiY,qCAAqC;EACrC;AACJ;AACA;AACA;EACIC,uCAAuC;EACvC;AACJ;AACA;AACA;EACIC,qCAAqC;EACrC;AACJ;AACA;AACA;EACIC,uCAAuC;EACvC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOC,mBAAmBA,CAAClL,QAAQ,EAAEvC,QAAQ,EAAEjF,OAAO,EAAE;IACpD,MAAM+Q,OAAO,GAAGe,WAAW,CAACC,QAAQ;IACpChB,OAAO,CAAC2B,mBAAmB,CAAClL,QAAQ,EAAEvC,QAAQ,EAAEjF,OAAO,CAAC;IACxD,OAAO+Q,OAAO;EAClB;EACA;AACJ;AACA;AACA;AACA;EACI,OAAO4B,oBAAoBA,CAAA,EAAG;IAC1Bb,WAAW,CAACC,QAAQ,CAACY,oBAAoB,CAAC,CAAC;EAC/C;EACA,OAAOC,iBAAiBA,CAACC,MAAM,EAAE;IAC7B,OAAOf,WAAW,CAACC,QAAQ,CAACa,iBAAiB,CAACC,MAAM,CAAC;EACzD;EACA;AACJ;AACA;AACA;EACI,OAAO3L,sBAAsBA,CAACC,SAAS,EAAE;IACrC,OAAO2K,WAAW,CAACC,QAAQ,CAAC7K,sBAAsB,CAACC,SAAS,CAAC;EACjE;EACA;AACJ;AACA;AACA;AACA;EACI,OAAOgD,iBAAiBA,CAAA,EAAG;IACvB,OAAO2H,WAAW,CAACC,QAAQ,CAAC5H,iBAAiB,CAAC,CAAC;EACnD;EACA,OAAO5C,cAAcA,CAACC,QAAQ,EAAE1G,QAAQ,EAAE;IACtC,OAAOgR,WAAW,CAACC,QAAQ,CAACxK,cAAc,CAACC,QAAQ,EAAE1G,QAAQ,CAAC;EAClE;EACA,OAAOgH,iBAAiBA,CAAChD,SAAS,EAAEhE,QAAQ,EAAE;IAC1C,OAAOgR,WAAW,CAACC,QAAQ,CAACjK,iBAAiB,CAAChD,SAAS,EAAEhE,QAAQ,CAAC;EACtE;EACA,OAAOmH,iBAAiBA,CAACC,SAAS,EAAEpH,QAAQ,EAAE;IAC1C,OAAOgR,WAAW,CAACC,QAAQ,CAAC9J,iBAAiB,CAACC,SAAS,EAAEpH,QAAQ,CAAC;EACtE;EACA,OAAOqH,YAAYA,CAACC,IAAI,EAAEtH,QAAQ,EAAE;IAChC,OAAOgR,WAAW,CAACC,QAAQ,CAAC5J,YAAY,CAACC,IAAI,EAAEtH,QAAQ,CAAC;EAC5D;EACA,OAAOgS,gBAAgBA,CAAChO,SAAS,EAAEqE,QAAQ,EAAE;IACzC,OAAO2I,WAAW,CAACC,QAAQ,CAACe,gBAAgB,CAAChO,SAAS,EAAEqE,QAAQ,CAAC;EACrE;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,OAAOD,kCAAkCA,CAACpE,SAAS,EAAEqE,QAAQ,EAAE;IAC3D,OAAO2I,WAAW,CAACC,QAAQ,CAAC7I,kCAAkC,CAACpE,SAAS,EAAEqE,QAAQ,CAAC;EACvF;EACA,OAAOb,gBAAgBA,CAACvM,KAAK,EAAEwM,QAAQ,EAAE;IACrC,OAAOuJ,WAAW,CAACC,QAAQ,CAACzJ,gBAAgB,CAACvM,KAAK,EAAEwM,QAAQ,CAAC;EACjE;EACA,OAAOlY,MAAMA,CAAC0L,KAAK,EAAEgX,aAAa,EAAEC,KAAK,EAAE;IACvC,OAAOlB,WAAW,CAACC,QAAQ,CAAC1hB,MAAM,CAAC0L,KAAK,EAAEgX,aAAa,EAAE1c,kBAAkB,CAAC2c,KAAK,CAAC,CAAC;EACvF;EACA;EACA,OAAO1T,GAAGA,CAACvD,KAAK,EAAEgX,aAAa,GAAGrd,QAAQ,CAACud,kBAAkB,EAAED,KAAK,GAAG1c,WAAW,CAAC4c,OAAO,EAAE;IACxF,OAAOpB,WAAW,CAACC,QAAQ,CAAC1hB,MAAM,CAAC0L,KAAK,EAAEgX,aAAa,EAAEC,KAAK,CAAC;EACnE;EACA;AACJ;AACA;AACA;AACA;EACI,OAAO7b,qBAAqBA,CAACS,EAAE,EAAE;IAC7B,OAAOka,WAAW,CAACC,QAAQ,CAAC5a,qBAAqB,CAACS,EAAE,CAAC;EACzD;EACA,OAAOub,eAAeA,CAACrO,SAAS,EAAE;IAC9B,OAAOgN,WAAW,CAACC,QAAQ,CAACoB,eAAe,CAACrO,SAAS,CAAC;EAC1D;EACA,OAAOsO,kBAAkBA,CAAA,EAAG;IACxB,OAAOtB,WAAW,CAACC,QAAQ,CAACqB,kBAAkB,CAAC,CAAC;EACpD;EACA,OAAOC,OAAOA,CAACC,MAAM,EAAE1b,EAAE,EAAE2b,OAAO,EAAE;IAChC,OAAOzB,WAAW,CAACC,QAAQ,CAACsB,OAAO,CAACC,MAAM,EAAE1b,EAAE,EAAE2b,OAAO,CAAC;EAC5D;EACA,WAAWtO,QAAQA,CAAA,EAAG;IAClB,OAAO6M,WAAW,CAACC,QAAQ,CAAC9M,QAAQ;EACxC;EACA,WAAWuC,QAAQA,CAAA,EAAG;IAClB,OAAOsK,WAAW,CAACC,QAAQ,CAACvK,QAAQ;EACxC;EACA,OAAOgM,YAAYA,CAAA,EAAG;IAClB,OAAO1B,WAAW,CAACC,QAAQ,CAACyB,YAAY,CAAC,CAAC;EAC9C;EACA;EACAvO,QAAQ,GAAG,IAAI;EACfuC,QAAQ,GAAG,IAAI;EACfiM,SAAS,GAAG,IAAI;EAChBC,cAAc,GAAG,IAAI;EACrBC,eAAe,GAAG,EAAE;EACpB;AACJ;AACA;AACA;AACA;EACIC,wBAAwB,GAAG,KAAK;EAChC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIlB,mBAAmBA,CAAClL,QAAQ,EAAEvC,QAAQ,EAAEjF,OAAO,EAAE;IAC7C,IAAI,IAAI,CAACiF,QAAQ,IAAI,IAAI,CAACuC,QAAQ,EAAE;MAChC,MAAM,IAAI1O,KAAK,CAAC,8DAA8D,CAAC;IACnF;IACAgZ,WAAW,CAACG,2BAA2B,GAAGjS,OAAO,EAAE6T,QAAQ;IAC3D/B,WAAW,CAACI,wCAAwC,GAAGlS,OAAO,EAAE8T,sBAAsB;IACtFhC,WAAW,CAACK,0CAA0C,GAAGnS,OAAO,EAAE+T,wBAAwB;IAC1F,IAAI,CAAC9O,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACuC,QAAQ,GAAGA,QAAQ;IACxB,IAAI,CAACiM,SAAS,GAAG,IAAIzO,eAAe,CAAC,IAAI,CAACC,QAAQ,EAAE,IAAI,CAACuC,QAAQ,CAAC;IAClE;IACA;IACA;IACA;IACAhR,oCAAoC,CAAC,IAAI,CAAC;EAC9C;EACA;AACJ;AACA;AACA;AACA;EACImc,oBAAoBA,CAAA,EAAG;IACnB,IAAI,CAACS,kBAAkB,CAAC,CAAC;IACzB,IAAI,CAACK,SAAS,GAAG,IAAI;IACrB,IAAI,CAACxO,QAAQ,GAAG,IAAI;IACpB,IAAI,CAACuC,QAAQ,GAAG,IAAI;IACpBsK,WAAW,CAACG,2BAA2B,GAAG7S,SAAS;IACnD5I,oCAAoC,CAAC,KAAK,CAAC;EAC/C;EACA4c,kBAAkBA,CAAA,EAAG;IACjB,IAAI,CAACY,8BAA8B,CAAC,CAAC;IACrCtd,wBAAwB,CAAC,CAAC;IAC1B,IAAI,IAAI,CAAC+c,SAAS,KAAK,IAAI,EAAE;MACzB,IAAI,CAACQ,QAAQ,CAACtF,oBAAoB,CAAC,CAAC;IACxC;IACA,IAAI,CAAC8E,SAAS,GAAG,IAAIzO,eAAe,CAAC,IAAI,CAACC,QAAQ,EAAE,IAAI,CAACuC,QAAQ,CAAC;IAClE;IACA5Q,4BAA4B,CAAC,IAAI,CAAC4b,qCAAqC,IAAIrY,iCAAiC,CAAC;IAC7G;IACArD,6BAA6B,CAAC,IAAI,CAAC2b,uCAAuC,IAAIrY,mCAAmC,CAAC;IAClH;IACA;IACA;IACA,IAAI;MACA,IAAI,CAAC8Z,qBAAqB,CAAC,CAAC;IAChC,CAAC,SACO;MACJ,IAAI;QACA,IAAI,IAAI,CAACC,2BAA2B,CAAC,CAAC,EAAE;UACpC,IAAI,CAACC,qBAAqB,CAAC,CAAC;QAChC;MACJ,CAAC,SACO;QACJ,IAAI,CAACV,cAAc,GAAG,IAAI;QAC1B,IAAI,CAACtB,wBAAwB,GAAGhT,SAAS;QACzC,IAAI,CAACkT,qCAAqC,GAAGlT,SAAS;QACtD,IAAI,CAACmT,uCAAuC,GAAGnT,SAAS;QACxD,IAAI,CAACiT,2BAA2B,GAAGhY,4BAA4B;MACnE;IACJ;IACA,OAAO,IAAI;EACf;EACAuY,iBAAiBA,CAACC,MAAM,EAAE;IACtB,IAAIA,MAAM,CAACwB,MAAM,IAAI,IAAI,EAAE;MACvB,MAAM,IAAIvb,KAAK,CAAC,oDAAoD,CAAC;IACzE;IACA,IAAI+Z,MAAM,CAACvN,SAAS,KAAKlG,SAAS,EAAE;MAChC,IAAI,CAAC6U,QAAQ,CAAChN,oBAAoB,CAAC4L,MAAM,CAACvN,SAAS,CAAC;IACxD;IACA,OAAO,IAAI;EACf;EACA4B,sBAAsBA,CAACC,SAAS,EAAE;IAC9B,IAAI,CAACmN,qBAAqB,CAAC,gCAAgC,EAAE,2BAA2B,CAAC;IACzF;IACA;IACA;IACA;IACA,IAAI,CAACN,8BAA8B,CAAC,CAAC;IACrC;IACA;IACA,IAAI,CAAC5B,wBAAwB,GAAGjL,SAAS,CAAC0M,QAAQ;IAClD,IAAI,CAACvB,qCAAqC,GAAGnL,SAAS,CAAC2M,sBAAsB;IAC7E,IAAI,CAACvB,uCAAuC,GAAGpL,SAAS,CAAC4M,wBAAwB;IACjF,IAAI,CAAC1B,2BAA2B,GAAGlL,SAAS,CAACL,kBAAkB,IAAIzM,4BAA4B;IAC/F;IACA;IACA,IAAI,CAACmY,qCAAqC,GAAGxb,4BAA4B,CAAC,CAAC;IAC3EJ,4BAA4B,CAAC,IAAI,CAAC2d,iCAAiC,CAAC,CAAC,CAAC;IACtE,IAAI,CAAC9B,uCAAuC,GAAGvb,6BAA6B,CAAC,CAAC;IAC9EJ,6BAA6B,CAAC,IAAI,CAAC0d,mCAAmC,CAAC,CAAC,CAAC;IACzE,IAAI,CAACP,QAAQ,CAAC/M,sBAAsB,CAACC,SAAS,CAAC;IAC/C,OAAO,IAAI;EACf;EACAgD,iBAAiBA,CAAA,EAAG;IAChB,OAAO,IAAI,CAAC8J,QAAQ,CAAC9J,iBAAiB,CAAC,CAAC;EAC5C;EACA9Z,MAAMA,CAAC0L,KAAK,EAAEgX,aAAa,EAAEC,KAAK,EAAE;IAChC,IAAIjX,KAAK,KAAK0Y,OAAO,EAAE;MACnB,OAAO,IAAI;IACf;IACA,MAAMC,SAAS,GAAG,CAAC,CAAC;IACpB,MAAMC,MAAM,GAAG,IAAI,CAAC9N,aAAa,CAACxH,QAAQ,CAACC,GAAG,CAACvD,KAAK,EAAE2Y,SAAS,EAAEre,kBAAkB,CAAC2c,KAAK,CAAC,CAAC;IAC3F,OAAO2B,MAAM,KAAKD,SAAS,GACrB,IAAI,CAACT,QAAQ,CAAC5U,QAAQ,CAACC,GAAG,CAACvD,KAAK,EAAEgX,aAAa,EAAEC,KAAK,CAAC,GACvD2B,MAAM;EAChB;EACA;EACArV,GAAGA,CAACvD,KAAK,EAAEgX,aAAa,GAAGrd,QAAQ,CAACud,kBAAkB,EAAED,KAAK,GAAG1c,WAAW,CAAC4c,OAAO,EAAE;IACjF,OAAO,IAAI,CAAC7iB,MAAM,CAAC0L,KAAK,EAAEgX,aAAa,EAAEC,KAAK,CAAC;EACnD;EACA7b,qBAAqBA,CAACS,EAAE,EAAE;IACtB,OAAOT,qBAAqB,CAAC,IAAI,CAAC9G,MAAM,CAAC+G,mBAAmB,CAAC,EAAEQ,EAAE,CAAC;EACtE;EACAyb,OAAOA,CAACC,MAAM,EAAE1b,EAAE,EAAE2b,OAAO,EAAE;IACzB,MAAMqB,MAAM,GAAGtB,MAAM,CAACuB,GAAG,CAAEC,CAAC,IAAK,IAAI,CAACzkB,MAAM,CAACykB,CAAC,CAAC,CAAC;IAChD,OAAOld,EAAE,CAACmd,KAAK,CAACxB,OAAO,EAAEqB,MAAM,CAAC;EACpC;EACArN,cAAcA,CAACC,QAAQ,EAAE1G,QAAQ,EAAE;IAC/B,IAAI,CAACwT,qBAAqB,CAAC,gBAAgB,EAAE,0BAA0B,CAAC;IACxE,IAAI,CAACL,QAAQ,CAAC1M,cAAc,CAACC,QAAQ,EAAE1G,QAAQ,CAAC;IAChD,OAAO,IAAI;EACf;EACAgH,iBAAiBA,CAAChD,SAAS,EAAEhE,QAAQ,EAAE;IACnC,IAAI,CAACwT,qBAAqB,CAAC,mBAAmB,EAAE,6BAA6B,CAAC;IAC9E,IAAI,CAACL,QAAQ,CAACnM,iBAAiB,CAAChD,SAAS,EAAEhE,QAAQ,CAAC;IACpD,OAAO,IAAI;EACf;EACAoI,kCAAkCA,CAACpE,SAAS,EAAEqE,QAAQ,EAAE;IACpD,IAAI,CAACmL,qBAAqB,CAAC,4CAA4C,EAAE,6EAA6E,CAAC;IACvJ,IAAI,CAACL,QAAQ,CAAC/K,kCAAkC,CAACpE,SAAS,EAAEqE,QAAQ,CAAC;IACrE,OAAO,IAAI;EACf;EACAlB,iBAAiBA,CAACC,SAAS,EAAEpH,QAAQ,EAAE;IACnC,IAAI,CAACwT,qBAAqB,CAAC,mBAAmB,EAAE,6BAA6B,CAAC;IAC9E,IAAI,CAACL,QAAQ,CAAChM,iBAAiB,CAACC,SAAS,EAAEpH,QAAQ,CAAC;IACpD,OAAO,IAAI;EACf;EACAqH,YAAYA,CAACC,IAAI,EAAEtH,QAAQ,EAAE;IACzB,IAAI,CAACwT,qBAAqB,CAAC,cAAc,EAAE,wBAAwB,CAAC;IACpE,IAAI,CAACL,QAAQ,CAAC9L,YAAY,CAACC,IAAI,EAAEtH,QAAQ,CAAC;IAC1C,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACIwH,gBAAgBA,CAACvM,KAAK,EAAEwM,QAAQ,EAAE;IAC9B,IAAI,CAAC+L,qBAAqB,CAAC,kBAAkB,EAAE,mBAAmB,CAAC;IACnE,IAAI,CAACL,QAAQ,CAAC3L,gBAAgB,CAACvM,KAAK,EAAEwM,QAAQ,CAAC;IAC/C,OAAO,IAAI;EACf;EACAuK,gBAAgBA,CAAChO,SAAS,EAAEqE,QAAQ,EAAE;IAClC,OAAO,IAAI,CAACrB,iBAAiB,CAAChD,SAAS,EAAE;MAAE3D,GAAG,EAAE;QAAEgI,QAAQ;QAAE6L,WAAW,EAAE;MAAK;IAAE,CAAC,CAAC;EACtF;EACA7B,eAAeA,CAAChX,IAAI,EAAE;IAClB,MAAM8Y,qBAAqB,GAAG,IAAI,CAAC5kB,MAAM,CAACkK,qBAAqB,CAAC;IAChE,MAAM2a,QAAQ,GAAG,OAAOtD,kBAAkB,EAAE,EAAE;IAC9CqD,qBAAqB,CAACza,iBAAiB,CAAC0a,QAAQ,CAAC;IACjD,IAAIviB,wBAAwB,CAACwJ,IAAI,CAAC,EAAE;MAChC,MAAM,IAAIrD,KAAK,CAAC,cAAcqD,IAAI,CAACyL,IAAI,6BAA6B,GAChE,6EAA6E,CAAC;IACtF;IACA,MAAMiE,YAAY,GAAG1P,IAAI,CAAC2P,IAAI;IAC9B,IAAI,CAACD,YAAY,EAAE;MACf,MAAM,IAAI/S,KAAK,CAAC,kBAAkBpH,UAAU,CAACyK,IAAI,CAAC,0BAA0B,CAAC;IACjF;IACA,MAAMgZ,gBAAgB,GAAG,IAAI5hB,wBAAwB,CAACsY,YAAY,CAAC;IACnE,MAAMuJ,aAAa,GAAGA,CAAA,KAAM;MACxB,MAAM/Y,YAAY,GAAG8Y,gBAAgB,CAAC3F,MAAM,CAAC9Z,QAAQ,CAAC2f,IAAI,EAAE,EAAE,EAAE,IAAIH,QAAQ,EAAE,EAAE,IAAI,CAACrO,aAAa,CAAC;MACnG,OAAO,IAAI,CAAC1P,qBAAqB,CAAC,MAAM,IAAIiF,gBAAgB,CAACC,YAAY,CAAC,CAAC;IAC/E,CAAC;IACD,MAAMiZ,QAAQ,GAAG,IAAI,CAACjlB,MAAM,CAACuK,wBAAwB,EAAE,KAAK,CAAC;IAC7D,MAAM+C,MAAM,GAAG2X,QAAQ,GAAG,IAAI,GAAG,IAAI,CAACjlB,MAAM,CAACE,MAAM,EAAE,IAAI,CAAC;IAC1D,MAAMglB,OAAO,GAAG5X,MAAM,GAAGA,MAAM,CAACiB,GAAG,CAACwW,aAAa,CAAC,GAAGA,aAAa,CAAC,CAAC;IACpE,IAAI,CAACzB,eAAe,CAACha,IAAI,CAAC4b,OAAO,CAAC;IAClC,OAAOA,OAAO;EAClB;EACA;AACJ;AACA;AACA;EACI,IAAItB,QAAQA,CAAA,EAAG;IACX,IAAI,IAAI,CAACR,SAAS,KAAK,IAAI,EAAE;MACzB,MAAM,IAAI3a,KAAK,CAAC,kDAAkD,CAAC;IACvE;IACA,OAAO,IAAI,CAAC2a,SAAS;EACzB;EACA;AACJ;AACA;AACA;EACI,IAAI5M,aAAaA,CAAA,EAAG;IAChB,IAAI,IAAI,CAAC6M,cAAc,KAAK,IAAI,EAAE;MAC9B,IAAI,CAACA,cAAc,GAAG,IAAI,CAACO,QAAQ,CAACvJ,QAAQ,CAAC,CAAC;IAClD;IACA,OAAO,IAAI,CAACgJ,cAAc;EAC9B;EACAY,qBAAqBA,CAACkB,UAAU,EAAEC,iBAAiB,EAAE;IACjD,IAAI,IAAI,CAAC/B,cAAc,KAAK,IAAI,EAAE;MAC9B,MAAM,IAAI5a,KAAK,CAAC,UAAU2c,iBAAiB,uDAAuD,GAC9F,mDAAmDD,UAAU,KAAK,CAAC;IAC3E;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIxB,8BAA8BA,CAAA,EAAG;IAC7B;IACA;IACA,IAAI,CAAC,IAAI,CAACJ,wBAAwB,IAAI,IAAI,CAACF,cAAc,KAAK,IAAI,EAAE;MAChEpc,wCAAwC,CAAC,CAAC;IAC9C;IACA,IAAI,CAACsc,wBAAwB,GAAG,IAAI;EACxC;EACAM,qBAAqBA,CAAA,EAAG;IACpB,IAAIwB,UAAU,GAAG,CAAC;IAClB,IAAI,CAAC/B,eAAe,CAAC1S,OAAO,CAAEsU,OAAO,IAAK;MACtC,IAAI;QACAA,OAAO,CAAC9V,OAAO,CAAC,CAAC;MACrB,CAAC,CACD,OAAOrE,CAAC,EAAE;QACNsa,UAAU,EAAE;QACZC,OAAO,CAACpX,KAAK,CAAC,mCAAmC,EAAE;UAC/CuG,SAAS,EAAEyQ,OAAO,CAAChZ,iBAAiB;UACpCqZ,UAAU,EAAExa;QAChB,CAAC,CAAC;MACN;IACJ,CAAC,CAAC;IACF,IAAI,CAACuY,eAAe,GAAG,EAAE;IACzB,IAAI+B,UAAU,GAAG,CAAC,IAAI,IAAI,CAACG,2BAA2B,CAAC,CAAC,EAAE;MACtD,MAAM/c,KAAK,CAAC,GAAG4c,UAAU,IAAIA,UAAU,KAAK,CAAC,GAAG,WAAW,GAAG,YAAY,GAAG,GACzE,6BAA6B,CAAC;IACtC;EACJ;EACAG,2BAA2BA,CAAA,EAAG;IAC1B,MAAMC,eAAe,GAAG,IAAI,CAAC1D,wBAAwB;IACrD,MAAM2D,kBAAkB,GAAGjE,WAAW,CAACG,2BAA2B;IAClE;IACA,IAAI,CAAC6D,eAAe,IAAI,CAACC,kBAAkB,EAAE;MACzC,OAAO7b,0CAA0C;IACrD;IACA;IACA,OAAQ4b,eAAe,EAAEE,aAAa,IAClCD,kBAAkB,EAAEC,aAAa,IACjC,IAAI,CAAC7B,2BAA2B,CAAC,CAAC;EAC1C;EACAI,iCAAiCA,CAAA,EAAG;IAChC;IACA,OAAQ,IAAI,CAACjC,qCAAqC,IAC9CR,WAAW,CAACI,wCAAwC,IACpD/X,iCAAiC;EACzC;EACAqa,mCAAmCA,CAAA,EAAG;IAClC;IACA,OAAQ,IAAI,CAACjC,uCAAuC,IAChDT,WAAW,CAACK,0CAA0C,IACtD/X,mCAAmC;EAC3C;EACA+Z,2BAA2BA,CAAA,EAAG;IAC1B,OAAQ,IAAI,CAAC/B,wBAAwB,EAAE6D,gBAAgB,IACnDnE,WAAW,CAACG,2BAA2B,EAAEgE,gBAAgB,IACzD/b,0CAA0C;EAClD;EACAgc,qBAAqBA,CAAA,EAAG;IACpB,OAAO,IAAI,CAAC7D,2BAA2B;EAC3C;EACA+B,qBAAqBA,CAAA,EAAG;IACpB;IACA,IAAI,IAAI,CAACV,cAAc,KAAK,IAAI,EAAE;MAC9B;IACJ;IACA;IACA;IACA,MAAMyC,YAAY,GAAG,IAAI,CAAC9lB,MAAM,CAACkK,qBAAqB,CAAC;IACvD,IAAI;MACA,IAAI,CAACmZ,cAAc,CAACjU,OAAO,CAAC,CAAC;IACjC,CAAC,CACD,OAAOrE,CAAC,EAAE;MACN,IAAI,IAAI,CAACya,2BAA2B,CAAC,CAAC,EAAE;QACpC,MAAMza,CAAC;MACX,CAAC,MACI;QACDua,OAAO,CAACpX,KAAK,CAAC,0CAA0C,EAAE;UACtDuG,SAAS,EAAE,IAAI,CAAC4O,cAAc,CAAC7V,QAAQ;UACvC+X,UAAU,EAAExa;QAChB,CAAC,CAAC;MACN;IACJ,CAAC,SACO;MACJ+a,YAAY,CAACzb,qBAAqB,GAAG,CAAC;IAC1C;EACJ;EACA;AACJ;AACA;AACA;AACA;EACI8Y,YAAYA,CAAA,EAAG;IACX,IAAI,CAACnjB,MAAM,CAACiB,yBAAyB,CAAC,CAACmN,KAAK,CAAC,CAAC;IAC9C,IAAI,CAACpO,MAAM,CAACe,gBAAgB,CAAC,CAACqN,KAAK,CAAC,CAAC;EACzC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMgW,OAAO,GAAG3C,WAAW;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASzhB,MAAMA,CAACijB,MAAM,EAAE1b,EAAE,EAAE;EACxB,MAAMmZ,OAAO,GAAGe,WAAW,CAACC,QAAQ;EACpC;EACA,OAAO,YAAY;IACf,OAAOhB,OAAO,CAACsC,OAAO,CAACC,MAAM,EAAE1b,EAAE,EAAE,IAAI,CAAC;EAC5C,CAAC;AACL;AACA;AACA;AACA;AACA,MAAMwe,kBAAkB,CAAC;EACrBC,UAAU;EACV/d,WAAWA,CAAC+d,UAAU,EAAE;IACpB,IAAI,CAACA,UAAU,GAAGA,UAAU;EAChC;EACAC,UAAUA,CAAA,EAAG;IACT,MAAMnP,SAAS,GAAG,IAAI,CAACkP,UAAU,CAAC,CAAC;IACnC,IAAIlP,SAAS,EAAE;MACX2K,WAAW,CAAC5K,sBAAsB,CAACC,SAAS,CAAC;IACjD;EACJ;EACA9W,MAAMA,CAACijB,MAAM,EAAE1b,EAAE,EAAE;IACf,MAAM2e,IAAI,GAAG,IAAI;IACjB;IACA,OAAO,YAAY;MACfA,IAAI,CAACD,UAAU,CAAC,CAAC;MACjB,OAAOjmB,MAAM,CAACijB,MAAM,EAAE1b,EAAE,CAAC,CAAC4e,IAAI,CAAC,IAAI,CAAC;IACxC,CAAC;EACL;AACJ;AACA,SAASC,UAAUA,CAACtP,SAAS,EAAEvP,EAAE,EAAE;EAC/B,IAAIA,EAAE,EAAE;IACJ;IACA,OAAO,YAAY;MACf,MAAMmZ,OAAO,GAAGe,WAAW,CAACC,QAAQ;MACpC,IAAI5K,SAAS,EAAE;QACX4J,OAAO,CAAC7J,sBAAsB,CAACC,SAAS,CAAC;MAC7C;MACA,OAAOvP,EAAE,CAACmd,KAAK,CAAC,IAAI,CAAC;IACzB,CAAC;EACL;EACA,OAAO,IAAIqB,kBAAkB,CAAC,MAAMjP,SAAS,CAAC;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAuP,UAAU,CAACC,UAAU,GAAGC,cAAc,CAAC,KAAK,CAAC,CAAC;AAC9C;AACA;AACA;AACA;AACA;AACAF,UAAU,CAACG,SAAS,GAAGD,cAAc,CAAC,IAAI,CAAC,CAAC;AAC5C,SAASA,cAAcA,CAACE,qBAAqB,EAAE;EAC3C,OAAO,MAAM;IACT,MAAM/F,OAAO,GAAGe,WAAW,CAACC,QAAQ;IACpC,IAAIhB,OAAO,CAACoD,2BAA2B,CAAC,CAAC,KAAK2C,qBAAqB,EAAE;MACjE/F,OAAO,CAACqC,kBAAkB,CAAC,CAAC;MAC5BtT,0BAA0B,CAAC,CAAC;IAChC;EACJ,CAAC;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMiX,oCAAoC,GAAG,EAAE;;AAE/C;AACA;AACA;AACA;AACA;AACA,MAAMC,cAAc,CAAC;EACjBC,MAAM;EACN;AACJ;AACA;AACA;EACIC,UAAU,GAAG,EAAE;EACf;AACJ;AACA;EACIC,iBAAiB,GAAG,CAAC;EACrB;AACJ;AACA;AACA;EACIC,aAAa,GAAG,IAAI;EACpB;AACJ;AACA;AACA;EACIC,cAAc,GAAG,IAAI3W,GAAG,CAAC,CAAC;EAC1B;AACJ;AACA;AACA;EACI4W,aAAa,GAAGvf,OAAO,CAAC6B,OAAO,CAAC,CAAC;EACjC;AACJ;AACA;AACA;EACI2d,qBAAqB,GAAG,CAAC;EACzB;AACJ;AACA;AACA;EACIC,qBAAqB,GAAG,KAAK;EAC7B;EACAC,kBAAkB,GAAG,IAAI;EACzB;AACJ;AACA;AACA;EACIC,WAAW;EACX;EACAC,MAAM,GAAG,CAAC;EACV;EACAC,OAAO,GAAG,CAAC;EACX;EACAC,QAAQ,GAAG,KAAK;EAChB;EACA,IAAIC,YAAYA,CAAA,EAAG;IACf,OAAO,IAAI,CAACZ,UAAU,CAAC,IAAI,CAACC,iBAAiB,CAAC;EAClD;EACA,IAAIY,SAASA,CAAA,EAAG;IACZ,OAAO,IAAI,CAACZ,iBAAiB,GAAG,CAAC;EACrC;EACA,IAAIa,YAAYA,CAAA,EAAG;IACf,OAAO,IAAI,CAACb,iBAAiB,GAAG,IAAI,CAACD,UAAU,CAACxd,MAAM,GAAG,CAAC;EAC9D;EACApB,WAAWA,CAAC2e,MAAM,EAAEgB,QAAQ,EAAE;IAC1B,IAAI,CAAChB,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACS,WAAW,GAAG,IAAI,CAACT,MAAM,CAACiB,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;IAC5D;IACA,IAAI,CAACC,yBAAyB,CAACH,QAAQ,CAAC;EAC5C;EACA;AACJ;AACA;EACIG,yBAAyBA,CAAC3N,GAAG,EAAEzK,OAAO,GAAG;IAAEqY,YAAY,EAAE;EAAK,CAAC,EAAE;IAC7D,IAAI,CAAC,IAAI,CAACZ,kBAAkB,EAAE;MAC1B,MAAM,IAAI3e,KAAK,CAAC,0DAA0D,GAAG,yBAAyB,CAAC;IAC3G;IACA,MAAMwf,mBAAmB,GAAG,IAAI,CAACpB,UAAU,CAAC,CAAC,CAAC;IAC9C,IAAI,CAACA,UAAU,CAAC,CAAC,CAAC,GAAG,IAAIqB,0BAA0B,CAAC,IAAI,CAACtB,MAAM,CAACiB,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC,EAAE,IAAIK,GAAG,CAAC/N,GAAG,CAAC,CAACgO,QAAQ,CAAC,CAAC,EAAE;MACpHC,KAAK,EAAE,CAAC;MACRlW,GAAG,EAAE8V,mBAAmB,EAAE9V,GAAG,IAAImW,MAAM,CAAC,IAAI,CAACf,OAAO,EAAE,CAAC;MACvD/U,EAAE,EAAEyV,mBAAmB,EAAEzV,EAAE,IAAI8V,MAAM,CAAC,IAAI,CAAChB,MAAM,EAAE,CAAC;MACpDiB,YAAY,EAAE,IAAI;MAClBP,YAAY,EAAErY,OAAO,EAAEqY,YAAY;MACnC7f,KAAK,EAAEwH,OAAO,CAACxH;IACnB,CAAC,CAAC;EACN;EACA;EACAqgB,4BAA4BA,CAAA,EAAG;IAC3B,OAAO,IAAI,CAACpB,kBAAkB;EAClC;EACA;AACJ;AACA;AACA;EACIqB,kCAAkCA,CAACtB,qBAAqB,EAAE;IACtD,IAAI,CAACA,qBAAqB,GAAGA,qBAAqB;EACtD;EACA;EACAuB,OAAOA,CAAA,EAAG;IACN,OAAO,IAAI,CAAC7B,UAAU,CAAC8B,KAAK,CAAC,CAAC;EAClC;EACA;EACAC,QAAQA,CAACxO,GAAG,EAAEzK,OAAO,EAAE;IACnB,MAAMkZ,OAAO,GAAG,IAAIV,GAAG,CAAC,IAAI,CAACV,YAAY,CAACrN,GAAG,CAAC;IAC9C,MAAM0O,KAAK,GAAG,IAAIX,GAAG,CAAC/N,GAAG,EAAE,IAAI,CAACqN,YAAY,CAACrN,GAAG,CAAC;IACjD,IAAI2O,cAAc;IAClB,IAAI,CAACpZ,OAAO,EAAEqZ,OAAO,IAAIrZ,OAAO,CAACqZ,OAAO,KAAK,MAAM,EAAE;MACjD;MACA,IAAIH,OAAO,CAACT,QAAQ,CAAC,CAAC,KAAKU,KAAK,CAACV,QAAQ,CAAC,CAAC,EAAE;QACzCW,cAAc,GAAG,SAAS;MAC9B,CAAC,MACI;QACDA,cAAc,GAAG,MAAM;MAC3B;IACJ,CAAC,MACI;MACDA,cAAc,GAAGpZ,OAAO,CAACqZ,OAAO;IACpC;IACA,MAAMC,UAAU,GAAGC,YAAY,CAACL,OAAO,EAAEC,KAAK,CAAC;IAC/C,MAAMK,WAAW,GAAG,IAAIC,yBAAyB,CAAC;MAC9ChP,GAAG,EAAE0O,KAAK,CAACV,QAAQ,CAAC,CAAC;MACrBjgB,KAAK,EAAEwH,OAAO,EAAExH,KAAK;MACrBogB,YAAY,EAAEU,UAAU;MACxBjB,YAAY,EAAE;IAClB,CAAC,CAAC;IACF,MAAM1D,MAAM,GAAG,IAAI+E,wBAAwB,CAAC,IAAI,CAAC;IACjD,IAAI,CAACC,iBAAiB,CAACH,WAAW,EAAE7E,MAAM,EAAE;MACxCyE,cAAc;MACdQ,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClB;MACAC,aAAa,EAAE,KAAK;MACpBR,UAAU;MACVS,IAAI,EAAE/Z,OAAO,EAAE+Z;IACnB,CAAC,CAAC;IACF,OAAO;MACHC,SAAS,EAAErF,MAAM,CAACqF,SAAS;MAC3BC,QAAQ,EAAEtF,MAAM,CAACsF;IACrB,CAAC;EACL;EACA;EACAC,SAASA,CAACC,IAAI,EAAEC,KAAK,EAAE3P,GAAG,EAAE;IACxB,IAAI,CAAC4P,kBAAkB,CAAC,MAAM,EAAEF,IAAI,EAAEC,KAAK,EAAE3P,GAAG,CAAC;EACrD;EACA;EACA6P,YAAYA,CAACH,IAAI,EAAEC,KAAK,EAAE3P,GAAG,EAAE;IAC3B,IAAI,CAAC4P,kBAAkB,CAAC,SAAS,EAAEF,IAAI,EAAEC,KAAK,EAAE3P,GAAG,CAAC;EACxD;EACA4P,kBAAkBA,CAACjB,cAAc,EAAEe,IAAI,EAAEI,MAAM,EAAE9P,GAAG,EAAE;IAClD,MAAMyO,OAAO,GAAG,IAAIV,GAAG,CAAC,IAAI,CAACV,YAAY,CAACrN,GAAG,CAAC;IAC9C,MAAM0O,KAAK,GAAG1O,GAAG,GAAG,IAAI+N,GAAG,CAAC/N,GAAG,EAAE,IAAI,CAACqN,YAAY,CAACrN,GAAG,CAAC,GAAGyO,OAAO;IACjE,MAAMI,UAAU,GAAGC,YAAY,CAACL,OAAO,EAAEC,KAAK,CAAC;IAC/C,MAAMK,WAAW,GAAG,IAAIC,yBAAyB,CAAC;MAC9ChP,GAAG,EAAE0O,KAAK,CAACV,QAAQ,CAAC,CAAC;MACrBG,YAAY,EAAE,IAAI;MAClBP,YAAY,EAAE8B;IAClB,CAAC,CAAC;IACF,MAAMxF,MAAM,GAAG,IAAI+E,wBAAwB,CAAC,IAAI,CAAC;IACjD,IAAI,CAACC,iBAAiB,CAACH,WAAW,EAAE7E,MAAM,EAAE;MACxCyE,cAAc;MACdQ,UAAU,EAAE,IAAI;MAChBC,YAAY,EAAE,IAAI;MAClB;MACAC,aAAa,EAAE,KAAK;MACpBR;IACJ,CAAC,CAAC;EACN;EACA;EACAkB,UAAUA,CAAChY,GAAG,EAAExC,OAAO,EAAE;IACrB,MAAMkZ,OAAO,GAAG,IAAIV,GAAG,CAAC,IAAI,CAACV,YAAY,CAACrN,GAAG,CAAC;IAC9C,MAAMgQ,KAAK,GAAG,IAAI,CAACC,SAAS,CAAClY,GAAG,CAAC;IACjC,IAAI,CAACiY,KAAK,EAAE;MACR,MAAME,YAAY,GAAG,IAAIC,YAAY,CAAC,aAAa,EAAE,mBAAmB,CAAC;MACzE,MAAMZ,SAAS,GAAGjiB,OAAO,CAACC,MAAM,CAAC2iB,YAAY,CAAC;MAC9C,MAAMV,QAAQ,GAAGliB,OAAO,CAACC,MAAM,CAAC2iB,YAAY,CAAC;MAC7CX,SAAS,CAACa,KAAK,CAAC,MAAM,CAAE,CAAC,CAAC;MAC1BZ,QAAQ,CAACY,KAAK,CAAC,MAAM,CAAE,CAAC,CAAC;MACzB,OAAO;QACHb,SAAS;QACTC;MACJ,CAAC;IACL;IACA,IAAIQ,KAAK,KAAK,IAAI,CAAC3C,YAAY,EAAE;MAC7B,OAAO;QACHkC,SAAS,EAAEjiB,OAAO,CAAC6B,OAAO,CAAC,IAAI,CAACke,YAAY,CAAC;QAC7CmC,QAAQ,EAAEliB,OAAO,CAAC6B,OAAO,CAAC,IAAI,CAACke,YAAY;MAC/C,CAAC;IACL;IACA,IAAI,IAAI,CAACT,cAAc,CAACpV,GAAG,CAACwY,KAAK,CAACjY,GAAG,CAAC,EAAE;MACpC,MAAMsY,cAAc,GAAG,IAAI,CAACzD,cAAc,CAAC/X,GAAG,CAACmb,KAAK,CAACjY,GAAG,CAAC;MACzD,OAAO;QACHwX,SAAS,EAAEc,cAAc,CAACd,SAAS;QACnCC,QAAQ,EAAEa,cAAc,CAACb;MAC7B,CAAC;IACL;IACA,MAAMX,UAAU,GAAGC,YAAY,CAACL,OAAO,EAAE,IAAIV,GAAG,CAACiC,KAAK,CAAChQ,GAAG,EAAE,IAAI,CAACqN,YAAY,CAACrN,GAAG,CAAC,CAAC;IACnF,MAAM+O,WAAW,GAAG,IAAIC,yBAAyB,CAAC;MAC9ChP,GAAG,EAAEgQ,KAAK,CAAChQ,GAAG;MACdjS,KAAK,EAAEiiB,KAAK,CAACM,QAAQ,CAAC,CAAC;MACvB1C,YAAY,EAAEoC,KAAK,CAACO,eAAe,CAAC,CAAC;MACrCxY,GAAG,EAAEiY,KAAK,CAACjY,GAAG;MACdK,EAAE,EAAE4X,KAAK,CAAC5X,EAAE;MACZ6V,KAAK,EAAE+B,KAAK,CAAC/B,KAAK;MAClBE,YAAY,EAAE6B,KAAK,CAAC7B;IACxB,CAAC,CAAC;IACF,IAAI,CAACrB,qBAAqB,GAAGkD,KAAK,CAAC/B,KAAK;IACxC,MAAM/D,MAAM,GAAG,IAAI+E,wBAAwB,CAAC,IAAI,CAAC;IACjD,IAAI,CAACrC,cAAc,CAAClW,GAAG,CAACsZ,KAAK,CAACjY,GAAG,EAAEmS,MAAM,CAAC;IAC1C,IAAI,CAACsG,YAAY,CAAC,MAAM;MACpB,IAAI,CAAC5D,cAAc,CAAClZ,MAAM,CAACsc,KAAK,CAACjY,GAAG,CAAC;MACrC,MAAM0Y,KAAK,GAAG,IAAI,CAACvB,iBAAiB,CAACH,WAAW,EAAE7E,MAAM,EAAE;QACtDyE,cAAc,EAAE,UAAU;QAC1BQ,UAAU,EAAE,IAAI;QAChBC,YAAY,EAAE,IAAI;QAClB;QACAC,aAAa,EAAE,KAAK;QACpBR,UAAU;QACVS,IAAI,EAAE/Z,OAAO,EAAE+Z;MACnB,CAAC,CAAC;MACF;MACA,IAAI,CAACoB,iBAAiB,CAACD,KAAK,CAAC;IACjC,CAAC,CAAC;IACF,OAAO;MACHlB,SAAS,EAAErF,MAAM,CAACqF,SAAS;MAC3BC,QAAQ,EAAEtF,MAAM,CAACsF;IACrB,CAAC;EACL;EACA;EACAmB,IAAIA,CAACpb,OAAO,EAAE;IACV,IAAI,IAAI,CAACmX,iBAAiB,KAAK,CAAC,EAAE;MAC9B,MAAMwD,YAAY,GAAG,IAAIC,YAAY,CAAC,gBAAgB,EAAE,mBAAmB,CAAC;MAC5E,MAAMZ,SAAS,GAAGjiB,OAAO,CAACC,MAAM,CAAC2iB,YAAY,CAAC;MAC9C,MAAMV,QAAQ,GAAGliB,OAAO,CAACC,MAAM,CAAC2iB,YAAY,CAAC;MAC7CX,SAAS,CAACa,KAAK,CAAC,MAAM,CAAE,CAAC,CAAC;MAC1BZ,QAAQ,CAACY,KAAK,CAAC,MAAM,CAAE,CAAC,CAAC;MACzB,OAAO;QACHb,SAAS;QACTC;MACJ,CAAC;IACL;IACA,MAAMQ,KAAK,GAAG,IAAI,CAACvD,UAAU,CAAC,IAAI,CAACC,iBAAiB,GAAG,CAAC,CAAC;IACzD,OAAO,IAAI,CAACqD,UAAU,CAACC,KAAK,CAACjY,GAAG,EAAExC,OAAO,CAAC;EAC9C;EACA;EACAqb,OAAOA,CAACrb,OAAO,EAAE;IACb,IAAI,IAAI,CAACmX,iBAAiB,KAAK,IAAI,CAACD,UAAU,CAACxd,MAAM,GAAG,CAAC,EAAE;MACvD,MAAMihB,YAAY,GAAG,IAAIC,YAAY,CAAC,mBAAmB,EAAE,mBAAmB,CAAC;MAC/E,MAAMZ,SAAS,GAAGjiB,OAAO,CAACC,MAAM,CAAC2iB,YAAY,CAAC;MAC9C,MAAMV,QAAQ,GAAGliB,OAAO,CAACC,MAAM,CAAC2iB,YAAY,CAAC;MAC7CX,SAAS,CAACa,KAAK,CAAC,MAAM,CAAE,CAAC,CAAC;MAC1BZ,QAAQ,CAACY,KAAK,CAAC,MAAM,CAAE,CAAC,CAAC;MACzB,OAAO;QACHb,SAAS;QACTC;MACJ,CAAC;IACL;IACA,MAAMQ,KAAK,GAAG,IAAI,CAACvD,UAAU,CAAC,IAAI,CAACC,iBAAiB,GAAG,CAAC,CAAC;IACzD,OAAO,IAAI,CAACqD,UAAU,CAACC,KAAK,CAACjY,GAAG,EAAExC,OAAO,CAAC;EAC9C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIsb,EAAEA,CAACC,SAAS,EAAE;IACV,MAAMC,WAAW,GAAG,IAAI,CAACjE,qBAAqB,GAAGgE,SAAS;IAC1D,IAAIC,WAAW,IAAI,IAAI,CAACtE,UAAU,CAACxd,MAAM,IAAI8hB,WAAW,GAAG,CAAC,EAAE;MAC1D;IACJ;IACA,IAAI,CAACjE,qBAAqB,GAAGiE,WAAW;IACxC,IAAI,CAACP,YAAY,CAAC,MAAM;MACpB;MACA,IAAIO,WAAW,IAAI,IAAI,CAACtE,UAAU,CAACxd,MAAM,IAAI8hB,WAAW,GAAG,CAAC,EAAE;QAC1D;MACJ;MACA,MAAMtC,OAAO,GAAG,IAAIV,GAAG,CAAC,IAAI,CAACV,YAAY,CAACrN,GAAG,CAAC;MAC9C,MAAMgQ,KAAK,GAAG,IAAI,CAACvD,UAAU,CAACsE,WAAW,CAAC;MAC1C,MAAMlC,UAAU,GAAGC,YAAY,CAACL,OAAO,EAAE,IAAIV,GAAG,CAACiC,KAAK,CAAChQ,GAAG,EAAE,IAAI,CAACqN,YAAY,CAACrN,GAAG,CAAC,CAAC;MACnF,MAAM+O,WAAW,GAAG,IAAIC,yBAAyB,CAAC;QAC9ChP,GAAG,EAAEgQ,KAAK,CAAChQ,GAAG;QACdjS,KAAK,EAAEiiB,KAAK,CAACM,QAAQ,CAAC,CAAC;QACvB1C,YAAY,EAAEoC,KAAK,CAACO,eAAe,CAAC,CAAC;QACrCxY,GAAG,EAAEiY,KAAK,CAACjY,GAAG;QACdK,EAAE,EAAE4X,KAAK,CAAC5X,EAAE;QACZ6V,KAAK,EAAE+B,KAAK,CAAC/B,KAAK;QAClBE,YAAY,EAAE6B,KAAK,CAAC7B;MACxB,CAAC,CAAC;MACF,MAAMjE,MAAM,GAAG,IAAI+E,wBAAwB,CAAC,IAAI,CAAC;MACjD,MAAMwB,KAAK,GAAG,IAAI,CAACvB,iBAAiB,CAACH,WAAW,EAAE7E,MAAM,EAAE;QACtDyE,cAAc,EAAE,UAAU;QAC1BQ,UAAU,EAAE,IAAI;QAChBC,YAAY,EAAE,IAAI;QAClB;QACAC,aAAa,EAAE,KAAK;QACpBR;MACJ,CAAC,CAAC;MACF;MACA,IAAI,CAAC6B,iBAAiB,CAACD,KAAK,CAAC;IACjC,CAAC,CAAC;EACN;EACA;EACAD,YAAYA,CAACQ,SAAS,EAAE;IACpB,IAAI,IAAI,CAACjE,qBAAqB,EAAE;MAC5BiE,SAAS,CAAC,CAAC;MACX;IACJ;IACA;IACA;IACA;IACA,IAAI,CAACnE,aAAa,GAAG,IAAI,CAACA,aAAa,CAACpY,IAAI,CAAC,MAAM;MAC/C,OAAO,IAAInH,OAAO,CAAE6B,OAAO,IAAK;QAC5B8hB,UAAU,CAAC,MAAM;UACb9hB,OAAO,CAAC,CAAC;UACT6hB,SAAS,CAAC,CAAC;QACf,CAAC,CAAC;MACN,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EACA;EACAE,gBAAgBA,CAACxf,IAAI,EAAEyf,QAAQ,EAAE5b,OAAO,EAAE;IACtC,IAAI,CAAC0X,WAAW,CAACiE,gBAAgB,CAACxf,IAAI,EAAEyf,QAAQ,EAAE5b,OAAO,CAAC;EAC9D;EACA;EACA6b,mBAAmBA,CAAC1f,IAAI,EAAEyf,QAAQ,EAAE5b,OAAO,EAAE;IACzC,IAAI,CAAC0X,WAAW,CAACmE,mBAAmB,CAAC1f,IAAI,EAAEyf,QAAQ,EAAE5b,OAAO,CAAC;EACjE;EACA;EACA8b,aAAaA,CAACZ,KAAK,EAAE;IACjB,OAAO,IAAI,CAACxD,WAAW,CAACoE,aAAa,CAACZ,KAAK,CAAC;EAChD;EACA;EACAa,OAAOA,CAAA,EAAG;IACN;IACA;IACA,IAAI,CAACrE,WAAW,GAAG,IAAI,CAACT,MAAM,CAACiB,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC;IAC5D,IAAI,CAACN,QAAQ,GAAG,IAAI;EACxB;EACA;EACAmE,UAAUA,CAAA,EAAG;IACT,OAAO,IAAI,CAACnE,QAAQ;EACxB;EACA;EACA8B,iBAAiBA,CAACH,WAAW,EAAE7E,MAAM,EAAE3U,OAAO,EAAE;IAC5C;IACA;IACA,IAAI,CAACyX,kBAAkB,GAAG,KAAK;IAC/B,IAAI,IAAI,CAACL,aAAa,EAAE;MACpB,IAAI,CAACA,aAAa,CAAC6E,MAAM,CAAC,IAAIrB,YAAY,CAAC,wBAAwB,EAAE,YAAY,CAAC,CAAC;MACnF,IAAI,CAACxD,aAAa,GAAG,IAAI;IAC7B;IACA,OAAO8E,qBAAqB,CAAC;MACzB9C,cAAc,EAAEpZ,OAAO,CAACoZ,cAAc;MACtCQ,UAAU,EAAE5Z,OAAO,CAAC4Z,UAAU;MAC9BC,YAAY,EAAE7Z,OAAO,CAAC6Z,YAAY;MAClCC,aAAa,EAAE9Z,OAAO,CAAC8Z,aAAa;MACpCR,UAAU,EAAEtZ,OAAO,CAACsZ,UAAU;MAC9B6C,MAAM,EAAExH,MAAM,CAACwH,MAAM;MACrB3C,WAAW;MACXO,IAAI,EAAE/Z,OAAO,CAAC+Z,IAAI;MAClBnB,YAAY,EAAEY,WAAW,CAACZ,YAAY;MACtCjE;IACJ,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;EACIyH,mBAAmBA,CAAChF,aAAa,EAAE;IAC/BA,aAAa,CAACiF,iBAAiB,GAAG,WAAW;IAC7C,MAAMC,IAAI,GAAG,IAAI,CAACxE,YAAY;IAC9B,IAAI,CAACwE,IAAI,EAAE;MACP,MAAM,IAAIxjB,KAAK,CAAC,qDAAqD,CAAC;IAC1E;IACA,IAAI,CAACse,aAAa,CAACwB,YAAY,EAAE;MAC7B,MAAMra,KAAK,GAAG,IAAIzF,KAAK,CAAC,6CAA6C,CAAC;MACtEse,aAAa,CAAC6E,MAAM,CAAC1d,KAAK,CAAC;MAC3B,MAAMA,KAAK;IACf;IACA;IACA,IAAI6Y,aAAa,CAACgC,cAAc,KAAK,MAAM,IAAIhC,aAAa,CAACgC,cAAc,KAAK,SAAS,EAAE;MACvF,IAAI,CAACmD,wBAAwB,CAACnF,aAAa,CAAC;IAChD,CAAC,MACI,IAAIA,aAAa,CAACgC,cAAc,KAAK,QAAQ,EAAE;MAChD,IAAI,CAACoD,gDAAgD,CAACpF,aAAa,CAAC;IACxE,CAAC,MACI;EACT;EACA;AACJ;AACA;AACA;AACA;EACImF,wBAAwBA,CAACnF,aAAa,EAAE;IACpC,IAAI,CAACoF,gDAAgD,CAACpF,aAAa,CAAC;EACxE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI+D,iBAAiBA,CAAC/D,aAAa,EAAE;IAC7B,IAAI,CAACoF,gDAAgD,CAACpF,aAAa,CAAC;IACpE;IACA,MAAMqF,aAAa,GAAGC,mBAAmB,CAAC;MACtClkB,KAAK,EAAE4e,aAAa,CAACoC,WAAW,CAACwB,eAAe,CAAC;IACrD,CAAC,CAAC;IACF,IAAI,CAAC/D,MAAM,CAAC6E,aAAa,CAACW,aAAa,CAAC;IACxC;EACJ;EACA;EACAD,gDAAgDA,CAAC;IAAEhD,WAAW;IAAEJ,cAAc;IAAEzE;EAAQ,CAAC,EAAE;IACvF,MAAMgI,aAAa,GAAG,IAAI,CAAC7E,YAAY;IACvC,MAAM8E,YAAY,GAAG,EAAE;IACvB,IAAIxD,cAAc,KAAK,UAAU,EAAE;MAC/B,IAAI,CAACjC,iBAAiB,GAAGqC,WAAW,CAACd,KAAK;MAC1C,IAAI,IAAI,CAACvB,iBAAiB,KAAK,CAAC,CAAC,EAAE;QAC/B,MAAM,IAAIre,KAAK,CAAC,gCAAgC,CAAC;MACrD;IACJ,CAAC,MACI,IAAIsgB,cAAc,KAAK,MAAM,EAAE;MAChC,IAAI,CAACjC,iBAAiB,EAAE;MACxB,IAAI,CAACI,qBAAqB,GAAG,IAAI,CAACJ,iBAAiB,CAAC,CAAC;MACrDyF,YAAY,CAACjjB,IAAI,CAAC,GAAG,IAAI,CAACud,UAAU,CAAC2F,MAAM,CAAC,IAAI,CAAC1F,iBAAiB,CAAC,CAAC;IACxE,CAAC,MACI,IAAIiC,cAAc,KAAK,SAAS,EAAE;MACnCwD,YAAY,CAACjjB,IAAI,CAACgjB,aAAa,CAAC;IACpC;IACA,IAAIvD,cAAc,KAAK,MAAM,IAAIA,cAAc,KAAK,SAAS,EAAE;MAC3D,MAAMV,KAAK,GAAG,IAAI,CAACvB,iBAAiB;MACpC,MAAM3U,GAAG,GAAG4W,cAAc,KAAK,MAAM,GAAGT,MAAM,CAAC,IAAI,CAACf,OAAO,EAAE,CAAC,GAAG,IAAI,CAACE,YAAY,CAACtV,GAAG;MACtF,MAAMsa,MAAM,GAAG,IAAIvE,0BAA0B,CAAC,IAAI,CAACtB,MAAM,CAACiB,QAAQ,CAACC,aAAa,CAAC,KAAK,CAAC,EAAEqB,WAAW,CAAC/O,GAAG,EAAE;QACtG5H,EAAE,EAAE8V,MAAM,CAAC,IAAI,CAAChB,MAAM,EAAE,CAAC;QACzBnV,GAAG;QACHkW,KAAK;QACLE,YAAY,EAAE,IAAI;QAClBpgB,KAAK,EAAEghB,WAAW,CAACuB,QAAQ,CAAC,CAAC;QAC7B1C,YAAY,EAAEmB,WAAW,CAACwB,eAAe,CAAC;MAC9C,CAAC,CAAC;MACF,IAAI,CAAC9D,UAAU,CAAC,IAAI,CAACC,iBAAiB,CAAC,GAAG2F,MAAM;IACpD;IACAnI,MAAM,CAACoI,gBAAgB,CAAC,IAAI,CAACjF,YAAY,CAAC;IAC1C,MAAMkF,uBAAuB,GAAGC,2CAA2C,CAAC;MACxEX,IAAI,EAAEK,aAAa;MACnBvD,cAAc,EAAEA;IACpB,CAAC,CAAC;IACF,IAAI,CAAC1B,WAAW,CAACoE,aAAa,CAACkB,uBAAuB,CAAC;IACvD,KAAK,MAAME,WAAW,IAAIN,YAAY,EAAE;MACpCM,WAAW,CAACnB,OAAO,CAAC,CAAC;IACzB;EACJ;EACA;EACArB,SAASA,CAAClY,GAAG,EAAE;IACX,KAAK,MAAMiY,KAAK,IAAI,IAAI,CAACvD,UAAU,EAAE;MACjC,IAAIuD,KAAK,CAACjY,GAAG,KAAKA,GAAG,EACjB,OAAOiY,KAAK;IACpB;IACA,OAAOrb,SAAS;EACpB;EACA,IAAI+d,UAAUA;EACd;EACAC,QAAQ,EAAE;IACN,MAAM,IAAItkB,KAAK,CAAC,eAAe,CAAC;EACpC;EACA;EACA,IAAIqkB,UAAUA,CAAA,EAAG;IACb,MAAM,IAAIrkB,KAAK,CAAC,eAAe,CAAC;EACpC;EACA,IAAIukB,oBAAoBA,CAACD,QAAQ,EAAE;IAC/B,MAAM,IAAItkB,KAAK,CAAC,eAAe,CAAC;EACpC;EACA,IAAIukB,oBAAoBA,CAAA,EAAG;IACvB,MAAM,IAAIvkB,KAAK,CAAC,eAAe,CAAC;EACpC;EACA,IAAIwkB,iBAAiBA;EACrB;EACAF,QAAQ,EAAE;IACN,MAAM,IAAItkB,KAAK,CAAC,eAAe,CAAC;EACpC;EACA;EACA,IAAIwkB,iBAAiBA,CAAA,EAAG;IACpB,MAAM,IAAIxkB,KAAK,CAAC,eAAe,CAAC;EACpC;EACA,IAAIykB,eAAeA;EACnB;EACAH,QAAQ,EAAE;IACN,MAAM,IAAItkB,KAAK,CAAC,eAAe,CAAC;EACpC;EACA;EACA,IAAIykB,eAAeA,CAAA,EAAG;IAClB,MAAM,IAAIzkB,KAAK,CAAC,eAAe,CAAC;EACpC;EACA0kB,WAAW,GAAG,IAAI;EAClB;EACA,IAAIC,UAAUA,CAAC3I,CAAC,EAAE;IACd,IAAI,CAAC0I,WAAW,GAAG1I,CAAC;EACxB;EACA,IAAI2I,UAAUA,CAAA,EAAG;IACb,OAAO,IAAI,CAACD,WAAW;EAC3B;EACAE,kBAAkBA,CAACC,QAAQ,EAAE;IACzB,MAAM,IAAI7kB,KAAK,CAAC,eAAe,CAAC;EACpC;EACA8kB,MAAMA,CAACD,QAAQ,EAAE;IACb,MAAM,IAAI7kB,KAAK,CAAC,eAAe,CAAC;EACpC;AACJ;AACA;AACA;AACA;AACA,MAAMyf,0BAA0B,CAAC;EAC7Bb,WAAW;EACXjN,GAAG;EACHmO,YAAY;EACZ/V,EAAE;EACFL,GAAG;EACHkW,KAAK;EACLlgB,KAAK;EACL6f,YAAY;EACZ;EACAwF,SAAS,GAAG,IAAI;EAChBvlB,WAAWA,CAACof,WAAW,EAAEjN,GAAG,EAAE;IAAE5H,EAAE;IAAEL,GAAG;IAAEkW,KAAK;IAAEE,YAAY;IAAEpgB,KAAK;IAAE6f;EAAc,CAAC,EAAE;IAClF,IAAI,CAACX,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACjN,GAAG,GAAGA,GAAG;IACd,IAAI,CAAC5H,EAAE,GAAGA,EAAE;IACZ,IAAI,CAACL,GAAG,GAAGA,GAAG;IACd,IAAI,CAACkW,KAAK,GAAGA,KAAK;IAClB,IAAI,CAACE,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACpgB,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAC6f,YAAY,GAAGA,YAAY;EACpC;EACA0C,QAAQA,CAAA,EAAG;IACP;IACA,OAAO,IAAI,CAACviB,KAAK,GAAGkK,IAAI,CAACob,KAAK,CAACpb,IAAI,CAACC,SAAS,CAAC,IAAI,CAACnK,KAAK,CAAC,CAAC,GAAG,IAAI,CAACA,KAAK;EAC3E;EACAwiB,eAAeA,CAAA,EAAG;IACd;IACA,OAAO,IAAI,CAAC3C,YAAY,GAClB3V,IAAI,CAACob,KAAK,CAACpb,IAAI,CAACC,SAAS,CAAC,IAAI,CAAC0V,YAAY,CAAC,CAAC,GAC7C,IAAI,CAACA,YAAY;EAC3B;EACAsD,gBAAgBA,CAACxf,IAAI,EAAEyf,QAAQ,EAAE5b,OAAO,EAAE;IACtC,IAAI,CAAC0X,WAAW,CAACiE,gBAAgB,CAACxf,IAAI,EAAEyf,QAAQ,EAAE5b,OAAO,CAAC;EAC9D;EACA6b,mBAAmBA,CAAC1f,IAAI,EAAEyf,QAAQ,EAAE5b,OAAO,EAAE;IACzC,IAAI,CAAC0X,WAAW,CAACmE,mBAAmB,CAAC1f,IAAI,EAAEyf,QAAQ,EAAE5b,OAAO,CAAC;EACjE;EACA8b,aAAaA,CAACZ,KAAK,EAAE;IACjB,OAAO,IAAI,CAACxD,WAAW,CAACoE,aAAa,CAACZ,KAAK,CAAC;EAChD;EACA;EACAa,OAAOA,CAAA,EAAG;IACN,MAAMgC,YAAY,GAAG,IAAIC,KAAK,CAAC,UAAU,CAAC;IAC1C,IAAI,CAAClC,aAAa,CAACiC,YAAY,CAAC;IAChC;IACA,IAAI,CAACrG,WAAW,GAAG,IAAI;EAC3B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASwE,qBAAqBA,CAAC;EAAEtC,UAAU;EAAEC,YAAY;EAAEC,aAAa;EAAER,UAAU;EAAEF,cAAc;EAAE+C,MAAM;EAAE3C,WAAW;EAAEO,IAAI;EAAEnB,YAAY;EAAEjE;AAAQ,CAAC,EAAE;EACtJ,MAAM;IAAEsJ;EAAW,CAAC,GAAGtJ,MAAM;EAC7B,MAAMuG,KAAK,GAAG,IAAI8C,KAAK,CAAC,UAAU,EAAE;IAAEE,OAAO,EAAE,KAAK;IAAEtE;EAAW,CAAC,CAAC;EACnEsB,KAAK,CAACiD,kBAAkB,GAAG,IAAI;EAC/BjD,KAAK,CAACkD,cAAc,GAAG,IAAI;EAC3BlD,KAAK,CAACmB,iBAAiB,GAAG,MAAM;EAChCnB,KAAK,CAACrB,YAAY,GAAGA,YAAY;EACjCqB,KAAK,CAACpB,aAAa,GAAGA,aAAa;EACnCoB,KAAK,CAAC5B,UAAU,GAAGA,UAAU;EAC7B4B,KAAK,CAAC9B,cAAc,GAAGA,cAAc;EACrC8B,KAAK,CAACiB,MAAM,GAAGA,MAAM;EACrBjB,KAAK,CAAC1B,WAAW,GAAGA,WAAW;EAC/B0B,KAAK,CAACnB,IAAI,GAAGA,IAAI;EACjBmB,KAAK,CAACmD,eAAe,GAAG,IAAI;EAC5BnD,KAAK,CAACoD,QAAQ,GAAG,IAAI;EACrBpD,KAAK,CAACvG,MAAM,GAAGA,MAAM;EACrBuG,KAAK,CAACtC,YAAY,GAAGA,YAAY;EACjCsC,KAAK,CAACqD,YAAY,GAAG,WAAW;EAChC,IAAIC,gBAAgB,GAAG,CAACzmB,OAAO,CAAC6B,OAAO,CAAC,CAAC,CAAC;EAC1C,IAAI6kB,uBAAuB,GAAG,KAAK;EACnCvD,KAAK,CAACwD,SAAS,GAAG,UAAU1e,OAAO,EAAE;IACjC,IAAI,CAAC,IAAI,CAAC6Z,YAAY,EAAE;MACpB,MAAM,IAAIe,YAAY,CAAC,+CAA+C,EAAE,eAAe,CAAC;IAC5F;IACA,IAAI,CAACyB,iBAAiB,GAAG,aAAa;IACtCnB,KAAK,CAACtC,YAAY,GAAG,IAAI;IACzB,MAAMvJ,OAAO,GAAGrP,OAAO,EAAEqP,OAAO;IAChC,IAAIA,OAAO,EAAE;MACTmP,gBAAgB,CAAC7kB,IAAI,CAAC0V,OAAO,CAAC,CAAC,CAAC;IACpC;IACA;IACA6L,KAAK,CAACqD,YAAY,GAAGve,OAAO,EAAE2e,MAAM,IAAIzD,KAAK,CAACqD,YAAY;IAC1DrD,KAAK,CAACkD,cAAc,GAAGpe,OAAO,EAAE4e,MAAM,IAAI1D,KAAK,CAACkD,cAAc;IAC9DlD,KAAK,CAACiD,kBAAkB,GAAGne,OAAO,EAAE6e,UAAU,IAAI3D,KAAK,CAACiD,kBAAkB;EAC9E,CAAC;EACDjD,KAAK,CAAC0D,MAAM,GAAG,YAAY;IACvB,IAAI1D,KAAK,CAACmB,iBAAiB,KAAK,WAAW,EAAE;MACzC,MAAM,IAAIzB,YAAY,CAAC,kEAAkE,GACrF,4EAA4E,EAAE,mBAAmB,CAAC;IAC1G;IACAkE,qBAAqB,CAAC5D,KAAK,CAAC;EAChC,CAAC;EACDA,KAAK,CAACyD,MAAM,GAAG,UAAUI,QAAQ,GAAG,KAAK,EAAE;IACvC,IAAI,CAACA,QAAQ,IAAI,IAAI,CAAC1C,iBAAiB,KAAK,aAAa,EAAE;MACvD,MAAM,IAAIzB,YAAY,CAAC,qEAAqE,GACxF,+DAA+D,EAAE,mBAAmB,CAAC;IAC7F;IACA,IAAI,CAACmE,QAAQ,IAAI7D,KAAK,CAACqD,YAAY,KAAK,kBAAkB,EAAE;MACxD,MAAM,IAAI3D,YAAY,CAAC,qEAAqE,GACxF,uDAAuD,EAAE,mBAAmB,CAAC;IACrF;IACA,IAAI,CAAC6D,uBAAuB,EAAE;MAC1B,MAAM,IAAI7D,YAAY,CAAC,qEAAqE,GACxF,+BAA+B,EAAE,mBAAmB,CAAC;IAC7D;IACA,IAAI,CAACyB,iBAAiB,GAAG,WAAW;IACpC1H,MAAM,CAACsJ,UAAU,CAAC7B,mBAAmB,CAAClB,KAAK,CAAC;EAChD,CAAC;EACD;EACAA,KAAK,CAACe,MAAM,GAAG,UAAU+C,MAAM,EAAE;IAC7BrK,MAAM,CAACsK,eAAe,CAACD,MAAM,CAAC;IAC9BrK,MAAM,CAACuK,cAAc,CAACF,MAAM,CAAC;EACjC,CAAC;EACD,SAASG,QAAQA,CAAA,EAAG;IAChBlB,UAAU,CAAC7G,aAAa,GAAG8D,KAAK;IAChC+C,UAAU,CAACvG,WAAW,CAACoE,aAAa,CAACZ,KAAK,CAAC;IAC3CuD,uBAAuB,GAAG,IAAI;IAC9B,IAAIvD,KAAK,CAACmB,iBAAiB,KAAK,MAAM,EAAE;MACpC4B,UAAU,CAACR,UAAU,GAAG,IAAI2B,4BAA4B,CAACnB,UAAU,CAACnG,YAAY,EAAEsB,cAAc,CAAC;MACjG,IAAI8B,KAAK,CAACqD,YAAY,KAAK,kBAAkB,EAAE;QAC3CrD,KAAK,CAACyD,MAAM,CAAC,eAAgB,IAAI,CAAC;MACtC;IACJ,CAAC,MACI;MACD;MACA;MACAzD,KAAK,CAACyD,MAAM,CAAC,eAAgB,IAAI,CAAC;IACtC;IACA5mB,OAAO,CAACgS,GAAG,CAACyU,gBAAgB,CAAC,CAACtf,IAAI,CAAC,MAAM;MACrC;MACA;MACA,IAAIyV,MAAM,CAACwH,MAAM,CAACkD,OAAO,EAAE;QACvB;MACJ;MACA,IAAInE,KAAK,KAAK+C,UAAU,CAAC7G,aAAa,EAAE;QACpC,MAAM,IAAIte,KAAK,CAAC,wDAAwD,CAAC;MAC7E;MACAmlB,UAAU,CAAC7G,aAAa,GAAG,IAAI;MAC/B,IAAI8D,KAAK,CAACmB,iBAAiB,KAAK,aAAa,EAAE;QAC3C4B,UAAU,CAAC7B,mBAAmB,CAAClB,KAAK,CAAC;MACzC;MACAoE,qBAAqB,CAACpE,KAAK,EAAE,IAAI,CAAC;MAClC,MAAMqE,oBAAoB,GAAG,IAAIvB,KAAK,CAAC,iBAAiB,EAAE;QAAEE,OAAO,EAAE,KAAK;QAAEtE;MAAW,CAAC,CAAC;MACzFqE,UAAU,CAACvG,WAAW,CAACoE,aAAa,CAACyD,oBAAoB,CAAC;MAC1D5K,MAAM,CAAC6K,eAAe,CAAC,CAAC;MACxB,IAAIvB,UAAU,CAACR,UAAU,KAAK,IAAI,EAAE;QAChCQ,UAAU,CAACR,UAAU,CAAC+B,eAAe,CAAC,CAAC;MAC3C;MACAvB,UAAU,CAACR,UAAU,GAAG,IAAI;IAChC,CAAC,EAAGuB,MAAM,IAAK;MACX,IAAIrK,MAAM,CAACwH,MAAM,CAACkD,OAAO,EAAE;QACvB;MACJ;MACA,IAAInE,KAAK,KAAK+C,UAAU,CAAC7G,aAAa,EAAE;QACpC,MAAM,IAAIte,KAAK,CAAC,wDAAwD,CAAC;MAC7E;MACAmlB,UAAU,CAAC7G,aAAa,GAAG,IAAI;MAC/B8D,KAAK,CAACmB,iBAAiB,GAAG,UAAU,CAAC,CAAC;MACtCiD,qBAAqB,CAACpE,KAAK,EAAE,KAAK,CAAC;MACnC,MAAMuE,kBAAkB,GAAG,IAAIzB,KAAK,CAAC,eAAe,EAAE;QAAEE,OAAO,EAAE,KAAK;QAAEtE;MAAW,CAAC,CAAC;MACrFqE,UAAU,CAACvG,WAAW,CAACoE,aAAa,CAAC2D,kBAAkB,CAAC;MACxD9K,MAAM,CAACuK,cAAc,CAACF,MAAM,CAAC;MAC7B,IAAIf,UAAU,CAACR,UAAU,KAAK,IAAI,EAAE;QAChCQ,UAAU,CAACR,UAAU,CAAC+B,eAAe,CAAC,CAAC;MAC3C;MACAvB,UAAU,CAACR,UAAU,GAAG,IAAI;IAChC,CAAC,CAAC;EACN;EACA0B,QAAQ,CAAC,CAAC;EACV,OAAOjE,KAAK;AAChB;AACA;AACA,SAASoE,qBAAqBA,CAACpE,KAAK,EAAEwE,UAAU,EAAE;EAC9C,IAAIxE,KAAK,CAACmB,iBAAiB,KAAK,aAAa,IAAInB,KAAK,CAACmB,iBAAiB,KAAK,UAAU,EAAE;IACrF,MAAM,IAAIvjB,KAAK,CAAC,+EAA+E,CAAC;EACpG;EACA,IAAIoiB,KAAK,CAACmB,iBAAiB,KAAK,MAAM,EAAE;IACpC;EACJ;EACA,IAAIqD,UAAU,EAAE;IACZ;IACAC,qBAAqB,CAACzE,KAAK,CAAC;IAC5B0E,sBAAsB,CAAC1E,KAAK,CAAC;EACjC;EACAA,KAAK,CAACmB,iBAAiB,GAAG,UAAU;AACxC;AACA;AACA,SAASsD,qBAAqBA,CAACzE,KAAK,EAAE;EAClC,IAAIA,KAAK,CAACmB,iBAAiB,KAAK,WAAW,IAAInB,KAAK,CAACmB,iBAAiB,KAAK,UAAU,EAAE;IACnF,MAAM,IAAIvjB,KAAK,CAAC,qEAAqE,CAAC;EAC1F;EACA;AACJ;AACA,SAAS8mB,sBAAsBA,CAAC1E,KAAK,EAAE;EACnC,IAAIA,KAAK,CAACmB,iBAAiB,KAAK,WAAW,IAAInB,KAAK,CAACmB,iBAAiB,KAAK,UAAU,EAAE;IACnF,MAAM,IAAIvjB,KAAK,CAAC,sEAAsE,CAAC;EAC3F;EACA,IAAIoiB,KAAK,CAACmB,iBAAiB,KAAK,UAAU,IAAInB,KAAK,CAACkD,cAAc,KAAK,QAAQ,EAAE;IAC7E;EACJ;EACAU,qBAAqB,CAAC5D,KAAK,CAAC;AAChC;AACA;AACA,SAAS4D,qBAAqBA,CAAC5D,KAAK,EAAE;EAClC,IAAIA,KAAK,CAACmB,iBAAiB,KAAK,WAAW,EAAE;IACzC,MAAM,IAAIvjB,KAAK,CAAC,kEAAkE,CAAC;EACvF;EACAoiB,KAAK,CAACmB,iBAAiB,GAAG,UAAU;EACpC;AACJ;AACA;AACA;AACA;AACA;AACA,SAASY,2CAA2CA,CAAC;EAAEX,IAAI;EAAElD;AAAgB,CAAC,EAAE;EAC5E,MAAM8B,KAAK,GAAG,IAAI8C,KAAK,CAAC,oBAAoB,EAAE;IAC1CE,OAAO,EAAE,KAAK;IACdtE,UAAU,EAAE;EAChB,CAAC,CAAC;EACFsB,KAAK,CAACoB,IAAI,GAAGA,IAAI;EACjBpB,KAAK,CAAC9B,cAAc,GAAGA,cAAc;EACrC,OAAO8B,KAAK;AAChB;AACA;AACA;AACA;AACA;AACA,SAASwB,mBAAmBA,CAAC;EAAElkB;AAAM,CAAC,EAAE;EACpC,MAAM0iB,KAAK,GAAG,IAAI8C,KAAK,CAAC,UAAU,EAAE;IAChCE,OAAO,EAAE,KAAK;IACdtE,UAAU,EAAE;EAChB,CAAC,CAAC;EACFsB,KAAK,CAAC1iB,KAAK,GAAGA,KAAK;EACnB,OAAO0iB,KAAK;AAChB;AACA;AACA;AACA;AACA,MAAMzB,yBAAyB,CAAC;EAC5BhP,GAAG;EACHmO,YAAY;EACZpW,GAAG;EACHK,EAAE;EACF6V,KAAK;EACLlgB,KAAK;EACL6f,YAAY;EACZ/f,WAAWA,CAAC;IAAEmS,GAAG;IAAEmO,YAAY;IAAEP,YAAY;IAAE7f,KAAK;IAAEgK,GAAG,GAAG,IAAI;IAAEK,EAAE,GAAG,IAAI;IAAE6V,KAAK,GAAG,CAAC;EAAG,CAAC,EAAE;IACxF,IAAI,CAACjO,GAAG,GAAGA,GAAG;IACd,IAAI,CAACmO,YAAY,GAAGA,YAAY;IAChC,IAAI,CAACpgB,KAAK,GAAGA,KAAK;IAClB,IAAI,CAAC6f,YAAY,GAAGA,YAAY;IAChC,IAAI,CAAC7V,GAAG,GAAGA,GAAG;IACd,IAAI,CAACK,EAAE,GAAGA,EAAE;IACZ,IAAI,CAAC6V,KAAK,GAAGA,KAAK;EACtB;EACAqC,QAAQA,CAAA,EAAG;IACP,OAAO,IAAI,CAACviB,KAAK;EACrB;EACAwiB,eAAeA,CAAA,EAAG;IACd,OAAO,IAAI,CAAC3C,YAAY;EAC5B;AACJ;AACA;AACA,SAASkB,YAAYA,CAAC+C,IAAI,EAAEuD,EAAE,EAAE;EAC5B,OAAQA,EAAE,CAACC,IAAI,KAAKxD,IAAI,CAACwD,IAAI,IACzBD,EAAE,CAACE,QAAQ,KAAKzD,IAAI,CAACyD,QAAQ,IAC7BF,EAAE,CAACG,QAAQ,KAAK1D,IAAI,CAAC0D,QAAQ,IAC7BH,EAAE,CAACI,MAAM,KAAK3D,IAAI,CAAC2D,MAAM;AACjC;AACA,MAAMb,4BAA4B,CAAC;EAC/B9C,IAAI;EACJlD,cAAc;EACda,QAAQ;EACRuF,eAAe;EACfN,cAAc;EACd5mB,WAAWA,CAACgkB,IAAI,EAAElD,cAAc,EAAE;IAC9B,IAAI,CAACkD,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAClD,cAAc,GAAGA,cAAc;IACpC,IAAI,CAACa,QAAQ,GAAG,IAAIliB,OAAO,CAAC,CAAC6B,OAAO,EAAE5B,MAAM,KAAK;MAC7C,IAAI,CAACknB,cAAc,GAAGlnB,MAAM;MAC5B,IAAI,CAACwnB,eAAe,GAAG5lB,OAAO;IAClC,CAAC,CAAC;EACN;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM8f,wBAAwB,CAAC;EAC3BuE,UAAU;EACViC,WAAW,GAAG,IAAI;EAClBnD,gBAAgB;EAChBkC,eAAe;EACfO,eAAe;EACfN,cAAc;EACdlF,SAAS;EACTC,QAAQ;EACR,IAAIkC,MAAMA,CAAA,EAAG;IACT,OAAO,IAAI,CAACgE,eAAe,CAAChE,MAAM;EACtC;EACAgE,eAAe,GAAG,IAAIC,eAAe,CAAC,CAAC;EACvC9nB,WAAWA,CAAC2lB,UAAU,EAAE;IAAA,IAAAoC,MAAA;IACpB,IAAI,CAACpC,UAAU,GAAGA,UAAU;IAC5B,IAAI,CAACjE,SAAS,GAAG,IAAIjiB,OAAO,CAAC,CAAC6B,OAAO,EAAE5B,MAAM,KAAK;MAC9C,IAAI,CAAC+kB,gBAAgB,GAAItC,KAAK,IAAK;QAC/B,IAAI,CAACyF,WAAW,GAAGzF,KAAK;QACxB7gB,OAAO,CAAC6gB,KAAK,CAAC;MAClB,CAAC;MACD,IAAI,CAACwE,eAAe,GAAGjnB,MAAM;IACjC,CAAC,CAAC;IACF,IAAI,CAACiiB,QAAQ,GAAG,IAAIliB,OAAO;MAAA,IAAAuoB,IAAA,GAAA5nB,iBAAA,CAAC,WAAOkB,OAAO,EAAE5B,MAAM,EAAK;QACnDqoB,MAAI,CAACb,eAAe,GAAG,MAAM;UACzB,IAAIa,MAAI,CAACH,WAAW,KAAK,IAAI,EAAE;YAC3B,MAAM,IAAIpnB,KAAK,CAAC,6EAA6E,CAAC;UAClG;UACAc,OAAO,CAACymB,MAAI,CAACH,WAAW,CAAC;QAC7B,CAAC;QACDG,MAAI,CAACnB,cAAc,GAAIF,MAAM,IAAK;UAC9BhnB,MAAM,CAACgnB,MAAM,CAAC;UACdqB,MAAI,CAACF,eAAe,CAACI,KAAK,CAACvB,MAAM,CAAC;QACtC,CAAC;MACL,CAAC;MAAA,iBAAAwB,EAAA,EAAAC,GAAA;QAAA,OAAAH,IAAA,CAAAvL,KAAA,OAAA2L,SAAA;MAAA;IAAA,IAAC;IACF;IACA,IAAI,CAAC1G,SAAS,CAACa,KAAK,CAAC,MAAM,CAAE,CAAC,CAAC;IAC/B,IAAI,CAACZ,QAAQ,CAACY,KAAK,CAAC,MAAM,CAAE,CAAC,CAAC;EAClC;AACJ;AAEA,SAASze,gBAAgB,EAAEzB,0BAA0B,EAAEC,wBAAwB,EAAEzC,iBAAiB,EAAEie,kBAAkB,EAAE3B,OAAO,EAAEla,qBAAqB,EAAEwc,oCAAoC,EAAE1W,oBAAoB,EAAEN,SAAS,EAAEtB,KAAK,EAAE6B,eAAe,EAAEuR,UAAU,EAAExhB,MAAM,EAAEwP,kBAAkB,EAAElB,IAAI,EAAEhH,YAAY,EAAE8e,UAAU,EAAEO,cAAc,IAAI2J,eAAe,EAAEngB,iBAAiB,IAAIogB,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}